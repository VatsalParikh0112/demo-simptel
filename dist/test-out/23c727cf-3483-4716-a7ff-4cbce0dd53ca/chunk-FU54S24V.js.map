{"version":3,"sources":["node_modules/@angular/core/fesm2022/not_found.mjs","node_modules/@angular/core/fesm2022/signal.mjs","node_modules/rxjs/dist/esm/internal/util/isFunction.js","node_modules/rxjs/dist/esm/internal/util/createErrorClass.js","node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js","node_modules/rxjs/dist/esm/internal/util/arrRemove.js","node_modules/rxjs/dist/esm/internal/Subscription.js","node_modules/rxjs/dist/esm/internal/config.js","node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js","node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js","node_modules/rxjs/dist/esm/internal/util/noop.js","node_modules/rxjs/dist/esm/internal/NotificationFactories.js","node_modules/rxjs/dist/esm/internal/util/errorContext.js","node_modules/rxjs/dist/esm/internal/Subscriber.js","node_modules/rxjs/dist/esm/internal/symbol/observable.js","node_modules/rxjs/dist/esm/internal/util/identity.js","node_modules/rxjs/dist/esm/internal/util/pipe.js","node_modules/rxjs/dist/esm/internal/Observable.js","node_modules/rxjs/dist/esm/internal/util/lift.js","node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js","node_modules/rxjs/dist/esm/internal/operators/refCount.js","node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js","node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js","node_modules/rxjs/dist/esm/internal/Subject.js","node_modules/rxjs/dist/esm/internal/BehaviorSubject.js","node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js","node_modules/rxjs/dist/esm/internal/scheduler/Action.js","node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js","node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js","node_modules/rxjs/dist/esm/internal/Scheduler.js","node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js","node_modules/rxjs/dist/esm/internal/scheduler/async.js","node_modules/rxjs/dist/esm/internal/observable/empty.js","node_modules/rxjs/dist/esm/internal/util/isScheduler.js","node_modules/rxjs/dist/esm/internal/util/args.js","node_modules/tslib/tslib.es6.mjs","node_modules/rxjs/dist/esm/internal/util/isArrayLike.js","node_modules/rxjs/dist/esm/internal/util/isPromise.js","node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js","node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js","node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js","node_modules/rxjs/dist/esm/internal/symbol/iterator.js","node_modules/rxjs/dist/esm/internal/util/isIterable.js","node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js","node_modules/rxjs/dist/esm/internal/observable/innerFrom.js","node_modules/rxjs/dist/esm/internal/util/executeSchedule.js","node_modules/rxjs/dist/esm/internal/operators/observeOn.js","node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js","node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js","node_modules/rxjs/dist/esm/internal/observable/from.js","node_modules/rxjs/dist/esm/internal/observable/of.js","node_modules/rxjs/dist/esm/internal/observable/throwError.js","node_modules/rxjs/dist/esm/internal/util/isObservable.js","node_modules/rxjs/dist/esm/internal/util/EmptyError.js","node_modules/rxjs/dist/esm/internal/operators/map.js","node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js","node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js","node_modules/rxjs/dist/esm/internal/util/createObject.js","node_modules/rxjs/dist/esm/internal/observable/combineLatest.js","node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js","node_modules/rxjs/dist/esm/internal/operators/mergeMap.js","node_modules/rxjs/dist/esm/internal/operators/mergeAll.js","node_modules/rxjs/dist/esm/internal/operators/concatAll.js","node_modules/rxjs/dist/esm/internal/observable/concat.js","node_modules/rxjs/dist/esm/internal/observable/defer.js","node_modules/rxjs/dist/esm/internal/observable/forkJoin.js","node_modules/rxjs/dist/esm/internal/operators/filter.js","node_modules/rxjs/dist/esm/internal/types.js","node_modules/rxjs/dist/esm/internal/operators/catchError.js","node_modules/rxjs/dist/esm/internal/operators/scanInternals.js","node_modules/rxjs/dist/esm/internal/operators/concatMap.js","node_modules/rxjs/dist/esm/internal/operators/debounceTime.js","node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js","node_modules/rxjs/dist/esm/internal/operators/take.js","node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js","node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js","node_modules/rxjs/dist/esm/internal/operators/finalize.js","node_modules/rxjs/dist/esm/internal/operators/first.js","node_modules/rxjs/dist/esm/internal/operators/takeLast.js","node_modules/rxjs/dist/esm/internal/operators/last.js","node_modules/rxjs/dist/esm/internal/operators/scan.js","node_modules/rxjs/dist/esm/internal/operators/skip.js","node_modules/rxjs/dist/esm/internal/operators/startWith.js","node_modules/rxjs/dist/esm/internal/operators/switchMap.js","node_modules/rxjs/dist/esm/internal/operators/takeUntil.js","node_modules/rxjs/dist/esm/internal/operators/tap.js","node_modules/rxjs/dist/esm/index.js","node_modules/@angular/core/fesm2022/untracked.mjs","node_modules/@angular/core/fesm2022/weak_ref.mjs","node_modules/@angular/core/fesm2022/primitives/signals.mjs","node_modules/@angular/core/fesm2022/primitives/di.mjs","node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs","node_modules/rxjs/dist/esm/operators/index.js","node_modules/@angular/core/fesm2022/attribute.mjs","node_modules/@angular/core/fesm2022/debug_node.mjs","node_modules/@angular/core/fesm2022/resource.mjs","node_modules/@angular/core/fesm2022/primitives/event-dispatch.mjs","node_modules/@angular/core/fesm2022/core.mjs","node_modules/@angular/compiler/fesm2022/compiler.mjs","node_modules/@angular/core/fesm2022/testing.mjs"],"sourcesContent":["/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction getCurrentInjector() {\n    return _currentInjector;\n}\nfunction setCurrentInjector(injector) {\n    const former = _currentInjector;\n    _currentInjector = injector;\n    return former;\n}\nfunction inject(token, options) {\n    const currentInjector = getCurrentInjector();\n    if (!currentInjector) {\n        throw new Error('Current injector is not set.');\n    }\n    if (!token.ɵprov) {\n        throw new Error('Token is not an injectable');\n    }\n    return currentInjector.retrieve(token, options);\n}\n\n/**\n * Value returned if the key-value pair couldn't be found in the context\n * hierarchy.\n */\nconst NOT_FOUND = Symbol('NotFound');\n/**\n * Error thrown when the key-value pair couldn't be found in the context\n * hierarchy. Context can be attached below.\n */\nclass NotFoundError extends Error {\n    name = 'ɵNotFound';\n    constructor(message) {\n        super(message);\n    }\n}\n/**\n * Type guard for checking if an unknown value is a NotFound.\n */\nfunction isNotFound(e) {\n    return e === NOT_FOUND || e?.name === 'ɵNotFound';\n}\n\nexport { NOT_FOUND, NotFoundError, getCurrentInjector, inject, isNotFound, setCurrentInjector };\n\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producers: undefined,\n    producersTail: undefined,\n    consumers: undefined,\n    consumersTail: undefined,\n    recomputing: false,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    kind: 'unknown',\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    const prevProducerLink = activeConsumer.producersTail;\n    // If the last producer we accessed is the same as the current one, we can skip adding a new\n    // link\n    if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n        return;\n    }\n    let nextProducerLink = undefined;\n    const isRecomputing = activeConsumer.recomputing;\n    if (isRecomputing) {\n        // If we're incrementally rebuilding the producers list, we want to check if the next producer\n        // in the list is the same as the one we're trying to add.\n        // If the previous producer is defined, then the next producer is just the one that follows it.\n        // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n        nextProducerLink =\n            prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n        if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n            // If the next producer is the same as the one we're trying to add, we can just update the\n            // last read version, update the tail of the producers list of this rerun, and return.\n            activeConsumer.producersTail = nextProducerLink;\n            nextProducerLink.lastReadVersion = node.version;\n            return;\n        }\n    }\n    const prevConsumerLink = node.consumersTail;\n    // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n    // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n    if (prevConsumerLink !== undefined &&\n        prevConsumerLink.consumer === activeConsumer &&\n        // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n        (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n        // If we found an existing link to the consumer we can just return.\n        return;\n    }\n    // If we got here, it means that we need to create a new link between the producer and the consumer.\n    const isLive = consumerIsLive(activeConsumer);\n    const newLink = {\n        producer: node,\n        consumer: activeConsumer,\n        // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n        // the producers list, so that we can destroy all of the old links at once.\n        nextProducer: nextProducerLink,\n        prevConsumer: prevConsumerLink,\n        lastReadVersion: node.version,\n        nextConsumer: undefined,\n    };\n    activeConsumer.producersTail = newLink;\n    if (prevProducerLink !== undefined) {\n        prevProducerLink.nextProducer = newLink;\n    }\n    else {\n        activeConsumer.producers = newLink;\n    }\n    if (isLive) {\n        producerAddLiveConsumer(node, newLink);\n    }\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        producerMarkClean(node);\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.consumers === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n            const consumer = link.consumer;\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    if (node) {\n        node.producersTail = undefined;\n        node.recomputing = true;\n    }\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node) {\n        return;\n    }\n    node.recomputing = false;\n    // We've finished incrementally rebuilding the producers list, now if there are any producers\n    // that are after producersTail, they are stale and should be removed.\n    const producersTail = node.producersTail;\n    let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n    if (toRemove !== undefined) {\n        if (consumerIsLive(node)) {\n            // For each stale link, we first unlink it from the producers list of consumers\n            do {\n                toRemove = producerRemoveLiveConsumerLink(toRemove);\n            } while (toRemove !== undefined);\n        }\n        // Now, we can truncate the producers list to remove all stale links.\n        if (producersTail !== undefined) {\n            producersTail.nextProducer = undefined;\n        }\n        else {\n            node.producers = undefined;\n        }\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    // Poll producers for change.\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n        const producer = link.producer;\n        const seenVersion = link.lastReadVersion;\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        let link = node.producers;\n        while (link !== undefined) {\n            link = producerRemoveLiveConsumerLink(link);\n        }\n    }\n    // Truncate all the linked lists to drop all connection from this node to the graph.\n    node.producers = undefined;\n    node.producersTail = undefined;\n    node.consumers = undefined;\n    node.consumersTail = undefined;\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, link) {\n    const consumersTail = node.consumersTail;\n    const wasLive = consumerIsLive(node);\n    if (consumersTail !== undefined) {\n        link.nextConsumer = consumersTail.nextConsumer;\n        consumersTail.nextConsumer = link;\n    }\n    else {\n        link.nextConsumer = undefined;\n        node.consumers = link;\n    }\n    link.prevConsumer = consumersTail;\n    node.consumersTail = link;\n    if (!wasLive) {\n        for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n            producerAddLiveConsumer(link.producer, link);\n        }\n    }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n    const producer = link.producer;\n    const nextProducer = link.nextProducer;\n    const nextConsumer = link.nextConsumer;\n    const prevConsumer = link.prevConsumer;\n    link.nextConsumer = undefined;\n    link.prevConsumer = undefined;\n    if (nextConsumer !== undefined) {\n        nextConsumer.prevConsumer = prevConsumer;\n    }\n    else {\n        producer.consumersTail = prevConsumer;\n    }\n    if (prevConsumer !== undefined) {\n        prevConsumer.nextConsumer = nextConsumer;\n    }\n    else {\n        producer.consumers = nextConsumer;\n        if (!consumerIsLive(producer)) {\n            let producerLink = producer.producers;\n            while (producerLink !== undefined) {\n                producerLink = producerRemoveLiveConsumerLink(producerLink);\n            }\n        }\n    }\n    return nextProducer;\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n    postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n    const prev = postProducerCreatedFn;\n    postProducerCreatedFn = fn;\n    return prev;\n}\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink, consumer) {\n    const producersTail = consumer.producersTail;\n    if (producersTail !== undefined) {\n        let link = consumer.producers;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === producersTail) {\n                break;\n            }\n            link = link.nextProducer;\n        } while (link !== undefined);\n    }\n    return false;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'computed',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            let wasEqual = false;\n            try {\n                newValue = node.computation();\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\n                // to track any reactive reads inside `equal`.\n                setActiveConsumer(null);\n                wasEqual =\n                    oldValue !== UNSET &&\n                        oldValue !== ERRORED &&\n                        newValue !== ERRORED &&\n                        node.equal(oldValue, newValue);\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (wasEqual) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n    throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const getter = (() => signalGetFn(node));\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    const set = (newValue) => signalSetFn(node, newValue);\n    const update = (updateFn) => signalUpdateFn(node, updateFn);\n    return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn(node) {\n    producerAccessed(node);\n    return node.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n    postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n        kind: 'signal',\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.(node);\n}\n\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\n\n","export function isFunction(value) {\n    return typeof value === 'function';\n}\n","export function createErrorClass(createImpl) {\n    const _super = (instance) => {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    const ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n","import { createErrorClass } from './createErrorClass';\nexport const UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {\n    _super(this);\n    this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n});\n","export function arrRemove(arr, item) {\n    if (arr) {\n        const index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nexport class Subscription {\n    constructor(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    unsubscribe() {\n        let errors;\n        if (!this.closed) {\n            this.closed = true;\n            const { _parentage } = this;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    for (const parent of _parentage) {\n                        parent.remove(this);\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            const { initialTeardown: initialFinalizer } = this;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            const { _finalizers } = this;\n            if (_finalizers) {\n                this._finalizers = null;\n                for (const finalizer of _finalizers) {\n                    try {\n                        execFinalizer(finalizer);\n                    }\n                    catch (err) {\n                        errors = errors !== null && errors !== void 0 ? errors : [];\n                        if (err instanceof UnsubscriptionError) {\n                            errors = [...errors, ...err.errors];\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    }\n    add(teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    }\n    _hasParent(parent) {\n        const { _parentage } = this;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    }\n    _addParent(parent) {\n        const { _parentage } = this;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    }\n    _removeParent(parent) {\n        const { _parentage } = this;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    }\n    remove(teardown) {\n        const { _finalizers } = this;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    }\n}\nSubscription.EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n})();\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n","export const config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n","export const timeoutProvider = {\n    setTimeout(handler, timeout, ...args) {\n        const { delegate } = timeoutProvider;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout(handler, timeout, ...args);\n        }\n        return setTimeout(handler, timeout, ...args);\n    },\n    clearTimeout(handle) {\n        const { delegate } = timeoutProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(() => {\n        const { onUnhandledError } = config;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n","export function noop() { }\n","export const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined))();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind,\n        value,\n        error,\n    };\n}\n","import { config } from '../config';\nlet context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        const isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            const { errorThrown, error } = context;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n","import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n    constructor(destination) {\n        super();\n        this.isStopped = false;\n        if (destination) {\n            this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(this);\n            }\n        }\n        else {\n            this.destination = EMPTY_OBSERVER;\n        }\n    }\n    static create(next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    }\n    next(value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    }\n    error(err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    complete() {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.isStopped = true;\n            super.unsubscribe();\n            this.destination = null;\n        }\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n    _complete() {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n}\nconst _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nclass ConsumerObserver {\n    constructor(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    next(value) {\n        const { partialObserver } = this;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n    error(err) {\n        const { partialObserver } = this;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    }\n    complete() {\n        const { partialObserver } = this;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n}\nexport class SafeSubscriber extends Subscriber {\n    constructor(observerOrNext, error, complete) {\n        super();\n        let partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            let context;\n            if (this && config.useDeprecatedNextContext) {\n                context = Object.create(observerOrNext);\n                context.unsubscribe = () => this.unsubscribe();\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context),\n                    error: observerOrNext.error && bind(observerOrNext.error, context),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        this.destination = new ConsumerObserver(partialObserver);\n    }\n}\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    const { onStoppedNotification } = config;\n    onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nexport const EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n","export const observable = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","export function identity(x) {\n    return x;\n}\n","import { identity } from './identity';\nexport function pipe(...fns) {\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn) => fn(prev), input);\n    };\n}\n","import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nexport class Observable {\n    constructor(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    subscribe(observerOrNext, error, complete) {\n        const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(() => {\n            const { operator, source } = this;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        this._subscribe(subscriber)\n                    :\n                        this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    }\n    _trySubscribe(sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    }\n    forEach(next, promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            const subscriber = new SafeSubscriber({\n                next: (value) => {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            this.subscribe(subscriber);\n        });\n    }\n    _subscribe(subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    }\n    [Symbol_observable]() {\n        return this;\n    }\n    pipe(...operations) {\n        return pipeFromArray(operations)(this);\n    }\n    toPromise(promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            let value;\n            this.subscribe((x) => (value = x), (err) => reject(err), () => resolve(value));\n        });\n    }\n}\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return (source) => {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n","import { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nexport class OperatorSubscriber extends Subscriber {\n    constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        super(destination);\n        this.onFinalize = onFinalize;\n        this.shouldUnsubscribe = shouldUnsubscribe;\n        this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : super._next;\n        this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._error;\n        this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._complete;\n    }\n    unsubscribe() {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            const { closed } = this;\n            super.unsubscribe();\n            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    }\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function refCount() {\n    return operate((source, subscriber) => {\n        let connection = null;\n        source._refCount++;\n        const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n            if (!source || source._refCount <= 0 || 0 < --source._refCount) {\n                connection = null;\n                return;\n            }\n            const sharedConnection = source._connection;\n            const conn = connection;\n            connection = null;\n            if (sharedConnection && (!conn || sharedConnection === conn)) {\n                sharedConnection.unsubscribe();\n            }\n            subscriber.unsubscribe();\n        });\n        source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            connection = source.connect();\n        }\n    });\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\nexport class ConnectableObservable extends Observable {\n    constructor(source, subjectFactory) {\n        super();\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._subject = null;\n        this._refCount = 0;\n        this._connection = null;\n        if (hasLift(source)) {\n            this.lift = source.lift;\n        }\n    }\n    _subscribe(subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    }\n    getSubject() {\n        const subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    }\n    _teardown() {\n        this._refCount = 0;\n        const { _connection } = this;\n        this._subject = this._connection = null;\n        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();\n    }\n    connect() {\n        let connection = this._connection;\n        if (!connection) {\n            connection = this._connection = new Subscription();\n            const subject = this.getSubject();\n            connection.add(this.source.subscribe(createOperatorSubscriber(subject, undefined, () => {\n                this._teardown();\n                subject.complete();\n            }, (err) => {\n                this._teardown();\n                subject.error(err);\n            }, () => this._teardown())));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription.EMPTY;\n            }\n        }\n        return connection;\n    }\n    refCount() {\n        return higherOrderRefCount()(this);\n    }\n}\n","import { createErrorClass } from './createErrorClass';\nexport const ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {\n    _super(this);\n    this.name = 'ObjectUnsubscribedError';\n    this.message = 'object unsubscribed';\n});\n","import { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nexport class Subject extends Observable {\n    constructor() {\n        super();\n        this.closed = false;\n        this.currentObservers = null;\n        this.observers = [];\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    lift(operator) {\n        const subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    }\n    _throwIfClosed() {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    }\n    next(value) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                if (!this.currentObservers) {\n                    this.currentObservers = Array.from(this.observers);\n                }\n                for (const observer of this.currentObservers) {\n                    observer.next(value);\n                }\n            }\n        });\n    }\n    error(err) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.hasError = this.isStopped = true;\n                this.thrownError = err;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    }\n    complete() {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.isStopped = true;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    }\n    unsubscribe() {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    }\n    get observed() {\n        var _a;\n        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n    }\n    _trySubscribe(subscriber) {\n        this._throwIfClosed();\n        return super._trySubscribe(subscriber);\n    }\n    _subscribe(subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    }\n    _innerSubscribe(subscriber) {\n        const { hasError, isStopped, observers } = this;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(() => {\n            this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    }\n    _checkFinalizedStatuses(subscriber) {\n        const { hasError, thrownError, isStopped } = this;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    }\n    asObservable() {\n        const observable = new Observable();\n        observable.source = this;\n        return observable;\n    }\n}\nSubject.create = (destination, source) => {\n    return new AnonymousSubject(destination, source);\n};\nexport class AnonymousSubject extends Subject {\n    constructor(destination, source) {\n        super();\n        this.destination = destination;\n        this.source = source;\n    }\n    next(value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    }\n    error(err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    }\n    complete() {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    _subscribe(subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    }\n}\n","import { Subject } from './Subject';\nexport class BehaviorSubject extends Subject {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    get value() {\n        return this.getValue();\n    }\n    _subscribe(subscriber) {\n        const subscription = super._subscribe(subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    }\n    getValue() {\n        const { hasError, thrownError, _value } = this;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    }\n    next(value) {\n        super.next((this._value = value));\n    }\n}\n","export const dateTimestampProvider = {\n    now() {\n        return (dateTimestampProvider.delegate || Date).now();\n    },\n    delegate: undefined,\n};\n","import { Subscription } from '../Subscription';\nexport class Action extends Subscription {\n    constructor(scheduler, work) {\n        super();\n    }\n    schedule(state, delay = 0) {\n        return this;\n    }\n}\n","export const intervalProvider = {\n    setInterval(handler, timeout, ...args) {\n        const { delegate } = intervalProvider;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {\n            return delegate.setInterval(handler, timeout, ...args);\n        }\n        return setInterval(handler, timeout, ...args);\n    },\n    clearInterval(handle) {\n        const { delegate } = intervalProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);\n    },\n    delegate: undefined,\n};\n","import { Action } from './Action';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nexport class AsyncAction extends Action {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    schedule(state, delay = 0) {\n        var _a;\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        const id = this.id;\n        const scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    }\n    requestAsyncId(scheduler, _id, delay = 0) {\n        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    }\n    recycleAsyncId(_scheduler, id, delay = 0) {\n        if (delay != null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        if (id != null) {\n            intervalProvider.clearInterval(id);\n        }\n        return undefined;\n    }\n    execute(state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        const error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    }\n    _execute(state, _delay) {\n        let errored = false;\n        let errorValue;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = e ? e : new Error('Scheduled action threw falsy error');\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            const { id, scheduler } = this;\n            const { actions } = scheduler;\n            this.work = this.state = this.scheduler = null;\n            this.pending = false;\n            arrRemove(actions, this);\n            if (id != null) {\n                this.id = this.recycleAsyncId(scheduler, id, null);\n            }\n            this.delay = null;\n            super.unsubscribe();\n        }\n    }\n}\n","import { dateTimestampProvider } from './scheduler/dateTimestampProvider';\nexport class Scheduler {\n    constructor(schedulerActionCtor, now = Scheduler.now) {\n        this.schedulerActionCtor = schedulerActionCtor;\n        this.now = now;\n    }\n    schedule(work, delay = 0, state) {\n        return new this.schedulerActionCtor(this, work).schedule(state, delay);\n    }\n}\nScheduler.now = dateTimestampProvider.now;\n","import { Scheduler } from '../Scheduler';\nexport class AsyncScheduler extends Scheduler {\n    constructor(SchedulerAction, now = Scheduler.now) {\n        super(SchedulerAction, now);\n        this.actions = [];\n        this._active = false;\n    }\n    flush(action) {\n        const { actions } = this;\n        if (this._active) {\n            actions.push(action);\n            return;\n        }\n        let error;\n        this._active = true;\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions.shift()));\n        this._active = false;\n        if (error) {\n            while ((action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\nexport const async = asyncScheduler;\n","import { Observable } from '../Observable';\nexport const EMPTY = new Observable((subscriber) => subscriber.complete());\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { isFunction } from './isFunction';\nexport function isScheduler(value) {\n    return value && isFunction(value.schedule);\n}\n","import { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexport function popResultSelector(args) {\n    return isFunction(last(args)) ? args.pop() : undefined;\n}\nexport function popScheduler(args) {\n    return isScheduler(last(args)) ? args.pop() : undefined;\n}\nexport function popNumber(args, defaultValue) {\n    return typeof last(args) === 'number' ? args.pop() : defaultValue;\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","export const isArrayLike = ((x) => x && typeof x.length === 'number' && typeof x !== 'function');\n","import { isFunction } from \"./isFunction\";\nexport function isPromise(value) {\n    return isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\n","import { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\nexport function isInteropObservable(input) {\n    return isFunction(input[Symbol_observable]);\n}\n","import { isFunction } from './isFunction';\nexport function isAsyncIterable(obj) {\n    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n","export function createInvalidObservableTypeError(input) {\n    return new TypeError(`You provided ${input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);\n}\n","export function getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexport const iterator = getSymbolIterator();\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\nexport function isIterable(input) {\n    return isFunction(input === null || input === void 0 ? void 0 : input[Symbol_iterator]);\n}\n","import { __asyncGenerator, __await } from \"tslib\";\nimport { isFunction } from './isFunction';\nexport function readableStreamLikeToAsyncGenerator(readableStream) {\n    return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {\n        const reader = readableStream.getReader();\n        try {\n            while (true) {\n                const { value, done } = yield __await(reader.read());\n                if (done) {\n                    return yield __await(void 0);\n                }\n                yield yield __await(value);\n            }\n        }\n        finally {\n            reader.releaseLock();\n        }\n    });\n}\nexport function isReadableStreamLike(obj) {\n    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n","import { __asyncValues, __awaiter } from \"tslib\";\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function innerFrom(input) {\n    if (input instanceof Observable) {\n        return input;\n    }\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return fromInteropObservable(input);\n        }\n        if (isArrayLike(input)) {\n            return fromArrayLike(input);\n        }\n        if (isPromise(input)) {\n            return fromPromise(input);\n        }\n        if (isAsyncIterable(input)) {\n            return fromAsyncIterable(input);\n        }\n        if (isIterable(input)) {\n            return fromIterable(input);\n        }\n        if (isReadableStreamLike(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\nexport function fromInteropObservable(obj) {\n    return new Observable((subscriber) => {\n        const obs = obj[Symbol_observable]();\n        if (isFunction(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nexport function fromArrayLike(array) {\n    return new Observable((subscriber) => {\n        for (let i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nexport function fromPromise(promise) {\n    return new Observable((subscriber) => {\n        promise\n            .then((value) => {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, (err) => subscriber.error(err))\n            .then(null, reportUnhandledError);\n    });\n}\nexport function fromIterable(iterable) {\n    return new Observable((subscriber) => {\n        for (const value of iterable) {\n            subscriber.next(value);\n            if (subscriber.closed) {\n                return;\n            }\n        }\n        subscriber.complete();\n    });\n}\nexport function fromAsyncIterable(asyncIterable) {\n    return new Observable((subscriber) => {\n        process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n    });\n}\nexport function fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done;) {\n                const value = asyncIterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\n","export function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {\n    const scheduleSubscription = scheduler.schedule(function () {\n        work();\n        if (repeat) {\n            parentSubscription.add(this.schedule(null, delay));\n        }\n        else {\n            this.unsubscribe();\n        }\n    }, delay);\n    parentSubscription.add(scheduleSubscription);\n    if (!repeat) {\n        return scheduleSubscription;\n    }\n}\n","import { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function observeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));\n    });\n}\n","import { operate } from '../util/lift';\nexport function subscribeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function scheduleObservable(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function schedulePromise(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n","import { Observable } from '../Observable';\nexport function scheduleArray(input, scheduler) {\n    return new Observable((subscriber) => {\n        let i = 0;\n        return scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n            }\n            else {\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    this.schedule();\n                }\n            }\n        });\n    });\n}\n","import { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleIterable(input, scheduler) {\n    return new Observable((subscriber) => {\n        let iterator;\n        executeSchedule(subscriber, scheduler, () => {\n            iterator = input[Symbol_iterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                let value;\n                let done;\n                try {\n                    ({ value, done } = iterator.next());\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                }\n            }, 0, true);\n        });\n        return () => isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();\n    });\n}\n","import { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleAsyncIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new Observable((subscriber) => {\n        executeSchedule(subscriber, scheduler, () => {\n            const iterator = input[Symbol.asyncIterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                iterator.next().then((result) => {\n                    if (result.done) {\n                        subscriber.complete();\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                });\n            }, 0, true);\n        });\n    });\n}\n","import { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nexport function scheduleReadableStreamLike(input, scheduler) {\n    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\nexport function scheduled(input, scheduler) {\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return scheduleObservable(input, scheduler);\n        }\n        if (isArrayLike(input)) {\n            return scheduleArray(input, scheduler);\n        }\n        if (isPromise(input)) {\n            return schedulePromise(input, scheduler);\n        }\n        if (isAsyncIterable(input)) {\n            return scheduleAsyncIterable(input, scheduler);\n        }\n        if (isIterable(input)) {\n            return scheduleIterable(input, scheduler);\n        }\n        if (isReadableStreamLike(input)) {\n            return scheduleReadableStreamLike(input, scheduler);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\n","import { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\nexport function from(input, scheduler) {\n    return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n","import { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function of(...args) {\n    const scheduler = popScheduler(args);\n    return from(args, scheduler);\n}\n","import { Observable } from '../Observable';\nimport { isFunction } from '../util/isFunction';\nexport function throwError(errorOrErrorFactory, scheduler) {\n    const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n    const init = (subscriber) => subscriber.error(errorFactory());\n    return new Observable(scheduler ? (subscriber) => scheduler.schedule(init, 0, subscriber) : init);\n}\n","import { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n","import { createErrorClass } from './createErrorClass';\nexport const EmptyError = createErrorClass((_super) => function EmptyErrorImpl() {\n    _super(this);\n    this.name = 'EmptyError';\n    this.message = 'no elements in sequence';\n});\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n","import { map } from \"../operators/map\";\nconst { isArray } = Array;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn(...args) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(args => callOrApply(fn, args));\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\nexport function argsArgArrayOrObject(args) {\n    if (args.length === 1) {\n        const first = args[0];\n        if (isArray(first)) {\n            return { args: first, keys: null };\n        }\n        if (isPOJO(first)) {\n            const keys = getKeys(first);\n            return {\n                args: keys.map((key) => first[key]),\n                keys,\n            };\n        }\n    }\n    return { args: args, keys: null };\n}\nfunction isPOJO(obj) {\n    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export function createObject(keys, values) {\n    return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {});\n}\n","import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest(...args) {\n    const scheduler = popScheduler(args);\n    const resultSelector = popResultSelector(args);\n    const { args: observables, keys } = argsArgArrayOrObject(args);\n    if (observables.length === 0) {\n        return from([], scheduler);\n    }\n    const result = new Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            (values) => createObject(keys, values)\n        :\n            identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler, valueTransform = identity) {\n    return (subscriber) => {\n        maybeSchedule(scheduler, () => {\n            const { length } = observables;\n            const values = new Array(length);\n            let active = length;\n            let remainingFirstValues = length;\n            for (let i = 0; i < length; i++) {\n                maybeSchedule(scheduler, () => {\n                    const source = from(observables[i], scheduler);\n                    let hasFirstValue = false;\n                    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, () => {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            }\n        }, subscriber);\n    };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    const buffer = [];\n    let active = 0;\n    let index = 0;\n    let isComplete = false;\n    const checkComplete = () => {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n    const doInnerSub = (value) => {\n        expand && subscriber.next(value);\n        active++;\n        let innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, () => {\n            innerComplete = true;\n        }, undefined, () => {\n            if (innerComplete) {\n                try {\n                    active--;\n                    while (buffer.length && active < concurrent) {\n                        const bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {\n        isComplete = true;\n        checkComplete();\n    }));\n    return () => {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent = Infinity) {\n    if (isFunction(resultSelector)) {\n        return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent = Infinity) {\n    return mergeMap(identity, concurrent);\n}\n","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n","import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat(...args) {\n    return concatAll()(from(args, popScheduler(args)));\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nexport function defer(observableFactory) {\n    return new Observable((subscriber) => {\n        innerFrom(observableFactory()).subscribe(subscriber);\n    });\n}\n","import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { innerFrom } from './innerFrom';\nimport { popResultSelector } from '../util/args';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { createObject } from '../util/createObject';\nexport function forkJoin(...args) {\n    const resultSelector = popResultSelector(args);\n    const { args: sources, keys } = argsArgArrayOrObject(args);\n    const result = new Observable((subscriber) => {\n        const { length } = sources;\n        if (!length) {\n            subscriber.complete();\n            return;\n        }\n        const values = new Array(length);\n        let remainingCompletions = length;\n        let remainingEmissions = length;\n        for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n            let hasValue = false;\n            innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {\n                if (!hasValue) {\n                    hasValue = true;\n                    remainingEmissions--;\n                }\n                values[sourceIndex] = value;\n            }, () => remainingCompletions--, undefined, () => {\n                if (!remainingCompletions || !hasValue) {\n                    if (!remainingEmissions) {\n                        subscriber.next(keys ? createObject(keys, values) : values);\n                    }\n                    subscriber.complete();\n                }\n            }));\n        }\n    });\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n","export {};\n","import { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\nexport function catchError(selector) {\n    return operate((source, subscriber) => {\n        let innerSub = null;\n        let syncUnsub = false;\n        let handledResult;\n        innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n            handledResult = innerFrom(selector(err, catchError(selector)(source)));\n            if (innerSub) {\n                innerSub.unsubscribe();\n                innerSub = null;\n                handledResult.subscribe(subscriber);\n            }\n            else {\n                syncUnsub = true;\n            }\n        }));\n        if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            handledResult.subscribe(subscriber);\n        }\n    });\n}\n","import { createOperatorSubscriber } from './OperatorSubscriber';\nexport function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {\n    return (source, subscriber) => {\n        let hasState = hasSeed;\n        let state = seed;\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            const i = index++;\n            state = hasState\n                ?\n                    accumulator(state, value, i)\n                :\n                    ((hasState = true), value);\n            emitOnNext && subscriber.next(state);\n        }, emitBeforeComplete &&\n            (() => {\n                hasState && subscriber.next(state);\n                subscriber.complete();\n            })));\n    };\n}\n","import { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\nexport function concatMap(project, resultSelector) {\n    return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function debounceTime(dueTime, scheduler = asyncScheduler) {\n    return operate((source, subscriber) => {\n        let activeTask = null;\n        let lastValue = null;\n        let lastTime = null;\n        const emit = () => {\n            if (activeTask) {\n                activeTask.unsubscribe();\n                activeTask = null;\n                const value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n        };\n        function emitWhenIdle() {\n            const targetTime = lastTime + dueTime;\n            const now = scheduler.now();\n            if (now < targetTime) {\n                activeTask = this.schedule(undefined, targetTime - now);\n                subscriber.add(activeTask);\n                return;\n            }\n            emit();\n        }\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            lastValue = value;\n            lastTime = scheduler.now();\n            if (!activeTask) {\n                activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n                subscriber.add(activeTask);\n            }\n        }, () => {\n            emit();\n            subscriber.complete();\n        }, undefined, () => {\n            lastValue = activeTask = null;\n        }));\n    });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function defaultIfEmpty(defaultValue) {\n    return operate((source, subscriber) => {\n        let hasValue = false;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            hasValue = true;\n            subscriber.next(value);\n        }, () => {\n            if (!hasValue) {\n                subscriber.next(defaultValue);\n            }\n            subscriber.complete();\n        }));\n    });\n}\n","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function take(count) {\n    return count <= 0\n        ?\n            () => EMPTY\n        : operate((source, subscriber) => {\n            let seen = 0;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\n","import { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function distinctUntilChanged(comparator, keySelector = identity) {\n    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;\n    return operate((source, subscriber) => {\n        let previousKey;\n        let first = true;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            const currentKey = keySelector(value);\n            if (first || !comparator(previousKey, currentKey)) {\n                first = false;\n                previousKey = currentKey;\n                subscriber.next(value);\n            }\n        }));\n    });\n}\nfunction defaultCompare(a, b) {\n    return a === b;\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function throwIfEmpty(errorFactory = defaultErrorFactory) {\n    return operate((source, subscriber) => {\n        let hasValue = false;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            hasValue = true;\n            subscriber.next(value);\n        }, () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))));\n    });\n}\nfunction defaultErrorFactory() {\n    return new EmptyError();\n}\n","import { operate } from '../util/lift';\nexport function finalize(callback) {\n    return operate((source, subscriber) => {\n        try {\n            source.subscribe(subscriber);\n        }\n        finally {\n            subscriber.add(callback);\n        }\n    });\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\nexport function first(predicate, defaultValue) {\n    const hasDefaultValue = arguments.length >= 2;\n    return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));\n}\n","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function takeLast(count) {\n    return count <= 0\n        ? () => EMPTY\n        : operate((source, subscriber) => {\n            let buffer = [];\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                buffer.push(value);\n                count < buffer.length && buffer.shift();\n            }, () => {\n                for (const value of buffer) {\n                    subscriber.next(value);\n                }\n                subscriber.complete();\n            }, undefined, () => {\n                buffer = null;\n            }));\n        });\n}\n","import { EmptyError } from '../util/EmptyError';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\nexport function last(predicate, defaultValue) {\n    const hasDefaultValue = arguments.length >= 2;\n    return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));\n}\n","import { operate } from '../util/lift';\nimport { scanInternals } from './scanInternals';\nexport function scan(accumulator, seed) {\n    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));\n}\n","import { filter } from './filter';\nexport function skip(count) {\n    return filter((_, index) => count <= index);\n}\n","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith(...values) {\n    const scheduler = popScheduler(values);\n    return operate((source, subscriber) => {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate((source, subscriber) => {\n        let innerSubscriber = null;\n        let index = 0;\n        let isComplete = false;\n        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            let innerIndex = 0;\n            const outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, () => {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\nexport function takeUntil(notifier) {\n    return operate((source, subscriber) => {\n        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\n","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    const tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error, complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate((source, subscriber) => {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            let isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, () => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, (err) => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, () => {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n","export { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { observable } from './internal/symbol/observable';\nexport { animationFrames } from './internal/observable/dom/animationFrames';\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\nexport { Notification, NotificationKind } from './internal/Notification';\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\nexport { lastValueFrom } from './internal/lastValueFrom';\nexport { firstValueFrom } from './internal/firstValueFrom';\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { NotFoundError } from './internal/util/NotFoundError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { SequenceError } from './internal/util/SequenceError';\nexport { TimeoutError } from './internal/operators/timeout';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { connectable } from './internal/observable/connectable';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\nexport * from './internal/types';\nexport { config } from './internal/config';\nexport { audit } from './internal/operators/audit';\nexport { auditTime } from './internal/operators/auditTime';\nexport { buffer } from './internal/operators/buffer';\nexport { bufferCount } from './internal/operators/bufferCount';\nexport { bufferTime } from './internal/operators/bufferTime';\nexport { bufferToggle } from './internal/operators/bufferToggle';\nexport { bufferWhen } from './internal/operators/bufferWhen';\nexport { catchError } from './internal/operators/catchError';\nexport { combineAll } from './internal/operators/combineAll';\nexport { combineLatestAll } from './internal/operators/combineLatestAll';\nexport { combineLatestWith } from './internal/operators/combineLatestWith';\nexport { concatAll } from './internal/operators/concatAll';\nexport { concatMap } from './internal/operators/concatMap';\nexport { concatMapTo } from './internal/operators/concatMapTo';\nexport { concatWith } from './internal/operators/concatWith';\nexport { connect } from './internal/operators/connect';\nexport { count } from './internal/operators/count';\nexport { debounce } from './internal/operators/debounce';\nexport { debounceTime } from './internal/operators/debounceTime';\nexport { defaultIfEmpty } from './internal/operators/defaultIfEmpty';\nexport { delay } from './internal/operators/delay';\nexport { delayWhen } from './internal/operators/delayWhen';\nexport { dematerialize } from './internal/operators/dematerialize';\nexport { distinct } from './internal/operators/distinct';\nexport { distinctUntilChanged } from './internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from './internal/operators/elementAt';\nexport { endWith } from './internal/operators/endWith';\nexport { every } from './internal/operators/every';\nexport { exhaust } from './internal/operators/exhaust';\nexport { exhaustAll } from './internal/operators/exhaustAll';\nexport { exhaustMap } from './internal/operators/exhaustMap';\nexport { expand } from './internal/operators/expand';\nexport { filter } from './internal/operators/filter';\nexport { finalize } from './internal/operators/finalize';\nexport { find } from './internal/operators/find';\nexport { findIndex } from './internal/operators/findIndex';\nexport { first } from './internal/operators/first';\nexport { groupBy } from './internal/operators/groupBy';\nexport { ignoreElements } from './internal/operators/ignoreElements';\nexport { isEmpty } from './internal/operators/isEmpty';\nexport { last } from './internal/operators/last';\nexport { map } from './internal/operators/map';\nexport { mapTo } from './internal/operators/mapTo';\nexport { materialize } from './internal/operators/materialize';\nexport { max } from './internal/operators/max';\nexport { mergeAll } from './internal/operators/mergeAll';\nexport { flatMap } from './internal/operators/flatMap';\nexport { mergeMap } from './internal/operators/mergeMap';\nexport { mergeMapTo } from './internal/operators/mergeMapTo';\nexport { mergeScan } from './internal/operators/mergeScan';\nexport { mergeWith } from './internal/operators/mergeWith';\nexport { min } from './internal/operators/min';\nexport { multicast } from './internal/operators/multicast';\nexport { observeOn } from './internal/operators/observeOn';\nexport { onErrorResumeNextWith } from './internal/operators/onErrorResumeNextWith';\nexport { pairwise } from './internal/operators/pairwise';\nexport { pluck } from './internal/operators/pluck';\nexport { publish } from './internal/operators/publish';\nexport { publishBehavior } from './internal/operators/publishBehavior';\nexport { publishLast } from './internal/operators/publishLast';\nexport { publishReplay } from './internal/operators/publishReplay';\nexport { raceWith } from './internal/operators/raceWith';\nexport { reduce } from './internal/operators/reduce';\nexport { repeat } from './internal/operators/repeat';\nexport { repeatWhen } from './internal/operators/repeatWhen';\nexport { retry } from './internal/operators/retry';\nexport { retryWhen } from './internal/operators/retryWhen';\nexport { refCount } from './internal/operators/refCount';\nexport { sample } from './internal/operators/sample';\nexport { sampleTime } from './internal/operators/sampleTime';\nexport { scan } from './internal/operators/scan';\nexport { sequenceEqual } from './internal/operators/sequenceEqual';\nexport { share } from './internal/operators/share';\nexport { shareReplay } from './internal/operators/shareReplay';\nexport { single } from './internal/operators/single';\nexport { skip } from './internal/operators/skip';\nexport { skipLast } from './internal/operators/skipLast';\nexport { skipUntil } from './internal/operators/skipUntil';\nexport { skipWhile } from './internal/operators/skipWhile';\nexport { startWith } from './internal/operators/startWith';\nexport { subscribeOn } from './internal/operators/subscribeOn';\nexport { switchAll } from './internal/operators/switchAll';\nexport { switchMap } from './internal/operators/switchMap';\nexport { switchMapTo } from './internal/operators/switchMapTo';\nexport { switchScan } from './internal/operators/switchScan';\nexport { take } from './internal/operators/take';\nexport { takeLast } from './internal/operators/takeLast';\nexport { takeUntil } from './internal/operators/takeUntil';\nexport { takeWhile } from './internal/operators/takeWhile';\nexport { tap } from './internal/operators/tap';\nexport { throttle } from './internal/operators/throttle';\nexport { throttleTime } from './internal/operators/throttleTime';\nexport { throwIfEmpty } from './internal/operators/throwIfEmpty';\nexport { timeInterval } from './internal/operators/timeInterval';\nexport { timeout } from './internal/operators/timeout';\nexport { timeoutWith } from './internal/operators/timeoutWith';\nexport { timestamp } from './internal/operators/timestamp';\nexport { toArray } from './internal/operators/toArray';\nexport { window } from './internal/operators/window';\nexport { windowCount } from './internal/operators/windowCount';\nexport { windowTime } from './internal/operators/windowTime';\nexport { windowToggle } from './internal/operators/windowToggle';\nexport { windowWhen } from './internal/operators/windowWhen';\nexport { withLatestFrom } from './internal/operators/withLatestFrom';\nexport { zipAll } from './internal/operators/zipAll';\nexport { zipWith } from './internal/operators/zipWith';\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer } from './signal.mjs';\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n    const node = Object.create(LINKED_SIGNAL_NODE);\n    node.source = sourceFn;\n    node.computation = computationFn;\n    if (equalityFn != undefined) {\n        node.equal = equalityFn;\n    }\n    const linkedSignalGetter = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    const getter = linkedSignalGetter;\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n    producerUpdateValueVersion(node);\n    signalSetFn(node, newValue);\n    producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n    producerUpdateValueVersion(node);\n    signalUpdateFn(node, updater);\n    producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'linkedSignal',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                const newSourceValue = node.source();\n                const prev = oldValue === UNSET || oldValue === ERRORED\n                    ? undefined\n                    : {\n                        source: node.sourceValue,\n                        value: oldValue,\n                    };\n                newValue = node.computation(newSourceValue, prev);\n                node.sourceValue = newSourceValue;\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked };\n\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\nexport { setAlternateWeakRefImpl };\n\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { consumerMarkDirty, SIGNAL, REACTIVE_NODE, consumerDestroy, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from '../signal.mjs';\nexport { SIGNAL_NODE, createComputed, createSignal, defaultEquals, getActiveConsumer, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn } from '../signal.mjs';\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked } from '../untracked.mjs';\nexport { setAlternateWeakRefImpl } from '../weak_ref.mjs';\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    function isWatchNodeDestroyed(node) {\n        return node.fn === null && node.schedule === null;\n    }\n    function destroyWatchNode(node) {\n        if (!isWatchNodeDestroyed(node)) {\n            consumerDestroy(node); // disconnect watcher from the reactive graph\n            node.cleanupFn();\n            // nullify references to the integration functions to mark node as destroyed\n            node.fn = null;\n            node.schedule = null;\n            node.cleanupFn = NOOP_CLEANUP_FN;\n        }\n    }\n    const run = () => {\n        if (node.fn === null) {\n            // trying to run a destroyed watch is noop\n            return;\n        }\n        if (isInNotificationPhase()) {\n            throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n                ? 'Schedulers cannot synchronously execute watches while scheduling.'\n                : '');\n        }\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n        destroy: () => destroyWatchNode(node),\n        [SIGNAL]: node,\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            if (node.schedule !== null) {\n                node.schedule(node.ref);\n            }\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nexport { REACTIVE_NODE, SIGNAL, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createWatch, isInNotificationPhase };\n\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nexport { NOT_FOUND, NotFoundError, getCurrentInjector, inject, isNotFound, setCurrentInjector } from '../not_found.mjs';\n\nfunction defineInjectable(opts) {\n    return {\n        token: opts.token,\n        providedIn: opts.providedIn || null,\n        factory: opts.factory,\n        value: undefined,\n    };\n}\nfunction registerInjectable(ctor, declaration) {\n    ctor.ɵprov = declaration;\n    return ctor;\n}\n\nexport { defineInjectable, registerInjectable };\n\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { isNotFound, getCurrentInjector, setCurrentInjector } from './not_found.mjs';\nimport { getActiveConsumer, SIGNAL, createSignal } from './signal.mjs';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { setActiveConsumer } from '@angular/core/primitives/signals';\nimport { isNotFound as isNotFound$1 } from '@angular/core/primitives/di';\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.dev/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```ts\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n    code;\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\nfunction formatRuntimeErrorCode(code) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    // We also prepend `0` to non-compile-time errors.\n    return `NG0${Math.abs(code)}`;\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    const fullCode = formatRuntimeErrorCode(code);\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\nconst _global = globalThis;\n\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        hydratedNodes: 0,\n        hydratedComponents: 0,\n        dehydratedViewsRemoved: 0,\n        dehydratedViewsCleanupRuns: 0,\n        componentsSkippedHydration: 0,\n        deferBlocksWithIncrementalHydration: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    if (!allowNgDevModeTrue) {\n        _global['ngDevMode'] = false;\n    }\n    else {\n        if (typeof _global['ngDevMode'] !== 'object') {\n            _global['ngDevMode'] = {};\n        }\n        Object.assign(_global['ngDevMode'], newCounters);\n    }\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n    for (let key in objWithPropertyToExtract) {\n        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n            return key;\n        }\n    }\n    // Cannot change it to `RuntimeError` because the `util` target cannot\n    // circularly depend on the `core` target.\n    throw Error(typeof ngDevMode !== 'undefined' && ngDevMode\n        ? 'Could not find renamed property on target object.'\n        : '');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target, source) {\n    for (const key in source) {\n        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n            target[key] = source[key];\n        }\n    }\n}\n\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return `[${token.map(stringify).join(', ')}]`;\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    const name = token.overriddenName || token.name;\n    if (name) {\n        return `${name}`;\n    }\n    const result = token.toString();\n    if (result == null) {\n        return '' + result;\n    }\n    const newLineIndex = result.indexOf('\\n');\n    return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nfunction concatStringsWithSpace(before, after) {\n    if (!before)\n        return after || '';\n    if (!after)\n        return before;\n    return `${before} ${after}`;\n}\n/**\n * Ellipses the string in the middle when longer than the max length\n *\n * @param string\n * @param maxLength of the output string\n * @returns ellipsed string with ... in the middle\n */\nfunction truncateMiddle(str, maxLength = 100) {\n    if (!str || maxLength < 1 || str.length <= maxLength)\n        return str;\n    if (maxLength == 1)\n        return str.substring(0, 1) + '...';\n    const halfLimit = Math.round(maxLength / 2);\n    return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);\n}\n\nconst __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * `forwardRef` is also used to break circularities in standalone components imports.\n *\n * @usageNotes\n * ### Circular dependency example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n *\n * ### Circular standalone reference import example\n * ```angular-ts\n * @Component({\n *   imports: [ChildComponent],\n *   selector: 'app-parent',\n *   template: `<app-child [hideParent]=\"hideParent()\"></app-child>`,\n * })\n * export class ParentComponent {\n *    hideParent = input.required<boolean>();\n * }\n *\n *\n * @Component({\n *   imports: [forwardRef(() => ParentComponent)],\n *   selector: 'app-child',\n *   template: `\n *    @if(!hideParent() {\n *       <app-parent/>\n *    }\n *  `,\n * })\n * export class ChildComponent {\n *    hideParent = input.required<boolean>();\n * }\n * ```\n *\n * @publicApi\n */\nfunction forwardRef(forwardRefFn) {\n    forwardRefFn.__forward_ref__ = forwardRef;\n    forwardRefFn.toString = function () {\n        return stringify(this());\n    };\n    return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see {@link forwardRef}\n * @publicApi\n */\nfunction resolveForwardRef(type) {\n    return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\nfunction isForwardRef(fn) {\n    return (typeof fn === 'function' &&\n        fn.hasOwnProperty(__forward_ref__) &&\n        fn.__forward_ref__ === forwardRef);\n}\n\n// The functions in this file verify that the assumptions we are making\n// about state in an instruction are correct before implementing any logic.\n// They are meant only to be called in dev mode as sanity checks.\nfunction assertNumber(actual, msg) {\n    if (!(typeof actual === 'number')) {\n        throwError(msg, typeof actual, 'number', '===');\n    }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n    assertNumber(actual, 'Expected a number');\n    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n    assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n    if (!(typeof actual === 'string')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n    }\n}\nfunction assertFunction(actual, msg) {\n    if (!(typeof actual === 'function')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n    }\n}\nfunction assertEqual(actual, expected, msg) {\n    if (!(actual == expected)) {\n        throwError(msg, actual, expected, '==');\n    }\n}\nfunction assertNotEqual(actual, expected, msg) {\n    if (!(actual != expected)) {\n        throwError(msg, actual, expected, '!=');\n    }\n}\nfunction assertSame(actual, expected, msg) {\n    if (!(actual === expected)) {\n        throwError(msg, actual, expected, '===');\n    }\n}\nfunction assertNotSame(actual, expected, msg) {\n    if (!(actual !== expected)) {\n        throwError(msg, actual, expected, '!==');\n    }\n}\nfunction assertLessThan(actual, expected, msg) {\n    if (!(actual < expected)) {\n        throwError(msg, actual, expected, '<');\n    }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n    if (!(actual <= expected)) {\n        throwError(msg, actual, expected, '<=');\n    }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n    if (!(actual > expected)) {\n        throwError(msg, actual, expected, '>');\n    }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n    if (!(actual >= expected)) {\n        throwError(msg, actual, expected, '>=');\n    }\n}\nfunction assertNotDefined(actual, msg) {\n    if (actual != null) {\n        throwError(msg, actual, null, '==');\n    }\n}\nfunction assertDefined(actual, msg) {\n    if (actual == null) {\n        throwError(msg, actual, null, '!=');\n    }\n}\nfunction throwError(msg, actual, expected, comparison) {\n    throw new Error(`ASSERTION ERROR: ${msg}` +\n        (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n    if (!(node instanceof Node)) {\n        throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n    }\n}\nfunction assertElement(node) {\n    if (!(node instanceof Element)) {\n        throwError(`The provided value must be an element but got ${stringify(node)}`);\n    }\n}\nfunction assertIndexInRange(arr, index) {\n    assertDefined(arr, 'Array must be defined.');\n    const maxLen = arr.length;\n    if (index < 0 || index >= maxLen) {\n        throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n    }\n}\nfunction assertOneOf(value, ...validValues) {\n    if (validValues.indexOf(value) !== -1)\n        return true;\n    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\nfunction assertNotReactive(fn) {\n    if (getActiveConsumer() !== null) {\n        throwError(`${fn}() should never be called in a reactive context.`);\n    }\n}\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\n * of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nfunction ɵɵdefineInjectable(opts) {\n    return {\n        token: opts.token,\n        providedIn: opts.providedIn || null,\n        factory: opts.factory,\n        value: undefined,\n    };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\nconst defineInjectable = ɵɵdefineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nfunction ɵɵdefineInjector(options) {\n    return { providers: options.providers || [], imports: options.imports || [] };\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nfunction getInjectableDef(type) {\n    return getOwnDefinition(type, NG_PROV_DEF);\n}\nfunction isInjectable(type) {\n    return getInjectableDef(type) !== null;\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition(type, field) {\n    // if the ɵprov prop exist but is undefined we still want to return null\n    return (type.hasOwnProperty(field) && type[field]) || null;\n}\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nfunction getInheritedInjectableDef(type) {\n    // if the ɵprov prop exist but is undefined we still want to return null\n    const def = type?.[NG_PROV_DEF] ?? null;\n    if (def) {\n        ngDevMode &&\n            console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n                `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n        return def;\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nfunction getInjectorDef(type) {\n    return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({ ɵprov: getClosureSafeProperty });\nconst NG_INJ_DEF = getClosureSafeProperty({ ɵinj: getClosureSafeProperty });\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n * **Important Note**: Ensure that you use the same instance of the `InjectionToken` in both the\n * provider and the injection call. Creating a new instance of `InjectionToken` in different places,\n * even with the same description, will be treated as different tokens by Angular's DI system,\n * leading to a `NullInjectorError`.\n *\n * </div>\n *\n * {@example injection-token/src/main.ts region='InjectionToken'}\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the [`inject`](api/core/inject) function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule` (note:\n * this option is now deprecated). As mentioned above, `'root'` is the default value for\n * `providedIn`.\n *\n * The `providedIn: NgModule` and `providedIn: 'any'` options are deprecated.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n * @publicApi\n */\nclass InjectionToken {\n    _desc;\n    /** @internal */\n    ngMetadataName = 'InjectionToken';\n    ɵprov;\n    /**\n     * @param _desc   Description for the token,\n     *                used only for debugging purposes,\n     *                it should but does not need to be unique\n     * @param options Options for the token's usage, as described above\n     */\n    constructor(_desc, options) {\n        this._desc = _desc;\n        this.ɵprov = undefined;\n        if (typeof options == 'number') {\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                assertLessThan(options, 0, 'Only negative numbers are supported here');\n            // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n            // See `InjectorMarkers`\n            this.__NG_ELEMENT_ID__ = options;\n        }\n        else if (options !== undefined) {\n            this.ɵprov = ɵɵdefineInjectable({\n                token: this,\n                providedIn: options.providedIn || 'root',\n                factory: options.factory,\n            });\n        }\n    }\n    /**\n     * @internal\n     */\n    get multi() {\n        return this;\n    }\n    toString() {\n        return `InjectionToken ${this._desc}`;\n    }\n}\n\nlet _injectorProfilerContext;\nfunction getInjectorProfilerContext() {\n    !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n    return _injectorProfilerContext;\n}\nfunction setInjectorProfilerContext(context) {\n    !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n    const previous = _injectorProfilerContext;\n    _injectorProfilerContext = context;\n    return previous;\n}\nconst injectorProfilerCallbacks = [];\nconst NOOP_PROFILER_REMOVAL = () => { };\nfunction removeProfiler(profiler) {\n    const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);\n    if (profilerIdx !== -1) {\n        injectorProfilerCallbacks.splice(profilerIdx, 1);\n    }\n}\n/**\n * Adds a callback function which will be invoked during certain DI events within the\n * runtime (for example: injecting services, creating injectable instances, configuring providers).\n * Multiple profiler callbacks can be set: in this case profiling events are\n * reported to every registered callback.\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n * @returns a cleanup function that, when invoked, removes a given profiler callback.\n */\nfunction setInjectorProfiler(injectorProfiler) {\n    !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n    if (injectorProfiler !== null) {\n        if (!injectorProfilerCallbacks.includes(injectorProfiler)) {\n            injectorProfilerCallbacks.push(injectorProfiler);\n        }\n        return () => removeProfiler(injectorProfiler);\n    }\n    else {\n        injectorProfilerCallbacks.length = 0;\n        return NOOP_PROFILER_REMOVAL;\n    }\n}\n/**\n * Injector profiler function which emits on DI events executed by the runtime.\n *\n * @param event InjectorProfilerEvent corresponding to the DI event being emitted\n */\nfunction injectorProfiler(event) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    for (let i = 0; i < injectorProfilerCallbacks.length; i++) {\n        const injectorProfilerCallback = injectorProfilerCallbacks[i];\n        injectorProfilerCallback(event);\n    }\n}\n/**\n * Emits an InjectorProfilerEventType.ProviderConfigured to the injector profiler. The data in the\n * emitted event includes the raw provider, as well as the token that provider is providing.\n *\n * @param eventProvider A provider object\n */\nfunction emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    let token;\n    // if the provider is a TypeProvider (typeof provider is function) then the token is the\n    // provider itself\n    if (typeof eventProvider === 'function') {\n        token = eventProvider;\n    }\n    // if the provider is an injection token, then the token is the injection token.\n    else if (eventProvider instanceof InjectionToken) {\n        token = eventProvider;\n    }\n    // in all other cases we can access the token via the `provide` property of the provider\n    else {\n        token = resolveForwardRef(eventProvider.provide);\n    }\n    let provider = eventProvider;\n    // Injection tokens may define their own default provider which gets attached to the token itself\n    // as `ɵprov`. In this case, we want to emit the provider that is attached to the token, not the\n    // token itself.\n    if (eventProvider instanceof InjectionToken) {\n        provider = eventProvider.ɵprov || eventProvider;\n    }\n    injectorProfiler({\n        type: 2 /* InjectorProfilerEventType.ProviderConfigured */,\n        context: getInjectorProfilerContext(),\n        providerRecord: { token, provider, isViewProvider },\n    });\n}\n/**\n * Emits an event to the injector profiler when an instance corresponding to a given token is about to be created be an injector. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nfunction emitInjectorToCreateInstanceEvent(token) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 4 /* InjectorProfilerEventType.InjectorToCreateInstanceEvent */,\n        context: getInjectorProfilerContext(),\n        token: token,\n    });\n}\n/**\n * Emits an event to the injector profiler with the instance that was created. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nfunction emitInstanceCreatedByInjectorEvent(instance) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 1 /* InjectorProfilerEventType.InstanceCreatedByInjector */,\n        context: getInjectorProfilerContext(),\n        instance: { value: instance },\n    });\n}\n/**\n * @param token DI token associated with injected service\n * @param value the instance of the injected service (i.e the result of `inject(token)`)\n * @param flags the flags that the token was injected with\n */\nfunction emitInjectEvent(token, value, flags) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 0 /* InjectorProfilerEventType.Inject */,\n        context: getInjectorProfilerContext(),\n        service: { token, value, flags },\n    });\n}\nfunction emitEffectCreatedEvent(effect) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 3 /* InjectorProfilerEventType.EffectCreated */,\n        context: getInjectorProfilerContext(),\n        effect,\n    });\n}\nfunction runInInjectorProfilerContext(injector, token, callback) {\n    !ngDevMode &&\n        throwError('runInInjectorProfilerContext should never be called in production mode');\n    const prevInjectContext = setInjectorProfilerContext({ injector, token });\n    try {\n        callback();\n    }\n    finally {\n        setInjectorProfilerContext(prevInjectContext);\n    }\n}\n\nfunction isEnvironmentProviders(value) {\n    return value && !!value.ɵproviders;\n}\n\nconst NG_COMP_DEF = getClosureSafeProperty({ ɵcmp: getClosureSafeProperty });\nconst NG_DIR_DEF = getClosureSafeProperty({ ɵdir: getClosureSafeProperty });\nconst NG_PIPE_DEF = getClosureSafeProperty({ ɵpipe: getClosureSafeProperty });\nconst NG_MOD_DEF = getClosureSafeProperty({ ɵmod: getClosureSafeProperty });\nconst NG_FACTORY_DEF = getClosureSafeProperty({ ɵfac: getClosureSafeProperty });\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nconst NG_ELEMENT_ID = getClosureSafeProperty({\n    __NG_ELEMENT_ID__: getClosureSafeProperty,\n});\n/**\n * The `NG_ENV_ID` field on a DI token indicates special processing in the `EnvironmentInjector`:\n * getting such tokens from the `EnvironmentInjector` will bypass the standard DI resolution\n * strategy and instead will return implementation produced by the `NG_ENV_ID` factory function.\n *\n * This particular retrieval of DI tokens is mostly done to eliminate circular dependencies and\n * improve tree-shaking.\n */\nconst NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nfunction renderStringify(value) {\n    if (typeof value === 'string')\n        return value;\n    if (value == null)\n        return '';\n    // Use `String` so that it invokes the `toString` method of the value. Note that this\n    // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n    return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n *\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nfunction stringifyForError(value) {\n    if (typeof value === 'function')\n        return value.name || value.toString();\n    if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n        return value.type.name || value.type.toString();\n    }\n    return renderStringify(value);\n}\n/**\n * Used to stringify a `Type` and including the file path and line number in which it is defined, if\n * possible, for better debugging experience.\n *\n * Important! This function contains a megamorphic read and should only be used for error messages.\n */\nfunction debugStringifyTypeForError(type) {\n    // TODO(pmvald): Do some refactoring so that we can use getComponentDef here without creating\n    // circular deps.\n    let componentDef = type[NG_COMP_DEF] || null;\n    if (componentDef !== null && componentDef.debugInfo) {\n        return stringifyTypeFromDebugInfo(componentDef.debugInfo);\n    }\n    return stringifyForError(type);\n}\n// TODO(pmvald): Do some refactoring so that we can use the type ClassDebugInfo for the param\n// debugInfo here without creating circular deps.\nfunction stringifyTypeFromDebugInfo(debugInfo) {\n    if (!debugInfo.filePath || !debugInfo.lineNumber) {\n        return debugInfo.className;\n    }\n    else {\n        return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;\n    }\n}\n\nconst NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({ 'ngErrorCode': getClosureSafeProperty });\nconst NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({ 'ngErrorMessage': getClosureSafeProperty });\nconst NG_TOKEN_PATH = getClosureSafeProperty({ 'ngTokenPath': getClosureSafeProperty });\n/** Creates a circular dependency runtime error. */\nfunction cyclicDependencyError(token, path) {\n    const message = ngDevMode ? `Circular dependency detected for \\`${token}\\`.` : '';\n    return createRuntimeError(message, -200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, path);\n}\n/** Creates a circular dependency runtime error including a dependency path in the error message. */\nfunction cyclicDependencyErrorWithDetails(token, path) {\n    return augmentRuntimeError(cyclicDependencyError(token, path), null);\n}\nfunction throwMixedMultiProviderError() {\n    throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n    if (ngModuleType && providers) {\n        const providerDetail = providers.map((v) => (v == provider ? '?' + provider + '?' : '...'));\n        throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n    }\n    else if (isEnvironmentProviders(provider)) {\n        if (provider.ɵfromNgModule) {\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n        }\n        else {\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n        }\n    }\n    else {\n        throw new Error('Invalid provider');\n    }\n}\n/** Throws an error when a token is not found in DI. */\nfunction throwProviderNotFoundError(token, injectorName) {\n    const errorMessage = ngDevMode &&\n        `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;\n    throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, errorMessage);\n}\n/**\n * Given an Error instance and the current token - update the monkey-patched\n * dependency path info to include that token.\n *\n * @param error Current instance of the Error class.\n * @param token Extra token that should be appended.\n */\nfunction prependTokenToDependencyPath(error, token) {\n    error[NG_TOKEN_PATH] ??= [];\n    // Append current token to the current token path. Since the error\n    // is bubbling up, add the token in front of other tokens.\n    const currentPath = error[NG_TOKEN_PATH];\n    // Do not append the same token multiple times.\n    let pathStr;\n    if (typeof token === 'object' && 'multi' in token && token?.multi === true) {\n        assertDefined(token.provide, 'Token with multi: true should have a provide property');\n        pathStr = stringifyForError(token.provide);\n    }\n    else {\n        pathStr = stringifyForError(token);\n    }\n    if (currentPath[0] !== pathStr) {\n        error[NG_TOKEN_PATH].unshift(pathStr);\n    }\n}\n/**\n * Modifies an Error instance with an updated error message\n * based on the accumulated dependency path.\n *\n * @param error Current instance of the Error class.\n * @param source Extra info about the injector which started\n *    the resolution process, which eventually failed.\n */\nfunction augmentRuntimeError(error, source) {\n    const tokenPath = error[NG_TOKEN_PATH];\n    const errorCode = error[NG_RUNTIME_ERROR_CODE];\n    const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;\n    error.message = formatErrorMessage(message, errorCode, tokenPath, source);\n    return error;\n}\n/**\n * Creates an initial RuntimeError instance when a problem is detected.\n * Monkey-patches extra info in the RuntimeError instance, so that it can\n * be reused later, before throwing the final error.\n */\nfunction createRuntimeError(message, code, path) {\n    // Cast to `any`, so that extra info can be monkey-patched onto this instance.\n    const error = new RuntimeError(code, message);\n    // Monkey-patch a runtime error code and a path onto an Error instance.\n    error[NG_RUNTIME_ERROR_CODE] = code;\n    error[NG_RUNTIME_ERROR_MESSAGE] = message;\n    if (path) {\n        error[NG_TOKEN_PATH] = path;\n    }\n    return error;\n}\n/**\n * Reads monkey-patched error code from the given Error instance.\n */\nfunction getRuntimeErrorCode(error) {\n    return error[NG_RUNTIME_ERROR_CODE];\n}\nfunction formatErrorMessage(text, code, path = [], source = null) {\n    let pathDetails = '';\n    // If the path is empty or contains only one element (self) -\n    // do not append additional info the error message.\n    if (path && path.length > 1) {\n        pathDetails = ` Path: ${path.join(' -> ')}.`;\n    }\n    const sourceDetails = source ? ` Source: ${source}.` : '';\n    return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);\n}\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation;\nfunction getInjectImplementation() {\n    return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\nfunction setInjectImplementation(impl) {\n    const previous = _injectImplementation;\n    _injectImplementation = impl;\n    return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n    const injectableDef = getInjectableDef(token);\n    if (injectableDef && injectableDef.providedIn == 'root') {\n        return injectableDef.value === undefined\n            ? (injectableDef.value = injectableDef.factory())\n            : injectableDef.value;\n    }\n    if (flags & 8 /* InternalInjectFlags.Optional */)\n        return null;\n    if (notFoundValue !== undefined)\n        return notFoundValue;\n    throwProviderNotFoundError(token, 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nfunction assertInjectImplementationNotEqual(fn) {\n    ngDevMode &&\n        assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\n/**\n * A wrapper around an `Injector` that implements the `PrimitivesInjector` interface.\n *\n * This is used to allow the `inject` function to be used with the new primitives-based DI system.\n */\nclass RetrievingInjector {\n    injector;\n    constructor(injector) {\n        this.injector = injector;\n    }\n    retrieve(token, options) {\n        const flags = convertToBitFlags(options) || 0 /* InternalInjectFlags.Default */;\n        try {\n            return this.injector.get(token, \n            // When a dependency is requested with an optional flag, DI returns null as the default value.\n            (flags & 8 /* InternalInjectFlags.Optional */ ? null : THROW_IF_NOT_FOUND), flags);\n        }\n        catch (e) {\n            if (isNotFound(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n}\nfunction injectInjectorOnly(token, flags = 0 /* InternalInjectFlags.Default */) {\n    const currentInjector = getCurrentInjector();\n    if (currentInjector === undefined) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n    }\n    else if (currentInjector === null) {\n        return injectRootLimpMode(token, undefined, flags);\n    }\n    else {\n        const options = convertToInjectOptions(flags);\n        // TODO: improve the typings here.\n        // `token` can be a multi: true provider definition, which is considered as a Token but not represented in the typings\n        const value = currentInjector.retrieve(token, options);\n        ngDevMode && emitInjectEvent(token, value, flags);\n        if (isNotFound(value)) {\n            if (options.optional) {\n                return null;\n            }\n            throw value;\n        }\n        return value;\n    }\n}\nfunction ɵɵinject(token, flags = 0 /* InternalInjectFlags.Default */) {\n    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction ɵɵinvalidFactoryDep(index) {\n    throw new RuntimeError(202 /* RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY */, ngDevMode &&\n        `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported in an [injection context](guide/di/dependency-injection-context). It\n * can be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n * - In a stackframe of a function call in a DI context\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```ts\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```ts\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```ts\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nfunction inject(token, options) {\n    // The `as any` here _shouldn't_ be necessary, but without it JSCompiler\n    // throws a disambiguation  error due to the multiple signatures.\n    return ɵɵinject(token, convertToBitFlags(options));\n}\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\nfunction convertToBitFlags(flags) {\n    if (typeof flags === 'undefined' || typeof flags === 'number') {\n        return flags;\n    }\n    // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n    // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n    // `InjectOptions` to `InjectFlags`.\n    return (0 /* InternalInjectFlags.Default */ | // comment to force a line break in the formatter\n        (flags.optional && 8 /* InternalInjectFlags.Optional */) |\n        (flags.host && 1 /* InternalInjectFlags.Host */) |\n        (flags.self && 2 /* InternalInjectFlags.Self */) |\n        (flags.skipSelf && 4 /* InternalInjectFlags.SkipSelf */));\n}\n// Converts bitflags to inject options\nfunction convertToInjectOptions(flags) {\n    return {\n        optional: !!(flags & 8 /* InternalInjectFlags.Optional */),\n        host: !!(flags & 1 /* InternalInjectFlags.Host */),\n        self: !!(flags & 2 /* InternalInjectFlags.Self */),\n        skipSelf: !!(flags & 4 /* InternalInjectFlags.SkipSelf */),\n    };\n}\nfunction injectArgs(types) {\n    const args = [];\n    for (let i = 0; i < types.length; i++) {\n        const arg = resolveForwardRef(types[i]);\n        if (Array.isArray(arg)) {\n            if (arg.length === 0) {\n                throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\n            }\n            let type = undefined;\n            let flags = 0 /* InternalInjectFlags.Default */;\n            for (let j = 0; j < arg.length; j++) {\n                const meta = arg[j];\n                const flag = getInjectFlag(meta);\n                if (typeof flag === 'number') {\n                    // Special case when we handle @Inject decorator.\n                    if (flag === -1 /* DecoratorFlags.Inject */) {\n                        type = meta.token;\n                    }\n                    else {\n                        flags |= flag;\n                    }\n                }\n                else {\n                    type = meta;\n                }\n            }\n            args.push(ɵɵinject(type, flags));\n        }\n        else {\n            args.push(ɵɵinject(arg));\n        }\n    }\n    return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nfunction attachInjectFlag(decorator, flag) {\n    decorator[DI_DECORATOR_FLAG] = flag;\n    decorator.prototype[DI_DECORATOR_FLAG] = flag;\n    return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nfunction getInjectFlag(token) {\n    return token[DI_DECORATOR_FLAG];\n}\n\nfunction getFactoryDef(type, throwNotFound) {\n    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n        throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n    }\n    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nfunction arrayEquals(a, b, identityAccessor) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        let valueA = a[i];\n        let valueB = b[i];\n        if (identityAccessor) {\n            valueA = identityAccessor(valueA);\n            valueB = identityAccessor(valueB);\n        }\n        if (valueB !== valueA) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens an array.\n */\nfunction flatten(list) {\n    return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input, fn) {\n    input.forEach((value) => (Array.isArray(value) ? deepForEach(value, fn) : fn(value)));\n}\nfunction addToArray(arr, index, value) {\n    // perf: array.push is faster than array.splice!\n    if (index >= arr.length) {\n        arr.push(value);\n    }\n    else {\n        arr.splice(index, 0, value);\n    }\n}\nfunction removeFromArray(arr, index) {\n    // perf: array.pop is faster than array.splice!\n    if (index >= arr.length - 1) {\n        return arr.pop();\n    }\n    else {\n        return arr.splice(index, 1)[0];\n    }\n}\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nfunction arraySplice(array, index, count) {\n    const length = array.length - count;\n    while (index < length) {\n        array[index] = array[index + count];\n        index++;\n    }\n    while (count--) {\n        array.pop(); // shrink the array\n    }\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nfunction arrayInsert2(array, index, value1, value2) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\n    let end = array.length;\n    if (end == index) {\n        // inserting at the end.\n        array.push(value1, value2);\n    }\n    else if (end === 1) {\n        // corner case when we have less items in array than we have items to insert.\n        array.push(value2, array[0]);\n        array[0] = value1;\n    }\n    else {\n        end--;\n        array.push(array[end - 1], array[end]);\n        while (end > index) {\n            const previousEnd = end - 2;\n            array[end] = array[previousEnd];\n            end--;\n        }\n        array[index] = value1;\n        array[index + 1] = value2;\n    }\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nfunction keyValueArraySet(keyValueArray, key, value) {\n    let index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it set it.\n        keyValueArray[index | 1] = value;\n    }\n    else {\n        index = ~index;\n        arrayInsert2(keyValueArray, index, key, value);\n    }\n    return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nfunction keyValueArrayGet(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it retrieve it.\n        return keyValueArray[index | 1];\n    }\n    return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n    return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array, value, shift) {\n    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n    let start = 0;\n    let end = array.length >> shift;\n    while (end !== start) {\n        const middle = start + ((end - start) >> 1); // find the middle.\n        const current = array[middle << shift];\n        if (value === current) {\n            return middle << shift;\n        }\n        else if (current > value) {\n            end = middle;\n        }\n        else {\n            start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n        }\n    }\n    return ~(end << shift);\n}\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n    // These property accesses can be ignored because ngDevMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_OBJ);\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_ARRAY);\n}\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @deprecated from v19.0.0, use provideEnvironmentInitializer instead\n *\n * @see {@link provideEnvironmentInitializer}\n *\n * Note: As opposed to the `APP_INITIALIZER` token, the `ENVIRONMENT_INITIALIZER` functions are not awaited,\n * hence they should not be `async`.\n *\n * @publicApi\n */\nconst ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nconst INJECTOR$1 = new InjectionToken(ngDevMode ? 'INJECTOR' : '', \n// Disable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1 /* InjectorMarkers.Injector */);\n\nconst INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? 'INJECTOR_DEF_TYPES' : '');\n\nclass NullInjector {\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n        if (notFoundValue === THROW_IF_NOT_FOUND) {\n            const message = ngDevMode ? `No provider found for \\`${stringify(token)}\\`.` : '';\n            const error = createRuntimeError(message, -201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */);\n            // Note: This is the name used by the primitives to identify a not found error.\n            error.name = 'ɵNotFound';\n            throw error;\n        }\n        return notFoundValue;\n    }\n}\n\nfunction getNgModuleDef(type) {\n    return type[NG_MOD_DEF] || null;\n}\nfunction getNgModuleDefOrThrow(type) {\n    const ngModuleDef = getNgModuleDef(type);\n    if (!ngModuleDef) {\n        throw new RuntimeError(915 /* RuntimeErrorCode.MISSING_NG_MODULE_DEFINITION */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Type ${stringify(type)} does not have 'ɵmod' property.`);\n    }\n    return ngModuleDef;\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nfunction getComponentDef(type) {\n    return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDefOrThrow(type) {\n    const def = getDirectiveDef(type);\n    if (!def) {\n        throw new RuntimeError(916 /* RuntimeErrorCode.MISSING_DIRECTIVE_DEFINITION */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Type ${stringify(type)} does not have 'ɵdir' property.`);\n    }\n    return def;\n}\nfunction getDirectiveDef(type) {\n    return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef(type) {\n    return type[NG_PIPE_DEF] || null;\n}\n/**\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\n * This will return false if passed anything other than a Component, Directive, or Pipe class\n * See [this guide](guide/components/importing) for additional information:\n *\n * @param type A reference to a Component, Directive or Pipe.\n * @publicApi\n */\nfunction isStandalone(type) {\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    return def !== null && def.standalone;\n}\n\n/**\n * Wrap an array of `Provider`s into `EnvironmentProviders`, preventing them from being accidentally\n * referenced in `@Component` in a component injector.\n *\n * @publicApi\n */\nfunction makeEnvironmentProviders(providers) {\n    return {\n        ɵproviders: providers,\n    };\n}\n/**\n * @description\n * This function is used to provide initialization functions that will be executed upon construction\n * of an environment injector.\n *\n * Note that the provided initializer is run in the injection context.\n *\n * Previously, this was achieved using the `ENVIRONMENT_INITIALIZER` token which is now deprecated.\n *\n * @see {@link ENVIRONMENT_INITIALIZER}\n *\n * @usageNotes\n * The following example illustrates how to configure an initialization function using\n * `provideEnvironmentInitializer()`\n * ```ts\n * createEnvironmentInjector(\n *   [\n *     provideEnvironmentInitializer(() => {\n *       console.log('environment initialized');\n *     }),\n *   ],\n *   parentInjector\n * );\n * ```\n *\n * @publicApi\n */\nfunction provideEnvironmentInitializer(initializerFn) {\n    return makeEnvironmentProviders([\n        {\n            provide: ENVIRONMENT_INITIALIZER,\n            multi: true,\n            useValue: initializerFn,\n        },\n    ]);\n}\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/components/importing).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```ts\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```ts\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n */\nfunction importProvidersFrom(...sources) {\n    return {\n        ɵproviders: internalImportProvidersFrom(true, sources),\n        ɵfromNgModule: true,\n    };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n    const providersOut = [];\n    const dedup = new Set(); // already seen types\n    let injectorTypesWithProviders;\n    const collectProviders = (provider) => {\n        providersOut.push(provider);\n    };\n    deepForEach(sources, (source) => {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n            const cmpDef = getComponentDef(source);\n            if (cmpDef?.standalone) {\n                throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n            }\n        }\n        // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n        const internalSource = source;\n        if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n            injectorTypesWithProviders ||= [];\n            injectorTypesWithProviders.push(internalSource);\n        }\n    });\n    // Collect all providers from `ModuleWithProviders` types.\n    if (injectorTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n    }\n    return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\n    for (let i = 0; i < typesWithProviders.length; i++) {\n        const { ngModule, providers } = typesWithProviders[i];\n        deepForEachProvider(providers, (provider) => {\n            ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n            visitor(provider, ngModule);\n        });\n    }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nfunction walkProviderTree(container, visitor, parents, dedup) {\n    container = resolveForwardRef(container);\n    if (!container)\n        return false;\n    // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n    // from `InjectorTypeWithProviders`.\n    let defType = null;\n    let injDef = getInjectorDef(container);\n    const cmpDef = !injDef && getComponentDef(container);\n    if (!injDef && !cmpDef) {\n        // `container` is not an injector type or a component type. It might be:\n        //  * An `InjectorTypeWithProviders` that wraps an injector type.\n        //  * A standalone directive or pipe that got pulled in from a standalone component's\n        //    dependencies.\n        // Try to unwrap it as an `InjectorTypeWithProviders` first.\n        const ngModule = container\n            .ngModule;\n        injDef = getInjectorDef(ngModule);\n        if (injDef) {\n            defType = ngModule;\n        }\n        else {\n            // Not a component or injector type, so ignore it.\n            return false;\n        }\n    }\n    else if (cmpDef && !cmpDef.standalone) {\n        return false;\n    }\n    else {\n        defType = container;\n    }\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n        const defName = stringify(defType);\n        const path = parents.map(stringify).concat(defName);\n        throw cyclicDependencyErrorWithDetails(defName, path);\n    }\n    // Check for multiple imports of the same module\n    const isDuplicate = dedup.has(defType);\n    if (cmpDef) {\n        if (isDuplicate) {\n            // This component definition has already been processed.\n            return false;\n        }\n        dedup.add(defType);\n        if (cmpDef.dependencies) {\n            const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n            for (const dep of deps) {\n                walkProviderTree(dep, visitor, parents, dedup);\n            }\n        }\n    }\n    else if (injDef) {\n        // First, include providers from any imports.\n        if (injDef.imports != null && !isDuplicate) {\n            // Before processing defType's imports, add it to the set of parents. This way, if it ends\n            // up deeply importing itself, this can be detected.\n            ngDevMode && parents.push(defType);\n            // Add it to the set of dedups. This way we can detect multiple imports of the same module\n            dedup.add(defType);\n            let importTypesWithProviders;\n            try {\n                deepForEach(injDef.imports, (imported) => {\n                    if (walkProviderTree(imported, visitor, parents, dedup)) {\n                        importTypesWithProviders ||= [];\n                        // If the processed import is an injector type with providers, we store it in the\n                        // list of import types with providers, so that we can process those afterwards.\n                        importTypesWithProviders.push(imported);\n                    }\n                });\n            }\n            finally {\n                // Remove it from the parents set when finished.\n                ngDevMode && parents.pop();\n            }\n            // Imports which are declared with providers (TypeWithProviders) need to be processed\n            // after all imported modules are processed. This is similar to how View Engine\n            // processes/merges module imports in the metadata resolver. See: FW-1349.\n            if (importTypesWithProviders !== undefined) {\n                processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n            }\n        }\n        if (!isDuplicate) {\n            // Track the InjectorType and add a provider for it.\n            // It's important that this is done after the def's imports.\n            const factory = getFactoryDef(defType) || (() => new defType());\n            // Append extra providers to make more info available for consumers (to retrieve an injector\n            // type), as well as internally (to calculate an injection scope correctly and eagerly\n            // instantiate a `defType` when an injector is created).\n            // Provider to create `defType` using its factory.\n            visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);\n            // Make this `defType` available to an internal logic that calculates injector scope.\n            visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);\n            // Provider to eagerly instantiate `defType` via `INJECTOR_INITIALIZER`.\n            visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => ɵɵinject(defType), multi: true }, defType);\n        }\n        // Next, include providers listed on the definition itself.\n        const defProviders = injDef.providers;\n        if (defProviders != null && !isDuplicate) {\n            const injectorType = container;\n            deepForEachProvider(defProviders, (provider) => {\n                ngDevMode && validateProvider(provider, defProviders, injectorType);\n                visitor(provider, injectorType);\n            });\n        }\n    }\n    else {\n        // Should not happen, but just in case.\n        return false;\n    }\n    return (defType !== container && container.providers !== undefined);\n}\nfunction validateProvider(provider, providers, containerType) {\n    if (isTypeProvider(provider) ||\n        isValueProvider(provider) ||\n        isFactoryProvider(provider) ||\n        isExistingProvider(provider)) {\n        return;\n    }\n    // Here we expect the provider to be a `useClass` provider (by elimination).\n    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n    if (!classRef) {\n        throwInvalidProviderError(containerType, providers, provider);\n    }\n}\nfunction deepForEachProvider(providers, fn) {\n    for (let provider of providers) {\n        if (isEnvironmentProviders(provider)) {\n            provider = provider.ɵproviders;\n        }\n        if (Array.isArray(provider)) {\n            deepForEachProvider(provider, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\nconst USE_VALUE = getClosureSafeProperty({\n    provide: String,\n    useValue: getClosureSafeProperty,\n});\nfunction isValueProvider(value) {\n    return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\nfunction isExistingProvider(value) {\n    return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n    return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n    return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n    return !!value.useClass;\n}\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nconst INJECTOR_SCOPE = new InjectionToken(ngDevMode ? 'Set Injector scope.' : '');\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR = undefined;\nfunction getNullInjector() {\n    if (NULL_INJECTOR === undefined) {\n        NULL_INJECTOR = new NullInjector();\n    }\n    return NULL_INJECTOR;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @publicApi\n */\nclass EnvironmentInjector {\n}\nclass R3Injector extends EnvironmentInjector {\n    parent;\n    source;\n    scopes;\n    /**\n     * Map of tokens to records which contain the instances of those tokens.\n     * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n     * to prevent further searches.\n     */\n    records = new Map();\n    /**\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n     */\n    _ngOnDestroyHooks = new Set();\n    _onDestroyHooks = [];\n    /**\n     * Flag indicating that this injector was previously destroyed.\n     */\n    get destroyed() {\n        return this._destroyed;\n    }\n    _destroyed = false;\n    injectorDefTypes;\n    constructor(providers, parent, source, scopes) {\n        super();\n        this.parent = parent;\n        this.source = source;\n        this.scopes = scopes;\n        // Start off by creating Records for every provider.\n        forEachSingleProvider(providers, (provider) => this.processProvider(provider));\n        // Make sure the INJECTOR token provides this injector.\n        this.records.set(INJECTOR$1, makeRecord(undefined, this));\n        // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n        if (scopes.has('environment')) {\n            this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n        }\n        // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n        // any injectable scoped to APP_ROOT_SCOPE.\n        const record = this.records.get(INJECTOR_SCOPE);\n        if (record != null && typeof record.value === 'string') {\n            this.scopes.add(record.value);\n        }\n        this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, { self: true }));\n    }\n    retrieve(token, options) {\n        const flags = convertToBitFlags(options) || 0 /* InternalInjectFlags.Default */;\n        try {\n            return this.get(token, \n            // When a dependency is requested with an optional flag, DI returns null as the default value.\n            THROW_IF_NOT_FOUND, flags);\n        }\n        catch (e) {\n            if (isNotFound$1(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Destroy the injector and release references to every instance or provider associated with it.\n     *\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n     * hook was found.\n     */\n    destroy() {\n        assertNotDestroyed(this);\n        // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n        this._destroyed = true;\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            // Call all the lifecycle hooks.\n            for (const service of this._ngOnDestroyHooks) {\n                service.ngOnDestroy();\n            }\n            const onDestroyHooks = this._onDestroyHooks;\n            // Reset the _onDestroyHooks array before iterating over it to prevent hooks that unregister\n            // themselves from mutating the array during iteration.\n            this._onDestroyHooks = [];\n            for (const hook of onDestroyHooks) {\n                hook();\n            }\n        }\n        finally {\n            // Release all references.\n            this.records.clear();\n            this._ngOnDestroyHooks.clear();\n            this.injectorDefTypes.clear();\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    onDestroy(callback) {\n        assertNotDestroyed(this);\n        this._onDestroyHooks.push(callback);\n        return () => this.removeOnDestroy(callback);\n    }\n    runInContext(fn) {\n        assertNotDestroyed(this);\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\n        }\n        try {\n            return fn();\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n        }\n    }\n    get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {\n        assertNotDestroyed(this);\n        if (token.hasOwnProperty(NG_ENV_ID)) {\n            return token[NG_ENV_ID](this);\n        }\n        const flags = convertToBitFlags(options);\n        // Set the injection context.\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: token });\n        }\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            // Check for the SkipSelf flag.\n            if (!(flags & 4 /* InternalInjectFlags.SkipSelf */)) {\n                // SkipSelf isn't set, check if the record belongs to this injector.\n                let record = this.records.get(token);\n                if (record === undefined) {\n                    // No record, but maybe the token is scoped to this injector. Look for an injectable\n                    // def with a scope matching this injector.\n                    const def = couldBeInjectableType(token) && getInjectableDef(token);\n                    if (def && this.injectableDefInScope(def)) {\n                        // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n                        // all along.\n                        if (ngDevMode) {\n                            runInInjectorProfilerContext(this, token, () => {\n                                emitProviderConfiguredEvent(token);\n                            });\n                        }\n                        record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n                    }\n                    else {\n                        record = null;\n                    }\n                    this.records.set(token, record);\n                }\n                // If a record was found, get the instance for it and return it.\n                if (record != null /* NOT null || undefined */) {\n                    return this.hydrate(token, record, flags);\n                }\n            }\n            // Select the next injector based on the Self flag - if self is set, the next injector is\n            // the NullInjector, otherwise it's the parent.\n            const nextInjector = !(flags & 2 /* InternalInjectFlags.Self */) ? this.parent : getNullInjector();\n            // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n            // is undefined, the value is null, otherwise it's the notFoundValue.\n            notFoundValue =\n                flags & 8 /* InternalInjectFlags.Optional */ && notFoundValue === THROW_IF_NOT_FOUND\n                    ? null\n                    : notFoundValue;\n            return nextInjector.get(token, notFoundValue);\n        }\n        catch (error) {\n            // If there was a cyclic dependency error or a token was not found,\n            // an error is thrown at the level where the problem was detected.\n            // The error propagates up the call stack and the code below appends\n            // the current token into the path. As a result, the full path is assembled\n            // at the very top of the call stack, so the final error message can be\n            // formatted to include that path.\n            const errorCode = getRuntimeErrorCode(error);\n            if (errorCode === -200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */ ||\n                errorCode === -201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */) {\n                if (!ngDevMode) {\n                    throw new RuntimeError(errorCode, null);\n                }\n                prependTokenToDependencyPath(error, token);\n                if (previousInjector) {\n                    // We still have a parent injector, keep throwing\n                    throw error;\n                }\n                else {\n                    // Format & throw the final error message when we don't have any previous injector\n                    throw augmentRuntimeError(error, this.source);\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n        finally {\n            // Lastly, restore the previous injection context.\n            setInjectImplementation(previousInjectImplementation);\n            setCurrentInjector(previousInjector);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n        }\n    }\n    /** @internal */\n    resolveInjectorInitializers() {\n        const prevConsumer = setActiveConsumer(null);\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\n        }\n        try {\n            const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, { self: true });\n            if (ngDevMode && !Array.isArray(initializers)) {\n                throw new RuntimeError(-209 /* RuntimeErrorCode.INVALID_MULTI_PROVIDER */, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' +\n                    `(expected an array, but got ${typeof initializers}). ` +\n                    'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' +\n                    '`multi: true` provider.');\n            }\n            for (const initializer of initializers) {\n                initializer();\n            }\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    toString() {\n        const tokens = [];\n        const records = this.records;\n        for (const token of records.keys()) {\n            tokens.push(stringify(token));\n        }\n        return `R3Injector[${tokens.join(', ')}]`;\n    }\n    /**\n     * Process a `SingleProvider` and add it.\n     */\n    processProvider(provider) {\n        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n        // property.\n        provider = resolveForwardRef(provider);\n        let token = isTypeProvider(provider)\n            ? provider\n            : resolveForwardRef(provider && provider.provide);\n        // Construct a `Record` for the provider.\n        const record = providerToRecord(provider);\n        if (ngDevMode) {\n            runInInjectorProfilerContext(this, token, () => {\n                // Emit InjectorProfilerEventType.Create if provider is a value provider because\n                // these are the only providers that do not go through the value hydration logic\n                // where this event would normally be emitted from.\n                if (isValueProvider(provider)) {\n                    emitInjectorToCreateInstanceEvent(token);\n                    emitInstanceCreatedByInjectorEvent(provider.useValue);\n                }\n                emitProviderConfiguredEvent(provider);\n            });\n        }\n        if (!isTypeProvider(provider) && provider.multi === true) {\n            // If the provider indicates that it's a multi-provider, process it specially.\n            // First check whether it's been defined already.\n            let multiRecord = this.records.get(token);\n            if (multiRecord) {\n                // It has. Throw a nice error if\n                if (ngDevMode && multiRecord.multi === undefined) {\n                    throwMixedMultiProviderError();\n                }\n            }\n            else {\n                multiRecord = makeRecord(undefined, NOT_YET, true);\n                multiRecord.factory = () => injectArgs(multiRecord.multi);\n                this.records.set(token, multiRecord);\n            }\n            token = provider;\n            multiRecord.multi.push(provider);\n        }\n        else {\n            if (ngDevMode) {\n                const existing = this.records.get(token);\n                if (existing && existing.multi !== undefined) {\n                    throwMixedMultiProviderError();\n                }\n            }\n        }\n        this.records.set(token, record);\n    }\n    hydrate(token, record, flags) {\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            if (record.value === CIRCULAR) {\n                throw cyclicDependencyError(stringify(token));\n            }\n            else if (record.value === NOT_YET) {\n                record.value = CIRCULAR;\n                if (ngDevMode) {\n                    runInInjectorProfilerContext(this, token, () => {\n                        emitInjectorToCreateInstanceEvent(token);\n                        record.value = record.factory(undefined, flags);\n                        emitInstanceCreatedByInjectorEvent(record.value);\n                    });\n                }\n                else {\n                    record.value = record.factory(undefined, flags);\n                }\n            }\n            if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n                this._ngOnDestroyHooks.add(record.value);\n            }\n            return record.value;\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    injectableDefInScope(def) {\n        if (!def.providedIn) {\n            return false;\n        }\n        const providedIn = resolveForwardRef(def.providedIn);\n        if (typeof providedIn === 'string') {\n            return providedIn === 'any' || this.scopes.has(providedIn);\n        }\n        else {\n            return this.injectorDefTypes.has(providedIn);\n        }\n    }\n    removeOnDestroy(callback) {\n        const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n        if (destroyCBIdx !== -1) {\n            this._onDestroyHooks.splice(destroyCBIdx, 1);\n        }\n    }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n    // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n    const injectableDef = getInjectableDef(token);\n    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n    if (factory !== null) {\n        return factory;\n    }\n    // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n    // If it's missing that, it's an error.\n    if (token instanceof InjectionToken) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\n    }\n    // Undecorated types can sometimes be created if they have no constructor arguments.\n    if (token instanceof Function) {\n        return getUndecoratedInjectableFactory(token);\n    }\n    // There was no way to resolve a factory for this token.\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n    // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n    const paramLength = token.length;\n    if (paramLength > 0) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode &&\n            `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);\n    }\n    // The constructor function appears to have no parameters.\n    // This might be because it inherits from a super-class. In which case, use an injectable\n    // def from an ancestor if there is one.\n    // Otherwise this really is a simple class with no dependencies, so return a factory that\n    // just instantiates the zero-arg constructor.\n    const inheritedInjectableDef = getInheritedInjectableDef(token);\n    if (inheritedInjectableDef !== null) {\n        return () => inheritedInjectableDef.factory(token);\n    }\n    else {\n        return () => new token();\n    }\n}\nfunction providerToRecord(provider) {\n    if (isValueProvider(provider)) {\n        return makeRecord(undefined, provider.useValue);\n    }\n    else {\n        const factory = providerToFactory(provider);\n        return makeRecord(factory, NOT_YET);\n    }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nfunction providerToFactory(provider, ngModuleType, providers) {\n    let factory = undefined;\n    if (ngDevMode && isEnvironmentProviders(provider)) {\n        throwInvalidProviderError(undefined, providers, provider);\n    }\n    if (isTypeProvider(provider)) {\n        const unwrappedProvider = resolveForwardRef(provider);\n        return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n    }\n    else {\n        if (isValueProvider(provider)) {\n            factory = () => resolveForwardRef(provider.useValue);\n        }\n        else if (isFactoryProvider(provider)) {\n            factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n        }\n        else if (isExistingProvider(provider)) {\n            factory = (_, flags) => ɵɵinject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 /* InternalInjectFlags.Optional */\n                ? 8 /* InternalInjectFlags.Optional */\n                : undefined);\n        }\n        else {\n            const classRef = resolveForwardRef(provider &&\n                (provider.useClass || provider.provide));\n            if (ngDevMode && !classRef) {\n                throwInvalidProviderError(ngModuleType, providers, provider);\n            }\n            if (hasDeps(provider)) {\n                factory = () => new classRef(...injectArgs(provider.deps));\n            }\n            else {\n                return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n            }\n        }\n    }\n    return factory;\n}\nfunction assertNotDestroyed(injector) {\n    if (injector.destroyed) {\n        throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\n    }\n}\nfunction makeRecord(factory, value, multi = false) {\n    return {\n        factory: factory,\n        value: value,\n        multi: multi ? [] : undefined,\n    };\n}\nfunction hasDeps(value) {\n    return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n    return (value !== null &&\n        typeof value === 'object' &&\n        typeof value.ngOnDestroy === 'function');\n}\nfunction couldBeInjectableType(value) {\n    return (typeof value === 'function' ||\n        (typeof value === 'object' && value.ngMetadataName === 'InjectionToken'));\n}\nfunction forEachSingleProvider(providers, fn) {\n    for (const provider of providers) {\n        if (Array.isArray(provider)) {\n            forEachSingleProvider(provider, fn);\n        }\n        else if (provider && isEnvironmentProviders(provider)) {\n            forEachSingleProvider(provider.ɵproviders, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\n\n/**\n * Runs the given function in the [context](guide/di/dependency-injection-context) of the given\n * `Injector`.\n *\n * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject dependencies\n * from the given `Injector`. Note that `inject` is only usable synchronously, and cannot be used in\n * any asynchronous callbacks or after any `await` points.\n *\n * @param injector the injector which will satisfy calls to [`inject`](api/core/inject) while `fn`\n *     is executing\n * @param fn the closure to be run in the context of `injector`\n * @returns the return value of the function, if any\n * @publicApi\n */\nfunction runInInjectionContext(injector, fn) {\n    let internalInjector;\n    if (injector instanceof R3Injector) {\n        assertNotDestroyed(injector);\n        internalInjector = injector;\n    }\n    else {\n        internalInjector = new RetrievingInjector(injector);\n    }\n    let prevInjectorProfilerContext;\n    if (ngDevMode) {\n        prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\n    }\n    const prevInjector = setCurrentInjector(internalInjector);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n        return fn();\n    }\n    finally {\n        setCurrentInjector(prevInjector);\n        ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\n        setInjectImplementation(previousInjectImplementation);\n    }\n}\n/**\n * Whether the current stack frame is inside an injection context.\n */\nfunction isInInjectionContext() {\n    return getInjectImplementation() !== undefined || getCurrentInjector() != null;\n}\n/**\n * Asserts that the current stack frame is within an [injection\n * context](guide/di/dependency-injection-context) and has access to `inject`.\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @publicApi\n */\nfunction assertInInjectionContext(debugFn) {\n    // Taking a `Function` instead of a string name here prevents the unminified name of the function\n    // from being retained in the bundle regardless of minification.\n    if (!isInInjectionContext()) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            debugFn.name +\n                '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');\n    }\n}\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nconst HOST = 0;\nconst TVIEW = 1;\n// Shared with LContainer\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst T_HOST = 5;\n// End shared with LContainer\nconst HYDRATION = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR = 9;\nconst ENVIRONMENT = 10;\nconst RENDERER = 11;\nconst CHILD_HEAD = 12;\nconst CHILD_TAIL = 13;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nconst DECLARATION_VIEW = 14;\nconst DECLARATION_COMPONENT_VIEW = 15;\nconst DECLARATION_LCONTAINER = 16;\nconst PREORDER_HOOK_FLAGS = 17;\nconst QUERIES = 18;\nconst ID = 19;\nconst EMBEDDED_VIEW_INJECTOR = 20;\nconst ON_DESTROY_HOOKS = 21;\nconst EFFECTS_TO_SCHEDULE = 22;\nconst EFFECTS = 23;\nconst REACTIVE_TEMPLATE_CONSUMER = 24;\nconst AFTER_RENDER_SEQUENCES_TO_ADD = 25;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nconst HEADER_OFFSET = 26;\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n// FLAGS, PARENT, NEXT, and T_HOST are indices 2, 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\nconst DEHYDRATED_VIEWS = 6;\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nconst CONTAINER_HEADER_OFFSET = 10;\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLView(value) {\n    return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLContainer(value) {\n    return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n    return (tNode.flags & 4 /* TNodeFlags.hasContentQuery */) !== 0;\n}\nfunction isComponentHost(tNode) {\n    return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n    return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\n}\nfunction isComponentDef(def) {\n    return !!def.template;\n}\nfunction isRootView(target) {\n    // Determines whether a given LView is marked as a root view.\n    return (target[FLAGS] & 512 /* LViewFlags.IsRoot */) !== 0;\n}\nfunction isProjectionTNode(tNode) {\n    return (tNode.type & 16 /* TNodeType.Projection */) === 16 /* TNodeType.Projection */;\n}\nfunction hasI18n(lView) {\n    return (lView[FLAGS] & 32 /* LViewFlags.HasI18n */) === 32 /* LViewFlags.HasI18n */;\n}\nfunction isDestroyed(lView) {\n    // Determines whether a given LView is marked as destroyed.\n    return (lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */;\n}\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\nfunction assertTNodeForLView(tNode, lView) {\n    assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeCreationIndex(lView, index) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    assertIndexInRange(lView, adjustedIndex);\n    assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');\n}\nfunction assertTNodeForTView(tNode, tView) {\n    assertTNode(tNode);\n    const tData = tView.data;\n    for (let i = HEADER_OFFSET; i < tData.length; i++) {\n        if (tData[i] === tNode) {\n            return;\n        }\n    }\n    throwError('This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n    assertDefined(tNode, 'TNode must be defined');\n    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n        throwError('Not of type TNode, got: ' + tNode);\n    }\n}\nfunction assertTIcu(tIcu) {\n    assertDefined(tIcu, 'Expected TIcu to be defined');\n    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n        throwError('Object is not of TIcu type.');\n    }\n}\nfunction assertComponentType(actual, msg = \"Type passed in is not ComponentType, it does not have 'ɵcmp' property.\") {\n    if (!getComponentDef(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertNgModuleType(actual, msg = \"Type passed in is not NgModuleType, it does not have 'ɵmod' property.\") {\n    if (!getNgModuleDef(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertHasParent(tNode) {\n    assertDefined(tNode, 'currentTNode should exist!');\n    assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertLContainer(value) {\n    assertDefined(value, 'LContainer must be defined');\n    assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n    assertDefined(value, 'LView must be defined');\n    assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n    assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nfunction assertDirectiveDef(obj) {\n    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n        throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n    }\n}\nfunction assertIndexInDeclRange(tView, index) {\n    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n    if (!(lower <= index && index < upper)) {\n        throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n    }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n    assertDefined(lView, \"Component views should always have a parent view (component's host view)\");\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nfunction assertNodeInjector(lView, injectorIndex) {\n    assertIndexInExpandoRange(lView, injectorIndex);\n    assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\n    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\n}\n\nconst SVG_NAMESPACE = 'svg';\nconst MATH_ML_NAMESPACE = 'math';\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapRNode(value) {\n    while (Array.isArray(value)) {\n        value = value[HOST];\n    }\n    return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLView(value) {\n    while (Array.isArray(value)) {\n        // This check is same as `isLView()` but we don't call at as we don't want to call\n        // `Array.isArray()` twice and give JITer more work for inlining.\n        if (typeof value[TYPE] === 'object')\n            return value;\n        value = value[HOST];\n    }\n    return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nfunction getNativeByIndex(index, lView) {\n    ngDevMode && assertIndexInRange(lView, index);\n    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n    return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNode(tNode, lView) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertIndexInRange(lView, tNode.index);\n    const node = unwrapRNode(lView[tNode.index]);\n    return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNodeOrNull(tNode, lView) {\n    const index = tNode === null ? -1 : tNode.index;\n    if (index !== -1) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        const node = unwrapRNode(lView[index]);\n        return node;\n    }\n    return null;\n}\n// fixme(misko): The return Type should be `TNode|null`\nfunction getTNode(tView, index) {\n    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n    const tNode = tView.data[index];\n    ngDevMode && tNode !== null && assertTNode(tNode);\n    return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\nfunction load(view, index) {\n    ngDevMode && assertIndexInRange(view, index);\n    return view[index];\n}\n/** Store a value in the `data` at a given `index`. */\nfunction store(tView, lView, index, value) {\n    // We don't store any static data for local variables, so the first time\n    // we see the template, we should store as null to avoid a sparse array\n    if (index >= tView.data.length) {\n        tView.data[index] = null;\n        tView.blueprint[index] = null;\n    }\n    lView[index] = value;\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n    // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n    ngDevMode && assertIndexInRange(hostView, nodeIndex);\n    const slotValue = hostView[nodeIndex];\n    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n    return lView;\n}\n/** Checks whether a given view is in creation mode */\nfunction isCreationMode(view) {\n    return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nfunction viewAttachedToChangeDetector(view) {\n    return (view[FLAGS] & 128 /* LViewFlags.Attached */) === 128 /* LViewFlags.Attached */;\n}\n/** Returns a boolean for whether the view is attached to a container. */\nfunction viewAttachedToContainer(view) {\n    return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n    if (index === null || index === undefined)\n        return null;\n    ngDevMode && assertIndexInRange(consts, index);\n    return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nfunction resetPreOrderHookFlags(lView) {\n    lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Adds the `RefreshView` flag from the lView and updates HAS_CHILD_VIEWS_TO_REFRESH flag of\n * parents.\n */\nfunction markViewForRefresh(lView) {\n    if (lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) {\n        return;\n    }\n    lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\n    if (viewAttachedToChangeDetector(lView)) {\n        markAncestorsForTraversal(lView);\n    }\n}\n/**\n * Walks up the LView hierarchy.\n * @param nestingLevel Number of times to walk up in hierarchy.\n * @param currentView View from which to start the lookup.\n */\nfunction walkUpViews(nestingLevel, currentView) {\n    while (nestingLevel > 0) {\n        ngDevMode &&\n            assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n        currentView = currentView[DECLARATION_VIEW];\n        nestingLevel--;\n    }\n    return currentView;\n}\nfunction requiresRefreshOrTraversal(lView) {\n    return !!(lView[FLAGS] & (1024 /* LViewFlags.RefreshView */ | 8192 /* LViewFlags.HasChildViewsToRefresh */) ||\n        lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);\n}\n/**\n * Updates the `HasChildViewsToRefresh` flag on the parents of the `LView` as well as the\n * parents above.\n */\nfunction updateAncestorTraversalFlagsOnAttach(lView) {\n    lView[ENVIRONMENT].changeDetectionScheduler?.notify(8 /* NotificationSource.ViewAttached */);\n    if (lView[FLAGS] & 64 /* LViewFlags.Dirty */) {\n        lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\n    }\n    if (requiresRefreshOrTraversal(lView)) {\n        markAncestorsForTraversal(lView);\n    }\n}\n/**\n * Ensures views above the given `lView` are traversed during change detection even when they are\n * not dirty.\n *\n * This is done by setting the `HAS_CHILD_VIEWS_TO_REFRESH` flag up to the root, stopping when the\n * flag is already `true` or the `lView` is detached.\n */\nfunction markAncestorsForTraversal(lView) {\n    lView[ENVIRONMENT].changeDetectionScheduler?.notify(0 /* NotificationSource.MarkAncestorsForTraversal */);\n    let parent = getLViewParent(lView);\n    while (parent !== null) {\n        // We stop adding markers to the ancestors once we reach one that already has the marker. This\n        // is to avoid needlessly traversing all the way to the root when the marker already exists.\n        if (parent[FLAGS] & 8192 /* LViewFlags.HasChildViewsToRefresh */) {\n            break;\n        }\n        parent[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\n        if (!viewAttachedToChangeDetector(parent)) {\n            break;\n        }\n        parent = getLViewParent(parent);\n    }\n}\n/**\n * Stores a LView-specific destroy callback.\n */\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n    if (isDestroyed(lView)) {\n        throw new RuntimeError(911 /* RuntimeErrorCode.VIEW_ALREADY_DESTROYED */, ngDevMode && 'View has already been destroyed.');\n    }\n    if (lView[ON_DESTROY_HOOKS] === null) {\n        lView[ON_DESTROY_HOOKS] = [];\n    }\n    lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\n/**\n * Removes previously registered LView-specific destroy callback.\n */\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n    if (lView[ON_DESTROY_HOOKS] === null)\n        return;\n    const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n    if (destroyCBIdx !== -1) {\n        lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n    }\n}\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nfunction getLViewParent(lView) {\n    ngDevMode && assertLView(lView);\n    const parent = lView[PARENT];\n    return isLContainer(parent) ? parent[PARENT] : parent;\n}\nfunction getOrCreateLViewCleanup(view) {\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n    return (view[CLEANUP] ??= []);\n}\nfunction getOrCreateTViewCleanup(tView) {\n    return (tView.cleanup ??= []);\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    // Historically the `storeCleanupWithContext` was used to register both framework-level and\n    // user-defined cleanup callbacks, but over time those two types of cleanups were separated.\n    // This dev mode checks assures that user-level cleanup callbacks are _not_ stored in data\n    // structures reserved for framework-specific hooks.\n    ngDevMode &&\n        assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\n    lCleanup.push(context);\n    if (tView.firstCreatePass) {\n        getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n    }\n    else {\n        // Make sure that no new framework-level cleanup functions are registered after the first\n        // template pass is done (and TView data structures are meant to fully constructed).\n        if (ngDevMode) {\n            Object.freeze(getOrCreateTViewCleanup(tView));\n        }\n    }\n}\n\nconst instructionState = {\n    lFrame: createLFrame(null),\n    bindingsEnabled: true,\n    skipHydrationRootTNode: null,\n};\nvar CheckNoChangesMode;\n(function (CheckNoChangesMode) {\n    CheckNoChangesMode[CheckNoChangesMode[\"Off\"] = 0] = \"Off\";\n    CheckNoChangesMode[CheckNoChangesMode[\"Exhaustive\"] = 1] = \"Exhaustive\";\n    CheckNoChangesMode[CheckNoChangesMode[\"OnlyDirtyViews\"] = 2] = \"OnlyDirtyViews\";\n})(CheckNoChangesMode || (CheckNoChangesMode = {}));\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _checkNoChangesMode = 0; /* CheckNoChangesMode.Off */\n/**\n * Flag used to indicate that we are in the middle running change detection on a view\n *\n * @see detectChangesInViewWhileDirty\n */\nlet _isRefreshingViews = false;\nfunction getElementDepthCount() {\n    return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n    return instructionState.bindingsEnabled;\n}\n/**\n * Returns true if currently inside a skip hydration block.\n * @returns boolean\n */\nfunction isInSkipHydrationBlock() {\n    return instructionState.skipHydrationRootTNode !== null;\n}\n/**\n * Returns true if this is the root TNode of the skip hydration block.\n * @param tNode the current TNode\n * @returns boolean\n */\nfunction isSkipHydrationRootTNode(tNode) {\n    return instructionState.skipHydrationRootTNode === tNode;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵenableBindings() {\n    instructionState.bindingsEnabled = true;\n}\n/**\n * Sets a flag to specify that the TNode is in a skip hydration block.\n * @param tNode the current TNode\n */\nfunction enterSkipHydrationBlock(tNode) {\n    instructionState.skipHydrationRootTNode = tNode;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction ɵɵdisableBindings() {\n    instructionState.bindingsEnabled = false;\n}\n/**\n * Clears the root skip hydration node when leaving a skip hydration block.\n */\nfunction leaveSkipHydrationBlock() {\n    instructionState.skipHydrationRootTNode = null;\n}\n/**\n * Return the current `LView`.\n */\nfunction getLView() {\n    return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\nfunction getTView() {\n    return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nfunction ɵɵrestoreView(viewToRestore) {\n    instructionState.lFrame.contextLView = viewToRestore;\n    return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nfunction ɵɵresetView(value) {\n    instructionState.lFrame.contextLView = null;\n    return value;\n}\nfunction getCurrentTNode() {\n    let currentTNode = getCurrentTNodePlaceholderOk();\n    while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\n        currentTNode = currentTNode.parent;\n    }\n    return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n    return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n    const lFrame = instructionState.lFrame;\n    const currentTNode = lFrame.currentTNode;\n    return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n    const lFrame = instructionState.lFrame;\n    lFrame.currentTNode = tNode;\n    lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n    return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n    instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n    const contextLView = instructionState.lFrame.contextLView;\n    ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n    return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n    !ngDevMode && throwError('Must never be called in production mode');\n    return _checkNoChangesMode !== CheckNoChangesMode.Off;\n}\nfunction isExhaustiveCheckNoChanges() {\n    !ngDevMode && throwError('Must never be called in production mode');\n    return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    _checkNoChangesMode = mode;\n}\nfunction isRefreshingViews() {\n    return _isRefreshingViews;\n}\nfunction setIsRefreshingViews(mode) {\n    const prev = _isRefreshingViews;\n    _isRefreshingViews = mode;\n    return prev;\n}\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nfunction getBindingRoot() {\n    const lFrame = instructionState.lFrame;\n    let index = lFrame.bindingRootIndex;\n    if (index === -1) {\n        index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n    }\n    return index;\n}\nfunction getBindingIndex() {\n    return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n    return (instructionState.lFrame.bindingIndex = value);\n}\nfunction nextBindingIndex() {\n    return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n    const lFrame = instructionState.lFrame;\n    const index = lFrame.bindingIndex;\n    lFrame.bindingIndex = lFrame.bindingIndex + count;\n    return index;\n}\nfunction isInI18nBlock() {\n    return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n    instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n    const lFrame = instructionState.lFrame;\n    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nfunction getCurrentDirectiveIndex() {\n    return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nfunction getCurrentDirectiveDef(tData) {\n    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n    return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n    instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView) {\n    const tView = lView[TVIEW];\n    // Return the declaration parent for embedded views\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    // Falling back to `T_HOST` in case we cross component boundary.\n    if (tView.type === 1 /* TViewType.Component */) {\n        return lView[T_HOST];\n    }\n    // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n    return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nfunction enterDI(lView, tNode, flags) {\n    ngDevMode && assertLViewOrUndefined(lView);\n    if (flags & 4 /* InternalInjectFlags.SkipSelf */) {\n        ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n        let parentTNode = tNode;\n        let parentLView = lView;\n        while (true) {\n            ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n            parentTNode = parentTNode.parent;\n            if (parentTNode === null && !(flags & 1 /* InternalInjectFlags.Host */)) {\n                parentTNode = getDeclarationTNode(parentLView);\n                if (parentTNode === null)\n                    break;\n                // In this case, a parent exists and is definitely an element. So it will definitely\n                // have an existing lView as the declaration view, which is why we can assume it's defined.\n                ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n                parentLView = parentLView[DECLARATION_VIEW];\n                // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n                // We want to skip those and look only at Elements and ElementContainers to ensure\n                // we're looking at true parent nodes, and not content or other types.\n                if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (parentTNode === null) {\n            // If we failed to find a parent TNode this means that we should use module injector.\n            return false;\n        }\n        else {\n            tNode = parentTNode;\n            lView = parentLView;\n        }\n    }\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const lFrame = (instructionState.lFrame = allocLFrame());\n    lFrame.currentTNode = tNode;\n    lFrame.lView = lView;\n    return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nfunction enterView(newView) {\n    ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n    ngDevMode && assertLViewOrUndefined(newView);\n    const newLFrame = allocLFrame();\n    if (ngDevMode) {\n        assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n        assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n    }\n    const tView = newView[TVIEW];\n    instructionState.lFrame = newLFrame;\n    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n    newLFrame.currentTNode = tView.firstChild;\n    newLFrame.lView = newView;\n    newLFrame.tView = tView;\n    newLFrame.contextLView = newView;\n    newLFrame.bindingIndex = tView.bindingStartIndex;\n    newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n    const currentLFrame = instructionState.lFrame;\n    const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n    return newLFrame;\n}\nfunction createLFrame(parent) {\n    const lFrame = {\n        currentTNode: null,\n        isParent: true,\n        lView: null,\n        tView: null,\n        selectedIndex: -1,\n        contextLView: null,\n        elementDepthCount: 0,\n        currentNamespace: null,\n        currentDirectiveIndex: -1,\n        bindingRootIndex: -1,\n        bindingIndex: -1,\n        currentQueryIndex: 0,\n        parent: parent,\n        child: null,\n        inI18n: false,\n    };\n    parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n    return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight() {\n    const oldLFrame = instructionState.lFrame;\n    instructionState.lFrame = oldLFrame.parent;\n    oldLFrame.currentTNode = null;\n    oldLFrame.lView = null;\n    return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nfunction leaveView() {\n    const oldLFrame = leaveViewLight();\n    oldLFrame.isParent = true;\n    oldLFrame.tView = null;\n    oldLFrame.selectedIndex = -1;\n    oldLFrame.contextLView = null;\n    oldLFrame.elementDepthCount = 0;\n    oldLFrame.currentDirectiveIndex = -1;\n    oldLFrame.currentNamespace = null;\n    oldLFrame.bindingRootIndex = -1;\n    oldLFrame.bindingIndex = -1;\n    oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n    const contextLView = (instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView));\n    return contextLView[CONTEXT];\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nfunction getSelectedIndex() {\n    return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nfunction setSelectedIndex(index) {\n    ngDevMode &&\n        index !== -1 &&\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n    ngDevMode &&\n        assertLessThan(index, instructionState.lFrame.lView.length, \"Can't set index passed end of LView\");\n    instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nfunction getSelectedTNode() {\n    const lFrame = instructionState.lFrame;\n    return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceSVG() {\n    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceMathML() {\n    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nfunction ɵɵnamespaceHTML() {\n    namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nfunction namespaceHTMLInternal() {\n    instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace() {\n    return instructionState.lFrame.currentNamespace;\n}\nlet _wasLastNodeCreated = true;\n/**\n * Retrieves a global flag that indicates whether the most recent DOM node\n * was created or hydrated.\n */\nfunction wasLastNodeCreated() {\n    return _wasLastNodeCreated;\n}\n/**\n * Sets a global flag to indicate whether the most recent DOM node\n * was created or hydrated.\n */\nfunction lastNodeWasCreated(flag) {\n    _wasLastNodeCreated = flag;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n */\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n    injector.resolveInjectorInitializers();\n    return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n    const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n    name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n    return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/di/dependency-injection-providers) that associate\n * dependencies of various types with [injection tokens](guide/di/dependency-injection-providers).\n *\n * @see [DI Providers](guide/di/dependency-injection-providers).\n * @see {@link StaticProvider}\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nclass Injector {\n    static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n    static NULL = new NullInjector();\n    static create(options, parent) {\n        if (Array.isArray(options)) {\n            return createInjector({ name: '' }, parent, options, '');\n        }\n        else {\n            const name = options.name ?? '';\n            return createInjector({ name }, options.parent, options.providers, name);\n        }\n    }\n    /** @nocollapse */\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n        token: Injector,\n        providedIn: 'any',\n        factory: () => ɵɵinject(INJECTOR$1),\n    });\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */;\n}\n\n/**\n * A DI Token representing the main rendering context.\n * In a browser and SSR this is the DOM Document.\n * When using SSR, that document is created by [Domino](https://github.com/angular/domino).\n *\n * @publicApi\n */\nconst DOCUMENT = new InjectionToken(ngDevMode ? 'DocumentToken' : '');\n\n/**\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\n * is injected in a component or directive, the callbacks run when that component or\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\n *\n * @publicApi\n */\nclass DestroyRef {\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = injectDestroyRef;\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ENV_ID__ = (injector) => injector;\n}\nclass NodeInjectorDestroyRef extends DestroyRef {\n    _lView;\n    constructor(_lView) {\n        super();\n        this._lView = _lView;\n    }\n    get destroyed() {\n        return isDestroyed(this._lView);\n    }\n    onDestroy(callback) {\n        const lView = this._lView;\n        storeLViewOnDestroy(lView, callback);\n        return () => removeLViewOnDestroy(lView, callback);\n    }\n}\nfunction injectDestroyRef() {\n    return new NodeInjectorDestroyRef(getLView());\n}\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * // Provide in standalone apps\n * bootstrapApplication(AppComponent, {\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n *\n * // Provide in module-based apps\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nclass ErrorHandler {\n    /**\n     * @internal\n     */\n    _console = console;\n    handleError(error) {\n        this._console.error('ERROR', error);\n    }\n}\n/**\n * `InjectionToken` used to configure how to call the `ErrorHandler`.\n */\nconst INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {\n    providedIn: 'root',\n    factory: () => {\n        // The user's error handler may depend on things that create a circular dependency\n        // so we inject it lazily.\n        const injector = inject(EnvironmentInjector);\n        let userErrorHandler;\n        return (e) => {\n            if (injector.destroyed && !userErrorHandler) {\n                setTimeout(() => {\n                    throw e;\n                });\n            }\n            else {\n                userErrorHandler ??= injector.get(ErrorHandler);\n                userErrorHandler.handleError(e);\n            }\n        };\n    },\n});\nconst errorHandlerEnvironmentInitializer = {\n    provide: ENVIRONMENT_INITIALIZER,\n    useValue: () => void inject(ErrorHandler),\n    multi: true,\n};\nconst globalErrorListeners = new InjectionToken(ngDevMode ? 'GlobalErrorListeners' : '', {\n    providedIn: 'root',\n    factory: () => {\n        if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n            return;\n        }\n        const window = inject(DOCUMENT).defaultView;\n        if (!window) {\n            return;\n        }\n        const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n        const rejectionListener = (e) => {\n            errorHandler(e.reason);\n            e.preventDefault();\n        };\n        const errorListener = (e) => {\n            if (e.error) {\n                errorHandler(e.error);\n            }\n            else {\n                errorHandler(new Error(ngDevMode\n                    ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}`\n                    : e.message, { cause: e }));\n            }\n            e.preventDefault();\n        };\n        const setupEventListeners = () => {\n            window.addEventListener('unhandledrejection', rejectionListener);\n            window.addEventListener('error', errorListener);\n        };\n        // Angular doesn't have to run change detection whenever any asynchronous tasks are invoked in\n        // the scope of this functionality.\n        if (typeof Zone !== 'undefined') {\n            Zone.root.run(setupEventListeners);\n        }\n        else {\n            setupEventListeners();\n        }\n        inject(DestroyRef).onDestroy(() => {\n            window.removeEventListener('error', errorListener);\n            window.removeEventListener('unhandledrejection', rejectionListener);\n        });\n    },\n});\n/**\n * Provides an environment initializer which forwards unhandled errors to the ErrorHandler.\n *\n * The listeners added are for the window's 'unhandledrejection' and 'error' events.\n *\n * @publicApi\n */\nfunction provideBrowserGlobalErrorListeners() {\n    return makeEnvironmentProviders([\n        provideEnvironmentInitializer(() => void inject(globalErrorListeners)),\n    ]);\n}\n\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @publicApi 17.0\n */\nfunction isSignal(value) {\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n\n/**\n * Utility function used during template type checking to extract the value from a `WritableSignal`.\n * @codeGenApi\n */\nfunction ɵunwrapWritableSignal(value) {\n    // Note: the function uses `WRITABLE_SIGNAL` as a brand instead of `WritableSignal<T>`,\n    // because the latter incorrectly unwraps non-signal getter functions.\n    return null;\n}\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction signal(initialValue, options) {\n    const [get, set, update] = createSignal(initialValue, options?.equal);\n    const signalFn = get;\n    const node = signalFn[SIGNAL];\n    signalFn.set = set;\n    signalFn.update = update;\n    signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);\n    if (ngDevMode) {\n        signalFn.toString = () => `[Signal: ${signalFn()}]`;\n        node.debugName = options?.debugName;\n    }\n    return signalFn;\n}\nfunction signalAsReadonlyFn() {\n    const node = this[SIGNAL];\n    if (node.readonlyFn === undefined) {\n        const readonlyFn = () => this();\n        readonlyFn[SIGNAL] = node;\n        node.readonlyFn = readonlyFn;\n    }\n    return node.readonlyFn;\n}\n/**\n * Checks if the given `value` is a writeable signal.\n */\nfunction isWritableSignal(value) {\n    return isSignal(value) && typeof value.set === 'function';\n}\n\n/**\n * Injectable that is notified when an `LView` is made aware of changes to application state.\n */\nclass ChangeDetectionScheduler {\n}\n/** Token used to indicate if zoneless was enabled via provideZonelessChangeDetection(). */\nconst ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', { providedIn: 'root', factory: () => false });\n/** Token used to indicate `provideZonelessChangeDetection` was used. */\nconst PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', { providedIn: 'root', factory: () => false });\nconst ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'scheduler disabled' : '');\n// TODO(atscott): Remove in v19. Scheduler should be done with runOutsideAngular.\nconst SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');\n\n/**\n * Asserts that the current stack frame is not within a reactive context. Useful\n * to disallow certain code from running inside a reactive context (see {@link /api/core/rxjs-interop/toSignal toSignal})\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @publicApi\n */\nfunction assertNotInReactiveContext(debugFn, extraContext) {\n    // Taking a `Function` instead of a string name here prevents the un-minified name of the function\n    // from being retained in the bundle regardless of minification.\n    if (getActiveConsumer() !== null) {\n        throw new RuntimeError(-602 /* RuntimeErrorCode.ASSERTION_NOT_INSIDE_REACTIVE_CONTEXT */, ngDevMode &&\n            `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);\n    }\n}\n\nclass ViewContext {\n    view;\n    node;\n    constructor(view, node) {\n        this.view = view;\n        this.node = node;\n    }\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = injectViewContext;\n}\nfunction injectViewContext() {\n    return new ViewContext(getLView(), getCurrentTNode());\n}\n\n/**\n * Internal implementation of the pending tasks service.\n */\nclass PendingTasksInternal {\n    taskId = 0;\n    pendingTasks = new Set();\n    destroyed = false;\n    pendingTask = new BehaviorSubject(false);\n    get hasPendingTasks() {\n        // Accessing the value of a closed `BehaviorSubject` throws an error.\n        return this.destroyed ? false : this.pendingTask.value;\n    }\n    /**\n     * In case the service is about to be destroyed, return a self-completing observable.\n     * Otherwise, return the observable that emits the current state of pending tasks.\n     */\n    get hasPendingTasksObservable() {\n        if (this.destroyed) {\n            // Manually creating the observable pulls less symbols from RxJS than `of(false)`.\n            return new Observable((subscriber) => {\n                subscriber.next(false);\n                subscriber.complete();\n            });\n        }\n        return this.pendingTask;\n    }\n    add() {\n        // Emitting a value to a closed subject throws an error.\n        if (!this.hasPendingTasks && !this.destroyed) {\n            this.pendingTask.next(true);\n        }\n        const taskId = this.taskId++;\n        this.pendingTasks.add(taskId);\n        return taskId;\n    }\n    has(taskId) {\n        return this.pendingTasks.has(taskId);\n    }\n    remove(taskId) {\n        this.pendingTasks.delete(taskId);\n        if (this.pendingTasks.size === 0 && this.hasPendingTasks) {\n            this.pendingTask.next(false);\n        }\n    }\n    ngOnDestroy() {\n        this.pendingTasks.clear();\n        if (this.hasPendingTasks) {\n            this.pendingTask.next(false);\n        }\n        // We call `unsubscribe()` to release observers, as users may forget to\n        // unsubscribe manually when subscribing to `isStable`. We do not call\n        // `complete()` because it is unsafe; if someone subscribes using the `first`\n        // operator and the observable completes before emitting a value,\n        // RxJS will throw an error.\n        this.destroyed = true;\n        this.pendingTask.unsubscribe();\n    }\n    /** @nocollapse */\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n        token: PendingTasksInternal,\n        providedIn: 'root',\n        factory: () => new PendingTasksInternal(),\n    });\n}\n/**\n * Service that keeps track of pending tasks contributing to the stableness of Angular\n * application. While several existing Angular services (ex.: `HttpClient`) will internally manage\n * tasks influencing stability, this API gives control over stability to library and application\n * developers for specific cases not covered by Angular internals.\n *\n * The concept of stability comes into play in several important scenarios:\n * - SSR process needs to wait for the application stability before serializing and sending rendered\n * HTML;\n * - tests might want to delay assertions until the application becomes stable;\n *\n * @usageNotes\n * ```ts\n * const pendingTasks = inject(PendingTasks);\n * const taskCleanup = pendingTasks.add();\n * // do work that should block application's stability and then:\n * taskCleanup();\n * ```\n *\n * @publicApi 20.0\n */\nclass PendingTasks {\n    internalPendingTasks = inject(PendingTasksInternal);\n    scheduler = inject(ChangeDetectionScheduler);\n    errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n    /**\n     * Adds a new task that should block application's stability.\n     * @returns A cleanup function that removes a task when called.\n     */\n    add() {\n        const taskId = this.internalPendingTasks.add();\n        return () => {\n            if (!this.internalPendingTasks.has(taskId)) {\n                // This pending task has already been cleared.\n                return;\n            }\n            // Notifying the scheduler will hold application stability open until the next tick.\n            this.scheduler.notify(11 /* NotificationSource.PendingTaskRemoved */);\n            this.internalPendingTasks.remove(taskId);\n        };\n    }\n    /**\n     * Runs an asynchronous function and blocks the application's stability until the function completes.\n     *\n     * ```ts\n     * pendingTasks.run(async () => {\n     *   const userData = await fetch('/api/user');\n     *   this.userData.set(userData);\n     * });\n     * ```\n     *\n     * @param fn The asynchronous function to execute\n     * @developerPreview 19.0\n     */\n    run(fn) {\n        const removeTask = this.add();\n        fn().catch(this.errorHandler).finally(removeTask);\n    }\n    /** @nocollapse */\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n        token: PendingTasks,\n        providedIn: 'root',\n        factory: () => new PendingTasks(),\n    });\n}\n\nfunction noop(...args) {\n    // Do nothing.\n}\n\n/**\n * A scheduler which manages the execution of effects.\n */\nclass EffectScheduler {\n    /** @nocollapse */\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\n        token: EffectScheduler,\n        providedIn: 'root',\n        factory: () => new ZoneAwareEffectScheduler(),\n    });\n}\n/**\n * A wrapper around `ZoneAwareQueueingScheduler` that schedules flushing via the microtask queue\n * when.\n */\nclass ZoneAwareEffectScheduler {\n    dirtyEffectCount = 0;\n    queues = new Map();\n    add(handle) {\n        this.enqueue(handle);\n        this.schedule(handle);\n    }\n    schedule(handle) {\n        if (!handle.dirty) {\n            return;\n        }\n        this.dirtyEffectCount++;\n    }\n    remove(handle) {\n        const zone = handle.zone;\n        const queue = this.queues.get(zone);\n        if (!queue.has(handle)) {\n            return;\n        }\n        queue.delete(handle);\n        if (handle.dirty) {\n            this.dirtyEffectCount--;\n        }\n    }\n    enqueue(handle) {\n        const zone = handle.zone;\n        if (!this.queues.has(zone)) {\n            this.queues.set(zone, new Set());\n        }\n        const queue = this.queues.get(zone);\n        if (queue.has(handle)) {\n            return;\n        }\n        queue.add(handle);\n    }\n    /**\n     * Run all scheduled effects.\n     *\n     * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no\n     * ordering guarantee between effects scheduled in different zones.\n     */\n    flush() {\n        while (this.dirtyEffectCount > 0) {\n            let ranOneEffect = false;\n            for (const [zone, queue] of this.queues) {\n                // `zone` here must be defined.\n                if (zone === null) {\n                    ranOneEffect ||= this.flushQueue(queue);\n                }\n                else {\n                    ranOneEffect ||= zone.run(() => this.flushQueue(queue));\n                }\n            }\n            // Safeguard against infinite looping if somehow our dirty effect count gets out of sync with\n            // the dirty flag across all the effects.\n            if (!ranOneEffect) {\n                this.dirtyEffectCount = 0;\n            }\n        }\n    }\n    flushQueue(queue) {\n        let ranOneEffect = false;\n        for (const handle of queue) {\n            if (!handle.dirty) {\n                continue;\n            }\n            this.dirtyEffectCount--;\n            ranOneEffect = true;\n            // TODO: what happens if this throws an error?\n            handle.run();\n        }\n        return ranOneEffect;\n    }\n}\n\nexport { AFTER_RENDER_SEQUENCES_TO_ADD, CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTAINER_HEADER_OFFSET, CONTEXT, ChangeDetectionScheduler, CheckNoChangesMode, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DECLARATION_VIEW, DEHYDRATED_VIEWS, DOCUMENT, DestroyRef, EFFECTS, EFFECTS_TO_SCHEDULE, EMBEDDED_VIEW_INJECTOR, EMPTY_ARRAY, EMPTY_OBJ, ENVIRONMENT, ENVIRONMENT_INITIALIZER, EffectScheduler, EnvironmentInjector, ErrorHandler, FLAGS, HEADER_OFFSET, HOST, HYDRATION, ID, INJECTOR$1 as INJECTOR, INJECTOR as INJECTOR$1, INJECTOR_DEF_TYPES, INJECTOR_SCOPE, INTERNAL_APPLICATION_ERROR_HANDLER, InjectionToken, Injector, MATH_ML_NAMESPACE, MOVED_VIEWS, NATIVE, NEXT, NG_COMP_DEF, NG_DIR_DEF, NG_ELEMENT_ID, NG_FACTORY_DEF, NG_INJ_DEF, NG_MOD_DEF, NG_PIPE_DEF, NG_PROV_DEF, NodeInjectorDestroyRef, NullInjector, ON_DESTROY_HOOKS, PARENT, PREORDER_HOOK_FLAGS, PROVIDED_ZONELESS, PendingTasks, PendingTasksInternal, QUERIES, R3Injector, REACTIVE_TEMPLATE_CONSUMER, RENDERER, RuntimeError, SCHEDULE_IN_ROOT_ZONE, SVG_NAMESPACE, TVIEW, T_HOST, VIEW_REFS, ViewContext, XSS_SECURITY_URL, ZONELESS_ENABLED, ZONELESS_SCHEDULER_DISABLED, _global, addToArray, arrayEquals, arrayInsert2, arraySplice, assertComponentType, assertDefined, assertDirectiveDef, assertDomNode, assertElement, assertEqual, assertFirstCreatePass, assertFirstUpdatePass, assertFunction, assertGreaterThan, assertGreaterThanOrEqual, assertHasParent, assertInInjectionContext, assertIndexInDeclRange, assertIndexInExpandoRange, assertIndexInRange, assertInjectImplementationNotEqual, assertLContainer, assertLView, assertLessThan, assertNgModuleType, assertNodeInjector, assertNotDefined, assertNotEqual, assertNotInReactiveContext, assertNotReactive, assertNotSame, assertNumber, assertNumberInRange, assertOneOf, assertParentView, assertProjectionSlots, assertSame, assertString, assertTIcu, assertTNode, assertTNodeCreationIndex, assertTNodeForLView, assertTNodeForTView, attachInjectFlag, concatStringsWithSpace, convertToBitFlags, createInjector, createInjectorWithoutInjectorInstances, cyclicDependencyError, cyclicDependencyErrorWithDetails, debugStringifyTypeForError, decreaseElementDepthCount, deepForEach, defineInjectable, emitEffectCreatedEvent, emitInjectEvent, emitInjectorToCreateInstanceEvent, emitInstanceCreatedByInjectorEvent, emitProviderConfiguredEvent, enterDI, enterSkipHydrationBlock, enterView, errorHandlerEnvironmentInitializer, fillProperties, flatten, formatRuntimeError, forwardRef, getBindingIndex, getBindingRoot, getBindingsEnabled, getClosureSafeProperty, getComponentDef, getComponentLViewByIndex, getConstant, getContextLView, getCurrentDirectiveDef, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentQueryIndex, getCurrentTNode, getCurrentTNodePlaceholderOk, getDirectiveDef, getDirectiveDefOrThrow, getElementDepthCount, getFactoryDef, getInjectableDef, getInjectorDef, getLView, getLViewParent, getNamespace, getNativeByIndex, getNativeByTNode, getNativeByTNodeOrNull, getNgModuleDef, getNgModuleDefOrThrow, getNullInjector, getOrCreateLViewCleanup, getOrCreateTViewCleanup, getPipeDef, getSelectedIndex, getSelectedTNode, getTNode, getTView, hasI18n, importProvidersFrom, increaseElementDepthCount, incrementBindingIndex, initNgDevMode, inject, injectRootLimpMode, internalImportProvidersFrom, isClassProvider, isComponentDef, isComponentHost, isContentQueryHost, isCreationMode, isCurrentTNodeParent, isDestroyed, isDirectiveHost, isEnvironmentProviders, isExhaustiveCheckNoChanges, isForwardRef, isInCheckNoChangesMode, isInI18nBlock, isInInjectionContext, isInSkipHydrationBlock, isInjectable, isLContainer, isLView, isProjectionTNode, isRefreshingViews, isRootView, isSignal, isSkipHydrationRootTNode, isStandalone, isTypeProvider, isWritableSignal, keyValueArrayGet, keyValueArrayIndexOf, keyValueArraySet, lastNodeWasCreated, leaveDI, leaveSkipHydrationBlock, leaveView, load, makeEnvironmentProviders, markAncestorsForTraversal, markViewForRefresh, newArray, nextBindingIndex, nextContextImpl, noop, provideBrowserGlobalErrorListeners, provideEnvironmentInitializer, providerToFactory, removeFromArray, removeLViewOnDestroy, renderStringify, requiresRefreshOrTraversal, resetPreOrderHookFlags, resolveForwardRef, runInInjectionContext, runInInjectorProfilerContext, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setCurrentTNodeAsNotParent, setInI18nBlock, setInjectImplementation, setInjectorProfiler, setInjectorProfilerContext, setIsInCheckNoChangesMode, setIsRefreshingViews, setSelectedIndex, signal, signalAsReadonlyFn, store, storeCleanupWithContext, storeLViewOnDestroy, stringify, stringifyForError, throwError, throwProviderNotFoundError, truncateMiddle, unwrapLView, unwrapRNode, updateAncestorTraversalFlagsOnAttach, viewAttachedToChangeDetector, viewAttachedToContainer, walkProviderTree, walkUpViews, wasLastNodeCreated, ɵunwrapWritableSignal, ɵɵdefineInjectable, ɵɵdefineInjector, ɵɵdisableBindings, ɵɵenableBindings, ɵɵinject, ɵɵinvalidFactoryDep, ɵɵnamespaceHTML, ɵɵnamespaceMathML, ɵɵnamespaceSVG, ɵɵresetView, ɵɵrestoreView };\n\n","export { audit } from '../internal/operators/audit';\nexport { auditTime } from '../internal/operators/auditTime';\nexport { buffer } from '../internal/operators/buffer';\nexport { bufferCount } from '../internal/operators/bufferCount';\nexport { bufferTime } from '../internal/operators/bufferTime';\nexport { bufferToggle } from '../internal/operators/bufferToggle';\nexport { bufferWhen } from '../internal/operators/bufferWhen';\nexport { catchError } from '../internal/operators/catchError';\nexport { combineAll } from '../internal/operators/combineAll';\nexport { combineLatestAll } from '../internal/operators/combineLatestAll';\nexport { combineLatest } from '../internal/operators/combineLatest';\nexport { combineLatestWith } from '../internal/operators/combineLatestWith';\nexport { concat } from '../internal/operators/concat';\nexport { concatAll } from '../internal/operators/concatAll';\nexport { concatMap } from '../internal/operators/concatMap';\nexport { concatMapTo } from '../internal/operators/concatMapTo';\nexport { concatWith } from '../internal/operators/concatWith';\nexport { connect } from '../internal/operators/connect';\nexport { count } from '../internal/operators/count';\nexport { debounce } from '../internal/operators/debounce';\nexport { debounceTime } from '../internal/operators/debounceTime';\nexport { defaultIfEmpty } from '../internal/operators/defaultIfEmpty';\nexport { delay } from '../internal/operators/delay';\nexport { delayWhen } from '../internal/operators/delayWhen';\nexport { dematerialize } from '../internal/operators/dematerialize';\nexport { distinct } from '../internal/operators/distinct';\nexport { distinctUntilChanged } from '../internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from '../internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from '../internal/operators/elementAt';\nexport { endWith } from '../internal/operators/endWith';\nexport { every } from '../internal/operators/every';\nexport { exhaust } from '../internal/operators/exhaust';\nexport { exhaustAll } from '../internal/operators/exhaustAll';\nexport { exhaustMap } from '../internal/operators/exhaustMap';\nexport { expand } from '../internal/operators/expand';\nexport { filter } from '../internal/operators/filter';\nexport { finalize } from '../internal/operators/finalize';\nexport { find } from '../internal/operators/find';\nexport { findIndex } from '../internal/operators/findIndex';\nexport { first } from '../internal/operators/first';\nexport { groupBy } from '../internal/operators/groupBy';\nexport { ignoreElements } from '../internal/operators/ignoreElements';\nexport { isEmpty } from '../internal/operators/isEmpty';\nexport { last } from '../internal/operators/last';\nexport { map } from '../internal/operators/map';\nexport { mapTo } from '../internal/operators/mapTo';\nexport { materialize } from '../internal/operators/materialize';\nexport { max } from '../internal/operators/max';\nexport { merge } from '../internal/operators/merge';\nexport { mergeAll } from '../internal/operators/mergeAll';\nexport { flatMap } from '../internal/operators/flatMap';\nexport { mergeMap } from '../internal/operators/mergeMap';\nexport { mergeMapTo } from '../internal/operators/mergeMapTo';\nexport { mergeScan } from '../internal/operators/mergeScan';\nexport { mergeWith } from '../internal/operators/mergeWith';\nexport { min } from '../internal/operators/min';\nexport { multicast } from '../internal/operators/multicast';\nexport { observeOn } from '../internal/operators/observeOn';\nexport { onErrorResumeNext } from '../internal/operators/onErrorResumeNextWith';\nexport { pairwise } from '../internal/operators/pairwise';\nexport { partition } from '../internal/operators/partition';\nexport { pluck } from '../internal/operators/pluck';\nexport { publish } from '../internal/operators/publish';\nexport { publishBehavior } from '../internal/operators/publishBehavior';\nexport { publishLast } from '../internal/operators/publishLast';\nexport { publishReplay } from '../internal/operators/publishReplay';\nexport { race } from '../internal/operators/race';\nexport { raceWith } from '../internal/operators/raceWith';\nexport { reduce } from '../internal/operators/reduce';\nexport { repeat } from '../internal/operators/repeat';\nexport { repeatWhen } from '../internal/operators/repeatWhen';\nexport { retry } from '../internal/operators/retry';\nexport { retryWhen } from '../internal/operators/retryWhen';\nexport { refCount } from '../internal/operators/refCount';\nexport { sample } from '../internal/operators/sample';\nexport { sampleTime } from '../internal/operators/sampleTime';\nexport { scan } from '../internal/operators/scan';\nexport { sequenceEqual } from '../internal/operators/sequenceEqual';\nexport { share } from '../internal/operators/share';\nexport { shareReplay } from '../internal/operators/shareReplay';\nexport { single } from '../internal/operators/single';\nexport { skip } from '../internal/operators/skip';\nexport { skipLast } from '../internal/operators/skipLast';\nexport { skipUntil } from '../internal/operators/skipUntil';\nexport { skipWhile } from '../internal/operators/skipWhile';\nexport { startWith } from '../internal/operators/startWith';\nexport { subscribeOn } from '../internal/operators/subscribeOn';\nexport { switchAll } from '../internal/operators/switchAll';\nexport { switchMap } from '../internal/operators/switchMap';\nexport { switchMapTo } from '../internal/operators/switchMapTo';\nexport { switchScan } from '../internal/operators/switchScan';\nexport { take } from '../internal/operators/take';\nexport { takeLast } from '../internal/operators/takeLast';\nexport { takeUntil } from '../internal/operators/takeUntil';\nexport { takeWhile } from '../internal/operators/takeWhile';\nexport { tap } from '../internal/operators/tap';\nexport { throttle } from '../internal/operators/throttle';\nexport { throttleTime } from '../internal/operators/throttleTime';\nexport { throwIfEmpty } from '../internal/operators/throwIfEmpty';\nexport { timeInterval } from '../internal/operators/timeInterval';\nexport { timeout } from '../internal/operators/timeout';\nexport { timeoutWith } from '../internal/operators/timeoutWith';\nexport { timestamp } from '../internal/operators/timestamp';\nexport { toArray } from '../internal/operators/toArray';\nexport { window } from '../internal/operators/window';\nexport { windowCount } from '../internal/operators/windowCount';\nexport { windowTime } from '../internal/operators/windowTime';\nexport { windowToggle } from '../internal/operators/windowToggle';\nexport { windowWhen } from '../internal/operators/windowWhen';\nexport { withLatestFrom } from '../internal/operators/withLatestFrom';\nexport { zip } from '../internal/operators/zip';\nexport { zipAll } from '../internal/operators/zipAll';\nexport { zipWith } from '../internal/operators/zipWith';\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nconst Attribute = {\n    /**\n     * The jsaction attribute defines a mapping of a DOM event to a\n     * generic event (aka jsaction), to which the actual event handlers\n     * that implement the behavior of the application are bound. The\n     * value is a semicolon separated list of colon separated pairs of\n     * an optional DOM event name and a jsaction name. If the optional\n     * DOM event name is omitted, 'click' is assumed. The jsaction names\n     * are dot separated pairs of a namespace and a simple jsaction\n     * name.\n     *\n     * See grammar in README.md for expected syntax in the attribute value.\n     */\n    JSACTION: 'jsaction',\n};\n\nexport { Attribute };\n\n","/**\n * @license Angular v20.1.6\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { attachInjectFlag, _global, ɵɵdefineInjectable as __defineInjectable, ɵɵdefineInjector as __defineInjector, ɵɵinject as __inject, ɵɵinvalidFactoryDep as __invalidFactoryDep, resolveForwardRef, newArray, EMPTY_OBJ, assertString, assertNotEqual, FLAGS, assertEqual, isInCheckNoChangesMode, PREORDER_HOOK_FLAGS, assertFirstCreatePass, assertDefined, throwError, assertNumber, assertGreaterThan, HEADER_OFFSET, DECLARATION_VIEW, NG_FACTORY_DEF, isForwardRef, getFactoryDef, assertIndexInRange, assertTNodeForLView, enterDI, runInInjectorProfilerContext, getCurrentTNode, getLView, emitInjectorToCreateInstanceEvent, emitInstanceCreatedByInjectorEvent, throwProviderNotFoundError, leaveDI, assertNodeInjector, stringifyForError, cyclicDependencyErrorWithDetails, cyclicDependencyError, setInjectorProfilerContext, setInjectImplementation, assertDirectiveDef, NG_ELEMENT_ID, convertToBitFlags, isRootView, T_HOST, TVIEW, injectRootLimpMode, isComponentDef, EMBEDDED_VIEW_INJECTOR, INJECTOR$1 as INJECTOR, DECLARATION_COMPONENT_VIEW, isComponentHost, RuntimeError, NG_PROV_DEF, getClosureSafeProperty, getNativeByTNode, flatten, arrayEquals, ID, isLView, assertDomNode, unwrapRNode, getComponentLViewByIndex, CONTEXT, EMPTY_ARRAY, assertLView, HOST, CHILD_HEAD, NEXT, isLContainer, getLViewParent, Injector, CLEANUP, getComponentDef, getDirectiveDef, InjectionToken, inject, isInSkipHydrationBlock as isInSkipHydrationBlock$1, HYDRATION, isContentQueryHost, setCurrentQueryIndex, XSS_SECURITY_URL, renderStringify, ENVIRONMENT, makeEnvironmentProviders, isDirectiveHost, formatRuntimeError, resetPreOrderHookFlags, PARENT, RENDERER, CHILD_TAIL, assertSame, assertFirstUpdatePass, getSelectedIndex, getTView, assertIndexInDeclRange, setSelectedIndex, assertLContainer, MOVED_VIEWS, isDestroyed, REACTIVE_TEMPLATE_CONSUMER, DECLARATION_LCONTAINER, QUERIES, assertNotReactive, ON_DESTROY_HOOKS, assertFunction, EFFECTS, assertProjectionSlots, NATIVE, assertParentView, CONTAINER_HEADER_OFFSET, assertNotSame, setCurrentDirectiveIndex, setCurrentTNode, getElementDepthCount, increaseElementDepthCount, wasLastNodeCreated, isCurrentTNodeParent, setCurrentTNodeAsNotParent, assertHasParent, INTERNAL_APPLICATION_ERROR_HANDLER, stringify, getCurrentDirectiveIndex, unwrapLView, isCreationMode, enterView, leaveView, AFTER_RENDER_SEQUENCES_TO_ADD, markAncestorsForTraversal, markViewForRefresh, setIsRefreshingViews, isExhaustiveCheckNoChanges, requiresRefreshOrTraversal, setIsInCheckNoChangesMode, CheckNoChangesMode, setBindingIndex, EFFECTS_TO_SCHEDULE, viewAttachedToChangeDetector, setBindingRootForHostBindings, isRefreshingViews, removeFromArray, addToArray, updateAncestorTraversalFlagsOnAttach, storeLViewOnDestroy, VIEW_REFS, assertGreaterThanOrEqual, isInI18nBlock, assertTNodeForTView, getCurrentParentTNode, getCurrentTNodePlaceholderOk, assertTNode, assertTIcu, assertNumberInRange, DEHYDRATED_VIEWS, getNgModuleDef, getPipeDef as getPipeDef$1, getNgModuleDefOrThrow, isStandalone, concatStringsWithSpace, assertInjectImplementationNotEqual, emitInjectEvent, getConstant, assertLessThan, getOrCreateTViewCleanup, getOrCreateLViewCleanup, assertNotDefined, nextBindingIndex, getSelectedTNode, getDirectiveDefOrThrow, getTNode, assertComponentType, debugStringifyTypeForError, ChangeDetectionScheduler, EnvironmentInjector, SVG_NAMESPACE, MATH_ML_NAMESPACE, viewAttachedToContainer, storeCleanupWithContext, signal, createInjectorWithoutInjectorInstances, R3Injector, getNullInjector, internalImportProvidersFrom, initNgDevMode, fillProperties, getBindingsEnabled, lastNodeWasCreated, isInInjectionContext, DestroyRef, PendingTasksInternal, noop, ErrorHandler, assertNotInReactiveContext, assertInInjectionContext, ViewContext, removeLViewOnDestroy, walkUpViews, getNativeByIndex, assertElement, arrayInsert2, arraySplice, setInjectorProfiler, NullInjector, ENVIRONMENT_INITIALIZER, INJECTOR_DEF_TYPES, walkProviderTree, getInjectorDef, deepForEach, isTypeProvider, isSignal, runInInjectionContext, ZONELESS_ENABLED, EffectScheduler, PendingTasks, assertTNodeCreationIndex, isSkipHydrationRootTNode, leaveSkipHydrationBlock, decreaseElementDepthCount, getNamespace, enterSkipHydrationBlock, getCurrentDirectiveDef, assertIndexInExpandoRange, getBindingIndex, assertOneOf, setInI18nBlock, nextContextImpl, getCurrentQueryIndex, getContextLView, load, keyValueArrayIndexOf, keyValueArraySet, keyValueArrayGet, incrementBindingIndex, isWritableSignal, store, providerToFactory, emitProviderConfiguredEvent, isClassProvider, getBindingRoot, NG_COMP_DEF, ɵɵresetView as __resetView, ɵɵnamespaceHTML as __namespaceHTML, ɵɵnamespaceMathML as __namespaceMathML, ɵɵnamespaceSVG as __namespaceSVG, ɵɵenableBindings as __enableBindings, ɵɵdisableBindings as __disableBindings, ɵɵrestoreView as __restoreView, forwardRef, NG_MOD_DEF, NG_INJ_DEF, NG_DIR_DEF, NG_PIPE_DEF, ZONELESS_SCHEDULER_DISABLED, SCHEDULE_IN_ROOT_ZONE, PROVIDED_ZONELESS, getNativeByTNodeOrNull } from './root_effect_scheduler.mjs';\nimport { setActiveConsumer, SIGNAL, consumerDestroy, REACTIVE_NODE, consumerPollProducersForChange, consumerBeforeComputation, getActiveConsumer, consumerAfterComputation, createComputed, setThrowInvalidWriteToSignalError } from './signal.mjs';\nimport { Subject, Subscription } from 'rxjs';\nimport { setActiveConsumer as setActiveConsumer$1 } from '@angular/core/primitives/signals';\nimport { map } from 'rxjs/operators';\nimport { Attribute as Attribute$1 } from './attribute.mjs';\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nfunction noSideEffects(fn) {\n    return { toString: fn }.toString();\n}\n\nconst ANNOTATIONS = '__annotations__';\nconst PARAMETERS = '__parameters__';\nconst PROP_METADATA = '__prop__metadata__';\n/**\n * @suppress {globalThis}\n */\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function DecoratorFactory(...args) {\n            if (this instanceof DecoratorFactory) {\n                metaCtor.call(this, ...args);\n                return this;\n            }\n            const annotationInstance = new DecoratorFactory(...args);\n            return function TypeDecorator(cls) {\n                if (typeFn)\n                    typeFn(cls, ...args);\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const annotations = cls.hasOwnProperty(ANNOTATIONS)\n                    ? cls[ANNOTATIONS]\n                    : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];\n                annotations.push(annotationInstance);\n                return cls;\n            };\n        }\n        if (parentClass) {\n            DecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        DecoratorFactory.prototype.ngMetadataName = name;\n        DecoratorFactory.annotationCls = DecoratorFactory;\n        return DecoratorFactory;\n    });\n}\nfunction makeMetadataCtor(props) {\n    return function ctor(...args) {\n        if (props) {\n            const values = props(...args);\n            for (const propName in values) {\n                this[propName] = values[propName];\n            }\n        }\n    };\n}\nfunction makeParamDecorator(name, props, parentClass) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function ParamDecoratorFactory(...args) {\n            if (this instanceof ParamDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const annotationInstance = new ParamDecoratorFactory(...args);\n            ParamDecorator.annotation = annotationInstance;\n            return ParamDecorator;\n            function ParamDecorator(cls, unusedKey, index) {\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const parameters = cls.hasOwnProperty(PARAMETERS)\n                    ? cls[PARAMETERS]\n                    : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];\n                // there might be gaps if some in between parameters do not have annotations.\n                // we pad with nulls.\n                while (parameters.length <= index) {\n                    parameters.push(null);\n                }\n                (parameters[index] = parameters[index] || []).push(annotationInstance);\n                return cls;\n            }\n        }\n        ParamDecoratorFactory.prototype.ngMetadataName = name;\n        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n        return ParamDecoratorFactory;\n    });\n}\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function PropDecoratorFactory(...args) {\n            if (this instanceof PropDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const decoratorInstance = new PropDecoratorFactory(...args);\n            function PropDecorator(target, name) {\n                // target is undefined with standard decorators. This case is not supported and will throw\n                // if this decorator is used in JIT mode with standard decorators.\n                if (target === undefined) {\n                    throw new Error('Standard Angular field decorators are not supported in JIT mode.');\n                }\n                const constructor = target.constructor;\n                // Use of Object.defineProperty is important because it creates a non-enumerable property\n                // which prevents the property from being copied during subclassing.\n                const meta = constructor.hasOwnProperty(PROP_METADATA)\n                    ? constructor[PROP_METADATA]\n                    : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];\n                meta[name] = (meta.hasOwnProperty(name) && meta[name]) || [];\n                meta[name].unshift(decoratorInstance);\n            }\n            return PropDecorator;\n        }\n        if (parentClass) {\n            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        PropDecoratorFactory.prototype.ngMetadataName = name;\n        PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n        return PropDecoratorFactory;\n    });\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Inject = attachInjectFlag(\n// Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\nmakeParamDecorator('Inject', (token) => ({ token })), -1 /* DecoratorFlags.Inject */);\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Optional = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Optional'), 8 /* InternalInjectFlags.Optional */);\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Self = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Self'), 2 /* InternalInjectFlags.Self */);\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst SkipSelf = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('SkipSelf'), 4 /* InternalInjectFlags.SkipSelf */);\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Host = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Host'), 1 /* InternalInjectFlags.Host */);\n\nfunction getCompilerFacade(request) {\n    const globalNg = _global['ng'];\n    if (globalNg && globalNg.ɵcompilerFacade) {\n        return globalNg.ɵcompilerFacade;\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Log the type as an error so that a developer can easily navigate to the type from the\n        // console.\n        console.error(`JIT compilation failed for ${request.kind}`, request.type);\n        let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\\n\\n`;\n        if (request.usage === 1 /* JitCompilerUsage.PartialDeclaration */) {\n            message += `The ${request.kind} is part of a library that has been partially compiled.\\n`;\n            message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\\n`;\n            message += '\\n';\n            message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\\n`;\n        }\n        else {\n            message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\\n`;\n        }\n        message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\\n`;\n        message += `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n        throw new Error(message);\n    }\n    else {\n        throw new Error('JIT compiler unavailable');\n    }\n}\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreDiEnv = {\n    'ɵɵdefineInjectable': __defineInjectable,\n    'ɵɵdefineInjector': __defineInjector,\n    'ɵɵinject': __inject,\n    'ɵɵinvalidFactoryDep': __invalidFactoryDep,\n    'resolveForwardRef': resolveForwardRef,\n};\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nconst Type = Function;\nfunction isType(v) {\n    return typeof v === 'function';\n}\n\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```ts\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```ts\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```ts\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nconst ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nconst ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nconst ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nconst ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nfunction isDelegateCtor(typeStr) {\n    return (ES5_DELEGATE_CTOR.test(typeStr) ||\n        ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n        (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr)));\n}\nclass ReflectionCapabilities {\n    _reflect;\n    constructor(reflect) {\n        this._reflect = reflect || _global['Reflect'];\n    }\n    factory(t) {\n        return (...args) => new t(...args);\n    }\n    /** @internal */\n    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n        let result;\n        if (typeof paramTypes === 'undefined') {\n            result = newArray(paramAnnotations.length);\n        }\n        else {\n            result = newArray(paramTypes.length);\n        }\n        for (let i = 0; i < result.length; i++) {\n            // TS outputs Object for parameters without types, while Traceur omits\n            // the annotations. For now we preserve the Traceur behavior to aid\n            // migration, but this can be revisited.\n            if (typeof paramTypes === 'undefined') {\n                result[i] = [];\n            }\n            else if (paramTypes[i] && paramTypes[i] != Object) {\n                result[i] = [paramTypes[i]];\n            }\n            else {\n                result[i] = [];\n            }\n            if (paramAnnotations && paramAnnotations[i] != null) {\n                result[i] = result[i].concat(paramAnnotations[i]);\n            }\n        }\n        return result;\n    }\n    _ownParameters(type, parentCtor) {\n        const typeStr = type.toString();\n        // If we have no decorators, we only have function.length as metadata.\n        // In that case, to detect whether a child class declared an own constructor or not,\n        // we need to look inside of that constructor to check whether it is\n        // just calling the parent.\n        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n        // that sets 'design:paramtypes' to []\n        // if a class inherits from another class but has no ctor declared itself.\n        if (isDelegateCtor(typeStr)) {\n            return null;\n        }\n        // Prefer the direct API.\n        if (type.parameters && type.parameters !== parentCtor.parameters) {\n            return type.parameters;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        const tsickleCtorParams = type.ctorParameters;\n        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n            // Newer tsickle uses a function closure\n            // Retain the non-function case for compatibility with older tsickle\n            const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n            const paramTypes = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);\n            const paramAnnotations = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // API for metadata created by invoking the decorators.\n        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n        const paramTypes = this._reflect &&\n            this._reflect.getOwnMetadata &&\n            this._reflect.getOwnMetadata('design:paramtypes', type);\n        if (paramTypes || paramAnnotations) {\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // If a class has no decorators, at least create metadata\n        // based on function.length.\n        // Note: We know that this is a real constructor as we checked\n        // the content of the constructor above.\n        return newArray(type.length);\n    }\n    parameters(type) {\n        // Note: only report metadata if we have at least one class decorator\n        // to stay in sync with the static reflector.\n        if (!isType(type)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(type);\n        let parameters = this._ownParameters(type, parentCtor);\n        if (!parameters && parentCtor !== Object) {\n            parameters = this.parameters(parentCtor);\n        }\n        return parameters || [];\n    }\n    _ownAnnotations(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n            let annotations = typeOrFunc.annotations;\n            if (typeof annotations === 'function' && annotations.annotations) {\n                annotations = annotations.annotations;\n            }\n            return annotations;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n            return typeOrFunc[ANNOTATIONS];\n        }\n        return null;\n    }\n    annotations(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n        return parentAnnotations.concat(ownAnnotations);\n    }\n    _ownPropMetadata(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.propMetadata &&\n            typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n            let propMetadata = typeOrFunc.propMetadata;\n            if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n                propMetadata = propMetadata.propMetadata;\n            }\n            return propMetadata;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.propDecorators &&\n            typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n            const propDecorators = typeOrFunc.propDecorators;\n            const propMetadata = {};\n            Object.keys(propDecorators).forEach((prop) => {\n                propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n            });\n            return propMetadata;\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n            return typeOrFunc[PROP_METADATA];\n        }\n        return null;\n    }\n    propMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const propMetadata = {};\n        if (parentCtor !== Object) {\n            const parentPropMetadata = this.propMetadata(parentCtor);\n            Object.keys(parentPropMetadata).forEach((propName) => {\n                propMetadata[propName] = parentPropMetadata[propName];\n            });\n        }\n        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n        if (ownPropMetadata) {\n            Object.keys(ownPropMetadata).forEach((propName) => {\n                const decorators = [];\n                if (propMetadata.hasOwnProperty(propName)) {\n                    decorators.push(...propMetadata[propName]);\n                }\n                decorators.push(...ownPropMetadata[propName]);\n                propMetadata[propName] = decorators;\n            });\n        }\n        return propMetadata;\n    }\n    ownPropMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n    }\n    hasLifecycleHook(type, lcProperty) {\n        return type instanceof Type && lcProperty in type.prototype;\n    }\n}\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n    if (!decoratorInvocations) {\n        return [];\n    }\n    return decoratorInvocations.map((decoratorInvocation) => {\n        const decoratorType = decoratorInvocation.type;\n        const annotationCls = decoratorType.annotationCls;\n        const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n        return new annotationCls(...annotationArgs);\n    });\n}\nfunction getParentCtor(ctor) {\n    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n    const parentCtor = parentProto ? parentProto.constructor : null;\n    // Note: We always use `Object` as the null value\n    // to simplify checking later on.\n    return parentCtor || Object;\n}\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see {@link OnChanges}\n *\n * @publicApi\n */\nclass SimpleChange {\n    previousValue;\n    currentValue;\n    firstChange;\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n    /**\n     * Check whether the new value is the first value assigned.\n     */\n    isFirstChange() {\n        return this.firstChange;\n    }\n}\n\nfunction applyValueToInputField(instance, inputSignalNode, privateName, value) {\n    if (inputSignalNode !== null) {\n        inputSignalNode.applyValueToInputSignal(inputSignalNode, value);\n    }\n    else {\n        instance[privateName] = value;\n    }\n}\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```ts\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nconst ɵɵNgOnChangesFeature = /* @__PURE__ */ (() => {\n    const ɵɵNgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;\n    // This option ensures that the ngOnChanges lifecycle hook will be inherited\n    // from superclasses (in InheritDefinitionFeature).\n    /** @nocollapse */\n    ɵɵNgOnChangesFeatureImpl.ngInherit = true;\n    return ɵɵNgOnChangesFeatureImpl;\n})();\nfunction NgOnChangesFeatureImpl(definition) {\n    if (definition.type.prototype.ngOnChanges) {\n        definition.setInput = ngOnChangesSetInput;\n    }\n    return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n    const simpleChangesStore = getSimpleChangesStore(this);\n    const current = simpleChangesStore?.current;\n    if (current) {\n        const previous = simpleChangesStore.previous;\n        if (previous === EMPTY_OBJ) {\n            simpleChangesStore.previous = current;\n        }\n        else {\n            // New changes are copied to the previous store, so that we don't lose history for inputs\n            // which were not changed this time\n            for (let key in current) {\n                previous[key] = current[key];\n            }\n        }\n        simpleChangesStore.current = null;\n        this.ngOnChanges(current);\n    }\n}\nfunction ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {\n    const declaredName = this.declaredInputs[publicName];\n    ngDevMode && assertString(declaredName, 'Name of input in ngOnChanges has to be a string');\n    const simpleChangesStore = getSimpleChangesStore(instance) ||\n        setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });\n    const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n    const previous = simpleChangesStore.previous;\n    const previousChange = previous[declaredName];\n    current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n    applyValueToInputField(instance, inputSignalNode, privateName, value);\n}\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\nfunction getSimpleChangesStore(instance) {\n    return instance[SIMPLE_CHANGES_STORE] || null;\n}\nfunction setSimpleChangesStore(instance, store) {\n    return (instance[SIMPLE_CHANGES_STORE] = store);\n}\n\nconst profilerCallbacks = [];\nconst NOOP_PROFILER_REMOVAL = () => { };\nfunction removeProfiler(profiler) {\n    const profilerIdx = profilerCallbacks.indexOf(profiler);\n    if (profilerIdx !== -1) {\n        profilerCallbacks.splice(profilerIdx, 1);\n    }\n}\n/**\n * Adds a callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection). Multiple profiler callbacks can be set:\n * in this case profiling events are reported to every registered callback.\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable all profilers.\n * @returns a cleanup function that, when invoked, removes a given profiler callback.\n */\nfunction setProfiler(profiler) {\n    if (profiler !== null) {\n        if (!profilerCallbacks.includes(profiler)) {\n            profilerCallbacks.push(profiler);\n        }\n        return () => removeProfiler(profiler);\n    }\n    else {\n        profilerCallbacks.length = 0;\n        return NOOP_PROFILER_REMOVAL;\n    }\n}\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param eventFn function associated with event.\n *    For example a template function, lifecycle hook, or output listener.\n *    The value depends on the execution context\n */\nconst profiler = function (event, instance = null, eventFn) {\n    for (let i = 0; i < profilerCallbacks.length; i++) {\n        const profilerCallback = profilerCallbacks[i];\n        profilerCallback(event, instance, eventFn);\n    }\n};\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;\n    if (ngOnChanges) {\n        const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n        (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);\n        (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);\n    }\n    if (ngOnInit) {\n        (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);\n    }\n    if (ngDoCheck) {\n        (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);\n        (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);\n    }\n}\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nfunction registerPostOrderHooks(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    // It's necessary to loop through the directives at elementEnd() (rather than processing in\n    // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n    // hooks for projected components and directives must be called *before* their hosts.\n    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n        const directiveDef = tView.data[i];\n        ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n        const lifecycleHooks = directiveDef.type.prototype;\n        const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy, } = lifecycleHooks;\n        if (ngAfterContentInit) {\n            (tView.contentHooks ??= []).push(-i, ngAfterContentInit);\n        }\n        if (ngAfterContentChecked) {\n            (tView.contentHooks ??= []).push(i, ngAfterContentChecked);\n            (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);\n        }\n        if (ngAfterViewInit) {\n            (tView.viewHooks ??= []).push(-i, ngAfterViewInit);\n        }\n        if (ngAfterViewChecked) {\n            (tView.viewHooks ??= []).push(i, ngAfterViewChecked);\n            (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);\n        }\n        if (ngOnDestroy != null) {\n            (tView.destroyHooks ??= []).push(i, ngOnDestroy);\n        }\n    }\n}\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n    callHooks(lView, hooks, 3 /* InitPhaseState.InitPhaseCompleted */, nodeIndex);\n}\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init pre-order hooks should not be called more than once');\n    if ((lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        callHooks(lView, hooks, initPhase, nodeIndex);\n    }\n}\nfunction incrementInitPhaseFlags(lView, initPhase) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init hooks phase should not be incremented after all init hooks have been run.');\n    let flags = lView[FLAGS];\n    if ((flags & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        flags &= 16383 /* LViewFlags.IndexWithinInitPhaseReset */;\n        flags += 1 /* LViewFlags.InitPhaseStateIncrementer */;\n        lView[FLAGS] = flags;\n    }\n}\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n    ngDevMode &&\n        assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');\n    const startIndex = currentNodeIndex !== undefined\n        ? currentView[PREORDER_HOOK_FLAGS] & 65535 /* PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask */\n        : 0;\n    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n    const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1\n    let lastNodeIndexFound = 0;\n    for (let i = startIndex; i < max; i++) {\n        const hook = arr[i + 1];\n        if (typeof hook === 'number') {\n            lastNodeIndexFound = arr[i];\n            if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n                break;\n            }\n        }\n        else {\n            const isInitHook = arr[i] < 0;\n            if (isInitHook) {\n                currentView[PREORDER_HOOK_FLAGS] += 65536 /* PreOrderHookFlags.NumberOfInitHooksCalledIncrementer */;\n            }\n            if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n                callHook(currentView, initPhase, arr, i);\n                currentView[PREORDER_HOOK_FLAGS] =\n                    (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* PreOrderHookFlags.NumberOfInitHooksCalledMask */) +\n                        i +\n                        2;\n            }\n            i++;\n        }\n    }\n}\n/**\n * Executes a single lifecycle hook, making sure that:\n * - it is called in the non-reactive context;\n * - profiling data are registered.\n */\nfunction callHookInternal(directive, hook) {\n    profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n    const prevConsumer = setActiveConsumer(null);\n    try {\n        hook.call(directive);\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n        profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n    }\n}\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView, initPhase, arr, i) {\n    const isInitHook = arr[i] < 0;\n    const hook = arr[i + 1];\n    const directiveIndex = isInitHook ? -arr[i] : arr[i];\n    const directive = currentView[directiveIndex];\n    if (isInitHook) {\n        const indexWithintInitPhase = currentView[FLAGS] >> 14 /* LViewFlags.IndexWithinInitPhaseShift */;\n        // The init phase state must be always checked here as it may have been recursively updated.\n        if (indexWithintInitPhase <\n            currentView[PREORDER_HOOK_FLAGS] >> 16 /* PreOrderHookFlags.NumberOfInitHooksCalledShift */ &&\n            (currentView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n            currentView[FLAGS] += 16384 /* LViewFlags.IndexWithinInitPhaseIncrementer */;\n            callHookInternal(directive, hook);\n        }\n    }\n    else {\n        callHookInternal(directive, hook);\n    }\n}\n\nconst NO_PARENT_INJECTOR = -1;\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\nclass NodeInjectorFactory {\n    factory;\n    name;\n    /**\n     * The inject implementation to be activated when using the factory.\n     */\n    injectImpl;\n    /**\n     * Marker set to true during factory invocation to see if we get into recursive loop.\n     * Recursive loop causes an error to be displayed.\n     */\n    resolving = false;\n    /**\n     * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n     */\n    canSeeViewProviders;\n    /**\n     * An array of factories to use in case of `multi` provider.\n     */\n    multi;\n    /**\n     * Number of `multi`-providers which belong to the component.\n     *\n     * This is needed because when multiple components and directives declare the `multi` provider\n     * they have to be concatenated in the correct order.\n     *\n     * Example:\n     *\n     * If we have a component and directive active an a single element as declared here\n     * ```ts\n     * component:\n     *   providers: [ {provide: String, useValue: 'component', multi: true} ],\n     *   viewProviders: [ {provide: String, useValue: 'componentView', multi: true} ],\n     *\n     * directive:\n     *   providers: [ {provide: String, useValue: 'directive', multi: true} ],\n     * ```\n     *\n     * Then the expected results are:\n     *\n     * ```ts\n     * providers: ['component', 'directive']\n     * viewProviders: ['component', 'componentView', 'directive']\n     * ```\n     *\n     * The way to think about it is that the `viewProviders` have been inserted after the component\n     * but before the directives, which is why we need to know how many `multi`s have been declared by\n     * the component.\n     */\n    componentProviders;\n    /**\n     * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n     * See `providerFactory`.\n     */\n    index;\n    /**\n     * Because the same `multi` provider can be declared in `providers` and `viewProviders` it is\n     * possible for `viewProviders` to shadow the `providers`. For this reason we store the\n     * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n     *\n     * Example:\n     *\n     * Given:\n     * ```ts\n     * providers: [ {provide: String, useValue: 'all', multi: true} ],\n     * viewProviders: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n     * ```\n     *\n     * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n     * of view injection. We further have to make sure that the shared instances (in our case\n     * `all`) are the exact same instance in both the content as well as the view injection. (We\n     * have to make sure that we don't double instantiate.) For this reason the `viewProviders`\n     * `Factory` has a pointer to the shadowed `providers` factory so that it can instantiate the\n     * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n     * ['all', 'viewOnly']`).\n     */\n    providerFactory;\n    constructor(\n    /**\n     * Factory to invoke in order to create a new instance.\n     */\n    factory, \n    /**\n     * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n     */\n    isViewProvider, injectImplementation, \n    // Expect `null` in devmode\n    name) {\n        this.factory = factory;\n        this.name = name;\n        ngDevMode && assertDefined(factory, 'Factory not specified');\n        ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n        this.canSeeViewProviders = isViewProvider;\n        this.injectImpl = injectImplementation;\n    }\n}\n\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\nfunction toTNodeTypeAsString(tNodeType) {\n    let text = '';\n    tNodeType & 1 /* TNodeType.Text */ && (text += '|Text');\n    tNodeType & 2 /* TNodeType.Element */ && (text += '|Element');\n    tNodeType & 4 /* TNodeType.Container */ && (text += '|Container');\n    tNodeType & 8 /* TNodeType.ElementContainer */ && (text += '|ElementContainer');\n    tNodeType & 16 /* TNodeType.Projection */ && (text += '|Projection');\n    tNodeType & 32 /* TNodeType.Icu */ && (text += '|IcuContainer');\n    tNodeType & 64 /* TNodeType.Placeholder */ && (text += '|Placeholder');\n    tNodeType & 128 /* TNodeType.LetDeclaration */ && (text += '|LetDeclaration');\n    return text.length > 0 ? text.substring(1) : text;\n}\n/**\n * Helper function to detect if a given value matches a `TNode` shape.\n *\n * The logic uses the `insertBeforeIndex` and its possible values as\n * a way to differentiate a TNode shape from other types of objects\n * within the `TView.data`. This is not a perfect check, but it can\n * be a reasonable differentiator, since we control the shapes of objects\n * within `TView.data`.\n */\nfunction isTNodeShape(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        (value.insertBeforeIndex === null ||\n            typeof value.insertBeforeIndex === 'number' ||\n            Array.isArray(value.insertBeforeIndex)));\n}\nfunction isLetDeclaration(tNode) {\n    return !!(tNode.type & 128 /* TNodeType.LetDeclaration */);\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```html\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```ts\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasClassInput(tNode) {\n    return (tNode.flags & 8 /* TNodeFlags.hasClassInput */) !== 0;\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```html\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```ts\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasStyleInput(tNode) {\n    return (tNode.flags & 16 /* TNodeFlags.hasStyleInput */) !== 0;\n}\n\nfunction assertTNodeType(tNode, expectedTypes, message) {\n    assertDefined(tNode, 'should be called with a TNode');\n    if ((tNode.type & expectedTypes) === 0) {\n        throwError(message ||\n            `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n    }\n}\nfunction assertPureTNodeType(type) {\n    if (!(type === 2 /* TNodeType.Element */ ||\n        type === 1 /* TNodeType.Text */ ||\n        type === 4 /* TNodeType.Container */ ||\n        type === 8 /* TNodeType.ElementContainer */ ||\n        type === 32 /* TNodeType.Icu */ ||\n        type === 16 /* TNodeType.Projection */ ||\n        type === 64 /* TNodeType.Placeholder */ ||\n        type === 128 /* TNodeType.LetDeclaration */)) {\n        throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n    }\n}\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nfunction setUpAttributes(renderer, native, attrs) {\n    let i = 0;\n    while (i < attrs.length) {\n        const value = attrs[i];\n        if (typeof value === 'number') {\n            // only namespaces are supported. Other value types (such as style/class\n            // entries) are not supported in this function.\n            if (value !== 0 /* AttributeMarker.NamespaceURI */) {\n                break;\n            }\n            // we just landed on the marker value ... therefore\n            // we should skip to the next entry\n            i++;\n            const namespaceURI = attrs[i++];\n            const attrName = attrs[i++];\n            const attrVal = attrs[i++];\n            renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n        }\n        else {\n            // attrName is string;\n            const attrName = value;\n            const attrVal = attrs[++i];\n            // Standard attributes\n            if (isAnimationProp(attrName)) {\n                renderer.setProperty(native, attrName, attrVal);\n            }\n            else {\n                renderer.setAttribute(native, attrName, attrVal);\n            }\n            i++;\n        }\n    }\n    // another piece of code may iterate over the same attributes array. Therefore\n    // it may be helpful to return the exact spot where the attributes array exited\n    // whether by running into an unsupported marker or if all the static values were\n    // iterated over.\n    return i;\n}\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nfunction isNameOnlyAttributeMarker(marker) {\n    return (marker === 3 /* AttributeMarker.Bindings */ ||\n        marker === 4 /* AttributeMarker.Template */ ||\n        marker === 6 /* AttributeMarker.I18n */);\n}\nfunction isAnimationProp(name) {\n    // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n    // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n    // charCodeAt doesn't allocate memory to return a substring.\n    return name.charCodeAt(0) === 64 /* CharCode.AT_SIGN */;\n}\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nfunction mergeHostAttrs(dst, src) {\n    if (src === null || src.length === 0) ;\n    else if (dst === null || dst.length === 0) {\n        // We have source, but dst is empty, just make a copy.\n        dst = src.slice();\n    }\n    else {\n        let srcMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n        for (let i = 0; i < src.length; i++) {\n            const item = src[i];\n            if (typeof item === 'number') {\n                srcMarker = item;\n            }\n            else {\n                if (srcMarker === 0 /* AttributeMarker.NamespaceURI */) ;\n                else if (srcMarker === -1 /* AttributeMarker.ImplicitAttributes */ ||\n                    srcMarker === 2 /* AttributeMarker.Styles */) {\n                    // Case where we have to consume `key1` and `value` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n                }\n                else {\n                    // Case where we have to consume `key1` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, null);\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n    let i = 0;\n    // Assume that new markers will be inserted at the end.\n    let markerInsertPosition = dst.length;\n    // scan until correct type.\n    if (marker === -1 /* AttributeMarker.ImplicitAttributes */) {\n        markerInsertPosition = -1;\n    }\n    else {\n        while (i < dst.length) {\n            const dstValue = dst[i++];\n            if (typeof dstValue === 'number') {\n                if (dstValue === marker) {\n                    markerInsertPosition = -1;\n                    break;\n                }\n                else if (dstValue > marker) {\n                    // We need to save this as we want the markers to be inserted in specific order.\n                    markerInsertPosition = i - 1;\n                    break;\n                }\n            }\n        }\n    }\n    // search until you find place of insertion\n    while (i < dst.length) {\n        const item = dst[i];\n        if (typeof item === 'number') {\n            // since `i` started as the index after the marker, we did not find it if we are at the next\n            // marker\n            break;\n        }\n        else if (item === key1) {\n            // We already have same token\n            {\n                if (value !== null) {\n                    dst[i + 1] = value;\n                }\n                return;\n            }\n        }\n        // Increment counter.\n        i++;\n        if (value !== null)\n            i++;\n    }\n    // insert at location.\n    if (markerInsertPosition !== -1) {\n        dst.splice(markerInsertPosition, 0, marker);\n        i = markerInsertPosition + 1;\n    }\n    dst.splice(i++, 0, key1);\n    if (value !== null) {\n        dst.splice(i++, 0, value);\n    }\n}\n\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nfunction hasParentInjector(parentLocation) {\n    return parentLocation !== NO_PARENT_INJECTOR;\n}\nfunction getParentInjectorIndex(parentLocation) {\n    if (ngDevMode) {\n        assertNumber(parentLocation, 'Number expected');\n        assertNotEqual(parentLocation, -1, 'Not a valid state.');\n        const parentInjectorIndex = parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n        assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');\n    }\n    return parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n}\nfunction getParentInjectorViewOffset(parentLocation) {\n    return parentLocation >> 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n}\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nfunction getParentInjectorView(location, startView) {\n    let viewOffset = getParentInjectorViewOffset(location);\n    let parentView = startView;\n    // For most cases, the parent injector can be found on the host node (e.g. for component\n    // or container), but we must keep the loop here to support the rarer case of deeply nested\n    // <ng-template> tags or inline views, where the parent injector might live many views\n    // above the child injector.\n    while (viewOffset > 0) {\n        parentView = parentView[DECLARATION_VIEW];\n        viewOffset--;\n    }\n    return parentView;\n}\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```ts\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\nfunction setIncludeViewProviders(v) {\n    const oldValue = includeViewProviders;\n    includeViewProviders = v;\n    return oldValue;\n}\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\nconst BLOOM_BUCKET_BITS = 5;\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n/** Value used when something wasn't found by an injector. */\nconst NOT_FOUND = {};\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nfunction bloomAdd(injectorIndex, tView, type) {\n    ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n    let id;\n    if (typeof type === 'string') {\n        id = type.charCodeAt(0) || 0;\n    }\n    else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n        id = type[NG_ELEMENT_ID];\n    }\n    // Set a unique ID on the directive type, so if something tries to inject the directive,\n    // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n    if (id == null) {\n        id = type[NG_ELEMENT_ID] = nextNgElementId++;\n    }\n    // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n    // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n    const bloomHash = id & BLOOM_MASK;\n    // Create a mask that targets the specific bit associated with the directive.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n    // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n    // should be written to.\n    tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n    const existingInjectorIndex = getInjectorIndex(tNode, lView);\n    if (existingInjectorIndex !== -1) {\n        return existingInjectorIndex;\n    }\n    const tView = lView[TVIEW];\n    if (tView.firstCreatePass) {\n        tNode.injectorIndex = lView.length;\n        insertBloom(tView.data, tNode); // foundation for node bloom\n        insertBloom(lView, null); // foundation for cumulative bloom\n        insertBloom(tView.blueprint, null);\n    }\n    const parentLoc = getParentInjectorLocation(tNode, lView);\n    const injectorIndex = tNode.injectorIndex;\n    // If a parent injector can't be found, its location is set to -1.\n    // In that case, we don't need to set up a cumulative bloom\n    if (hasParentInjector(parentLoc)) {\n        const parentIndex = getParentInjectorIndex(parentLoc);\n        const parentLView = getParentInjectorView(parentLoc, lView);\n        const parentData = parentLView[TVIEW].data;\n        // Creates a cumulative bloom filter that merges the parent's bloom filter\n        // and its own cumulative bloom (which contains tokens for all ancestors)\n        for (let i = 0; i < 8 /* NodeInjectorOffset.BLOOM_SIZE */; i++) {\n            lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n        }\n    }\n    lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */] = parentLoc;\n    return injectorIndex;\n}\nfunction insertBloom(arr, footer) {\n    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\nfunction getInjectorIndex(tNode, lView) {\n    if (tNode.injectorIndex === -1 ||\n        // If the injector index is the same as its parent's injector index, then the index has been\n        // copied down from the parent node. No injector has been created yet on this node.\n        (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n        // After the first template pass, the injector index might exist but the parent values\n        // might not have been calculated yet for this instance\n        lView[tNode.injectorIndex + 8 /* NodeInjectorOffset.PARENT */] === null) {\n        return -1;\n    }\n    else {\n        ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n        return tNode.injectorIndex;\n    }\n}\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nfunction getParentInjectorLocation(tNode, lView) {\n    if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n        // If we have a parent `TNode` and there is an injector associated with it we are done, because\n        // the parent injector is within the current `LView`.\n        return tNode.parent.injectorIndex; // ViewOffset is 0\n    }\n    // When parent injector location is computed it may be outside of the current view. (ie it could\n    // be pointing to a declared parent location). This variable stores number of declaration parents\n    // we need to walk up in order to find the parent injector location.\n    let declarationViewOffset = 0;\n    let parentTNode = null;\n    let lViewCursor = lView;\n    // The parent injector is not in the current `LView`. We will have to walk the declared parent\n    // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n    // `NodeInjector`.\n    while (lViewCursor !== null) {\n        parentTNode = getTNodeFromLView(lViewCursor);\n        if (parentTNode === null) {\n            // If we have no parent, than we are done.\n            return NO_PARENT_INJECTOR;\n        }\n        ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);\n        // Every iteration of the loop requires that we go to the declared parent.\n        declarationViewOffset++;\n        lViewCursor = lViewCursor[DECLARATION_VIEW];\n        if (parentTNode.injectorIndex !== -1) {\n            // We found a NodeInjector which points to something.\n            return (parentTNode.injectorIndex |\n                (declarationViewOffset <<\n                    16 /* RelativeInjectorLocationFlags.ViewOffsetShift */));\n        }\n    }\n    return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nfunction diPublicInInjector(injectorIndex, tView, token) {\n    bloomAdd(injectorIndex, tView, token);\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```ts\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```html\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```ts\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n    ngDevMode && assertTNodeType(tNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n    ngDevMode && assertDefined(tNode, 'expecting tNode');\n    if (attrNameToInject === 'class') {\n        return tNode.classes;\n    }\n    if (attrNameToInject === 'style') {\n        return tNode.styles;\n    }\n    const attrs = tNode.attrs;\n    if (attrs) {\n        const attrsLength = attrs.length;\n        let i = 0;\n        while (i < attrsLength) {\n            const value = attrs[i];\n            // If we hit a `Bindings` or `Template` marker then we are done.\n            if (isNameOnlyAttributeMarker(value))\n                break;\n            // Skip namespaced attributes\n            if (value === 0 /* AttributeMarker.NamespaceURI */) {\n                // we skip the next two values\n                // as namespaced attributes looks like\n                // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n                // 'existValue', ...]\n                i = i + 2;\n            }\n            else if (typeof value === 'number') {\n                // Skip to the first value of the marked attribute.\n                i++;\n                while (i < attrsLength && typeof attrs[i] === 'string') {\n                    i++;\n                }\n            }\n            else if (value === attrNameToInject) {\n                return attrs[i + 1];\n            }\n            else {\n                i = i + 2;\n            }\n        }\n    }\n    return null;\n}\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n    if (flags & 8 /* InternalInjectFlags.Optional */ || notFoundValue !== undefined) {\n        return notFoundValue;\n    }\n    else {\n        throwProviderNotFoundError(token, 'NodeInjector');\n    }\n}\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n    if (flags & 8 /* InternalInjectFlags.Optional */ && notFoundValue === undefined) {\n        // This must be set or the NullInjector will throw for optional deps\n        notFoundValue = null;\n    }\n    if ((flags & (2 /* InternalInjectFlags.Self */ | 1 /* InternalInjectFlags.Host */)) === 0) {\n        const moduleInjector = lView[INJECTOR];\n        // switch to `injectInjectorOnly` implementation for module injector, since module injector\n        // should not have access to Component/Directive DI scope (that may happen through\n        // `directiveInject` implementation)\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            if (moduleInjector) {\n                return moduleInjector.get(token, notFoundValue, flags & 8 /* InternalInjectFlags.Optional */);\n            }\n            else {\n                return injectRootLimpMode(token, notFoundValue, flags & 8 /* InternalInjectFlags.Optional */);\n            }\n        }\n        finally {\n            setInjectImplementation(previousInjectImplementation);\n        }\n    }\n    return notFoundValueOrThrow(notFoundValue, token, flags);\n}\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction getOrCreateInjectable(tNode, lView, token, flags = 0 /* InternalInjectFlags.Default */, notFoundValue) {\n    if (tNode !== null) {\n        // If the view or any of its ancestors have an embedded\n        // view injector, we have to look it up there first.\n        if (lView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */ &&\n            // The token must be present on the current node injector when the `Self`\n            // flag is set, so the lookup on embedded view injector(s) can be skipped.\n            !(flags & 2 /* InternalInjectFlags.Self */)) {\n            const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);\n            if (embeddedInjectorValue !== NOT_FOUND) {\n                return embeddedInjectorValue;\n            }\n        }\n        // Otherwise try the node injector.\n        const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n        if (value !== NOT_FOUND) {\n            return value;\n        }\n    }\n    // Finally, fall back to the module injector.\n    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n        if (!enterDI(lView, tNode, flags)) {\n            // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n            // flag, the module injector is not searched for that token in Ivy.\n            return flags & 1 /* InternalInjectFlags.Host */\n                ? notFoundValueOrThrow(notFoundValue, token, flags)\n                : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n        }\n        try {\n            let value;\n            if (ngDevMode) {\n                runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {\n                    emitInjectorToCreateInstanceEvent(token);\n                    value = bloomHash(flags);\n                    emitInstanceCreatedByInjectorEvent(value);\n                });\n            }\n            else {\n                value = bloomHash(flags);\n            }\n            if (value == null && !(flags & 8 /* InternalInjectFlags.Optional */)) {\n                throwProviderNotFoundError(token);\n            }\n            else {\n                return value;\n            }\n        }\n        finally {\n            leaveDI();\n        }\n    }\n    else if (typeof bloomHash === 'number') {\n        // A reference to the previous injector TView that was found while climbing the element\n        // injector tree. This is used to know if viewProviders can be accessed on the current\n        // injector.\n        let previousTView = null;\n        let injectorIndex = getInjectorIndex(tNode, lView);\n        let parentLocation = NO_PARENT_INJECTOR;\n        let hostTElementNode = flags & 1 /* InternalInjectFlags.Host */ ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n        // If we should skip this injector, or if there is no injector on this node, start by\n        // searching the parent injector.\n        if (injectorIndex === -1 || flags & 4 /* InternalInjectFlags.SkipSelf */) {\n            parentLocation =\n                injectorIndex === -1\n                    ? getParentInjectorLocation(tNode, lView)\n                    : lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n                injectorIndex = -1;\n            }\n            else {\n                previousTView = lView[TVIEW];\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n        }\n        // Traverse up the injector tree until we find a potential match or until we know there\n        // *isn't* a match.\n        while (injectorIndex !== -1) {\n            ngDevMode && assertNodeInjector(lView, injectorIndex);\n            // Check the current injector. If it matches, see if it contains token.\n            const tView = lView[TVIEW];\n            ngDevMode &&\n                assertTNodeForLView(tView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */], lView);\n            if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n                // At this point, we have an injector which *may* contain the token, so we step through\n                // the providers and directives associated with the injector's corresponding node to get\n                // the instance.\n                const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n                if (instance !== NOT_FOUND) {\n                    return instance;\n                }\n            }\n            parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation !== NO_PARENT_INJECTOR &&\n                shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */] === hostTElementNode) &&\n                bloomHasToken(bloomHash, injectorIndex, lView)) {\n                // The def wasn't found anywhere on this node, so it was a false positive.\n                // Traverse up the tree and continue searching.\n                previousTView = tView;\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n            else {\n                // If we should not search parent OR If the ancestor bloom filter value does not have the\n                // bit corresponding to the directive we can give up on traversing up to find the specific\n                // injector.\n                injectorIndex = -1;\n            }\n        }\n    }\n    return notFoundValue;\n}\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n    const currentTView = lView[TVIEW];\n    const tNode = currentTView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n    // First, we need to determine if view providers can be accessed by the starting element.\n    // There are two possibilities\n    const canAccessViewProviders = previousTView == null\n        ? // 1) This is the first invocation `previousTView == null` which means that we are at the\n            // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n            // to look into the ViewProviders is if:\n            // - we are on a component\n            // - AND the injector set `includeViewProviders` to true (implying that the token can see\n            // ViewProviders because it is the Component or a Service which itself was declared in\n            // ViewProviders)\n            isComponentHost(tNode) && includeViewProviders\n        : // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n            // In such a case we are only allowed to look into the ViewProviders if:\n            // - We just crossed from child View to Parent View `previousTView != currentTView`\n            // - AND the parent TNode is an Element.\n            // This means that we just came from the Component's View and therefore are allowed to see\n            // into the ViewProviders.\n            previousTView != currentTView && (tNode.type & 3 /* TNodeType.AnyRNode */) !== 0;\n    // This special case happens when there is a @host on the inject and when we are searching\n    // on the host element node.\n    const isHostSpecialCase = flags & 1 /* InternalInjectFlags.Host */ && hostTElementNode === tNode;\n    const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n    if (injectableIdx !== null) {\n        return getNodeInjectable(lView, currentTView, injectableIdx, tNode, flags);\n    }\n    else {\n        return NOT_FOUND;\n    }\n}\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n    const nodeProviderIndexes = tNode.providerIndexes;\n    const tInjectables = tView.data;\n    const injectablesStart = nodeProviderIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const directivesStart = tNode.directiveStart;\n    const directiveEnd = tNode.directiveEnd;\n    const cptViewProvidersCount = nodeProviderIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n    const startingIndex = canAccessViewProviders\n        ? injectablesStart\n        : injectablesStart + cptViewProvidersCount;\n    // When the host special case applies, only the viewProviders and the component are visible\n    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n    for (let i = startingIndex; i < endIndex; i++) {\n        const providerTokenOrDef = tInjectables[i];\n        if ((i < directivesStart && token === providerTokenOrDef) ||\n            (i >= directivesStart && providerTokenOrDef.type === token)) {\n            return i;\n        }\n    }\n    if (isHostSpecialCase) {\n        const dirDef = tInjectables[directivesStart];\n        if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n            return directivesStart;\n        }\n    }\n    return null;\n}\n/**\n * Used in ngDevMode to keep the injection path in case of cycles in DI.\n */\nlet injectionPath = [];\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nfunction getNodeInjectable(lView, tView, index, tNode, flags) {\n    let value = lView[index];\n    const tData = tView.data;\n    if (value instanceof NodeInjectorFactory) {\n        const factory = value;\n        ngDevMode && injectionPath.push(factory.name ?? 'unknown');\n        if (factory.resolving) {\n            const token = stringifyForError(tData[index]);\n            if (ngDevMode) {\n                throw cyclicDependencyErrorWithDetails(token, injectionPath);\n            }\n            else {\n                throw cyclicDependencyError(token);\n            }\n        }\n        const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n        factory.resolving = true;\n        // tData indexes mirror the concrete instances in its corresponding LView.\n        // lView[index] here is either the injectable instance itself or a factory,\n        // therefore tData[index] is the constructor of that injectable or a\n        // definition object that contains the constructor in a `.type` field.\n        const token = tData[index].type || tData[index];\n        let prevInjectContext;\n        if (ngDevMode) {\n            const injector = new NodeInjector(tNode, lView);\n            prevInjectContext = setInjectorProfilerContext({ injector, token });\n        }\n        const previousInjectImplementation = factory.injectImpl\n            ? setInjectImplementation(factory.injectImpl)\n            : null;\n        const success = enterDI(lView, tNode, 0 /* InternalInjectFlags.Default */);\n        ngDevMode &&\n            assertEqual(success, true, \"Because flags do not contain `SkipSelf' we expect this to always succeed.\");\n        try {\n            ngDevMode && emitInjectorToCreateInstanceEvent(token);\n            value = lView[index] = factory.factory(undefined, flags, tData, lView, tNode);\n            ngDevMode && emitInstanceCreatedByInjectorEvent(value);\n            // This code path is hit for both directives and providers.\n            // For perf reasons, we want to avoid searching for hooks on providers.\n            // It does no harm to try (the hooks just won't exist), but the extra\n            // checks are unnecessary and this is a hot path. So we check to see\n            // if the index of the dependency is in the directive range for this\n            // tNode. If it's not, we know it's a provider and skip hook registration.\n            if (tView.firstCreatePass && index >= tNode.directiveStart) {\n                ngDevMode && assertDirectiveDef(tData[index]);\n                registerPreOrderHooks(index, tData[index], tView);\n            }\n        }\n        finally {\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n            previousInjectImplementation !== null &&\n                setInjectImplementation(previousInjectImplementation);\n            setIncludeViewProviders(previousIncludeViewProviders);\n            factory.resolving = false;\n            leaveDI();\n            ngDevMode && (injectionPath = []);\n        }\n    }\n    return value;\n}\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nfunction bloomHashBitOrFactory(token) {\n    ngDevMode && assertDefined(token, 'token must be defined');\n    if (typeof token === 'string') {\n        return token.charCodeAt(0) || 0;\n    }\n    const tokenId = \n    // First check with `hasOwnProperty` so we don't get an inherited ID.\n    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;\n    // Negative token IDs are used for special objects such as `Injector`\n    if (typeof tokenId === 'number') {\n        if (tokenId >= 0) {\n            return tokenId & BLOOM_MASK;\n        }\n        else {\n            ngDevMode &&\n                assertEqual(tokenId, -1 /* InjectorMarkers.Injector */, 'Expecting to get Special Injector Id');\n            return createNodeInjector;\n        }\n    }\n    else {\n        return tokenId;\n    }\n}\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n    // Create a mask that targets the specific bit associated with the directive we're looking for.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n    // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n    // that should be used.\n    const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n    // this injector is a potential match.\n    return !!(value & mask);\n}\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n    return (!(flags & 2 /* InternalInjectFlags.Self */) && !(flags & 1 /* InternalInjectFlags.Host */ && isFirstHostTNode));\n}\nfunction getNodeInjectorLView(nodeInjector) {\n    return nodeInjector._lView;\n}\nfunction getNodeInjectorTNode(nodeInjector) {\n    return nodeInjector._tNode;\n}\nclass NodeInjector {\n    _tNode;\n    _lView;\n    constructor(_tNode, _lView) {\n        this._tNode = _tNode;\n        this._lView = _lView;\n    }\n    get(token, notFoundValue, flags) {\n        return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);\n    }\n}\n/** Creates a `NodeInjector` for the current node. */\nfunction createNodeInjector() {\n    return new NodeInjector(getCurrentTNode(), getLView());\n}\n/**\n * @codeGenApi\n */\nfunction ɵɵgetInheritedFactory(type) {\n    return noSideEffects(() => {\n        const ownConstructor = type.prototype.constructor;\n        const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n        const objectPrototype = Object.prototype;\n        let parent = Object.getPrototypeOf(type.prototype).constructor;\n        // Go up the prototype until we hit `Object`.\n        while (parent && parent !== objectPrototype) {\n            const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n            // If we hit something that has a factory and the factory isn't the same as the type,\n            // we've found the inherited factory. Note the check that the factory isn't the type's\n            // own factory is redundant in most cases, but if the user has custom decorators on the\n            // class, this lookup will start one level down in the prototype chain, causing us to\n            // find the own factory first and potentially triggering an infinite loop downstream.\n            if (factory && factory !== ownFactory) {\n                return factory;\n            }\n            parent = Object.getPrototypeOf(parent);\n        }\n        // There is no factory defined. Either this was improper usage of inheritance\n        // (no Angular decorator on the superclass) or there is no constructor at all\n        // in the inheritance chain. Since the two cases cannot be distinguished, the\n        // latter has to be assumed.\n        return (t) => new t();\n    });\n}\nfunction getFactoryOf(type) {\n    if (isForwardRef(type)) {\n        return () => {\n            const factory = getFactoryOf(resolveForwardRef(type));\n            return factory && factory();\n        };\n    }\n    return getFactoryDef(type);\n}\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InternalInjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n    let currentTNode = tNode;\n    let currentLView = lView;\n    // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n    // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n    // Since the bloom filters for the node injectors have already been constructed and we don't\n    // have a way of extracting the records from an injector, the only way to maintain the correct\n    // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n    // the token at each level.\n    while (currentTNode !== null &&\n        currentLView !== null &&\n        currentLView[FLAGS] & 2048 /* LViewFlags.HasEmbeddedViewInjector */ &&\n        !isRootView(currentLView)) {\n        ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n        // Note that this lookup on the node injector is using the `Self` flag, because\n        // we don't want the node injector to look at any parent injectors since we\n        // may hit the embedded view injector first.\n        const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | 2 /* InternalInjectFlags.Self */, NOT_FOUND);\n        if (nodeInjectorValue !== NOT_FOUND) {\n            return nodeInjectorValue;\n        }\n        // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n        let parentTNode = currentTNode.parent;\n        // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n        // it means that we've hit the view boundary and we need to go up to the next view.\n        if (!parentTNode) {\n            // Before we go to the next LView, check if the token exists on the current embedded injector.\n            const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n            if (embeddedViewInjector) {\n                const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);\n                if (embeddedViewInjectorValue !== NOT_FOUND) {\n                    return embeddedViewInjectorValue;\n                }\n            }\n            // Otherwise keep going up the tree.\n            parentTNode = getTNodeFromLView(currentLView);\n            currentLView = currentLView[DECLARATION_VIEW];\n        }\n        currentTNode = parentTNode;\n    }\n    return notFoundValue;\n}\n/** Gets the TNode associated with an LView inside of the declaration view. */\nfunction getTNodeFromLView(lView) {\n    const tView = lView[TVIEW];\n    const tViewType = tView.type;\n    // The parent pointer differs based on `TView.type`.\n    if (tViewType === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    else if (tViewType === 1 /* TViewType.Component */) {\n        // Components don't have `TView.declTNode` because each instance of component could be\n        // inserted in different location, hence `TView.declTNode` is meaningless.\n        return lView[T_HOST];\n    }\n    return null;\n}\n\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nfunction ɵɵinjectAttribute(attrNameToInject) {\n    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Attribute = makeParamDecorator('Attribute', (attributeName) => ({\n    attributeName,\n    __NG_ELEMENT_ID__: () => ɵɵinjectAttribute(attributeName),\n}));\n\nlet _reflect = null;\nfunction getReflect() {\n    return (_reflect = _reflect || new ReflectionCapabilities());\n}\nfunction reflectDependencies(type) {\n    return convertDependencies(getReflect().parameters(type));\n}\nfunction convertDependencies(deps) {\n    return deps.map((dep) => reflectDependency(dep));\n}\nfunction reflectDependency(dep) {\n    const meta = {\n        token: null,\n        attribute: null,\n        host: false,\n        optional: false,\n        self: false,\n        skipSelf: false,\n    };\n    if (Array.isArray(dep) && dep.length > 0) {\n        for (let j = 0; j < dep.length; j++) {\n            const param = dep[j];\n            if (param === undefined) {\n                // param may be undefined if type of dep is not set by ngtsc\n                continue;\n            }\n            const proto = Object.getPrototypeOf(param);\n            if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n                meta.optional = true;\n            }\n            else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n                meta.skipSelf = true;\n            }\n            else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n                meta.self = true;\n            }\n            else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n                meta.host = true;\n            }\n            else if (param instanceof Inject) {\n                meta.token = param.token;\n            }\n            else if (param instanceof Attribute) {\n                if (param.attributeName === undefined) {\n                    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Attribute name must be defined.`);\n                }\n                meta.attribute = param.attributeName;\n            }\n            else {\n                meta.token = param;\n            }\n        }\n    }\n    else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n        meta.token = null;\n    }\n    else {\n        meta.token = dep;\n    }\n    return meta;\n}\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`ɵprov`) onto the injectable type.\n */\nfunction compileInjectable(type, meta) {\n    let ngInjectableDef = null;\n    let ngFactoryDef = null;\n    // if NG_PROV_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_PROV_DEF)) {\n        Object.defineProperty(type, NG_PROV_DEF, {\n            get: () => {\n                if (ngInjectableDef === null) {\n                    const compiler = getCompilerFacade({\n                        usage: 0 /* JitCompilerUsage.Decorator */,\n                        kind: 'injectable',\n                        type,\n                    });\n                    ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/ɵprov.js`, getInjectableMetadata(type, meta));\n                }\n                return ngInjectableDef;\n            },\n        });\n    }\n    // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n        Object.defineProperty(type, NG_FACTORY_DEF, {\n            get: () => {\n                if (ngFactoryDef === null) {\n                    const compiler = getCompilerFacade({\n                        usage: 0 /* JitCompilerUsage.Decorator */,\n                        kind: 'injectable',\n                        type,\n                    });\n                    ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/ɵfac.js`, {\n                        name: type.name,\n                        type,\n                        typeArgumentCount: 0, // In JIT mode types are not available nor used.\n                        deps: reflectDependencies(type),\n                        target: compiler.FactoryTarget.Injectable,\n                    });\n                }\n                return ngFactoryDef;\n            },\n            // Leave this configurable so that the factories from directives or pipes can take precedence.\n            configurable: true,\n        });\n    }\n}\nconst USE_VALUE = getClosureSafeProperty({\n    provide: String,\n    useValue: getClosureSafeProperty,\n});\nfunction isUseClassProvider(meta) {\n    return meta.useClass !== undefined;\n}\nfunction isUseValueProvider(meta) {\n    return USE_VALUE in meta;\n}\nfunction isUseFactoryProvider(meta) {\n    return meta.useFactory !== undefined;\n}\nfunction isUseExistingProvider(meta) {\n    return meta.useExisting !== undefined;\n}\nfunction getInjectableMetadata(type, srcMeta) {\n    // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n    const meta = srcMeta || { providedIn: null };\n    const compilerMeta = {\n        name: type.name,\n        type: type,\n        typeArgumentCount: 0,\n        providedIn: meta.providedIn,\n    };\n    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n        compilerMeta.deps = convertDependencies(meta.deps);\n    }\n    // Check to see if the user explicitly provided a `useXxxx` property.\n    if (isUseClassProvider(meta)) {\n        compilerMeta.useClass = meta.useClass;\n    }\n    else if (isUseValueProvider(meta)) {\n        compilerMeta.useValue = meta.useValue;\n    }\n    else if (isUseFactoryProvider(meta)) {\n        compilerMeta.useFactory = meta.useFactory;\n    }\n    else if (isUseExistingProvider(meta)) {\n        compilerMeta.useExisting = meta.useExisting;\n    }\n    return compilerMeta;\n}\n\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nfunction injectElementRef() {\n    return createElementRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nfunction createElementRef(tNode, lView) {\n    return new ElementRef(getNativeByTNode(tNode, lView));\n}\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nclass ElementRef {\n    /**\n     * <div class=\"docs-alert docs-alert-important\">\n     *   <header>Use with caution</header>\n     *   <p>\n     *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n     *    data-binding provided by Angular instead. If used, it is recommended in combination with\n     *    {@link /best-practices/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls DomSanitizer}\n     *    for maxiumum security;\n     *   </p>\n     * </div>\n     */\n    nativeElement;\n    constructor(nativeElement) {\n        this.nativeElement = nativeElement;\n    }\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = injectElementRef;\n}\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\nfunction unwrapElementRef(value) {\n    return value instanceof ElementRef ? value.nativeElement : value;\n}\n\nfunction symbolIterator() {\n    // @ts-expect-error accessing a private member\n    return this._results[Symbol.iterator]();\n}\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `@for(i of myList; track $index)`.\n *\n * Changes can be observed by subscribing to the `changes` `Observable`.\n * *\n * @usageNotes\n * ### Example\n * ```ts\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nclass QueryList {\n    _emitDistinctChangesOnly;\n    dirty = true;\n    _onDirty = undefined;\n    _results = [];\n    _changesDetected = false;\n    _changes = undefined;\n    length = 0;\n    first = undefined;\n    last = undefined;\n    /**\n     * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n     */\n    get changes() {\n        return (this._changes ??= new Subject());\n    }\n    /**\n     * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n     *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n     *     the same result)\n     */\n    constructor(_emitDistinctChangesOnly = false) {\n        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;\n    }\n    /**\n     * Returns the QueryList entry at `index`.\n     */\n    get(index) {\n        return this._results[index];\n    }\n    /**\n     * See\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n     */\n    map(fn) {\n        return this._results.map(fn);\n    }\n    filter(fn) {\n        return this._results.filter(fn);\n    }\n    /**\n     * See\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n     */\n    find(fn) {\n        return this._results.find(fn);\n    }\n    /**\n     * See\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n     */\n    reduce(fn, init) {\n        return this._results.reduce(fn, init);\n    }\n    /**\n     * See\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n     */\n    forEach(fn) {\n        this._results.forEach(fn);\n    }\n    /**\n     * See\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n     */\n    some(fn) {\n        return this._results.some(fn);\n    }\n    /**\n     * Returns a copy of the internal results list as an Array.\n     */\n    toArray() {\n        return this._results.slice();\n    }\n    toString() {\n        return this._results.toString();\n    }\n    /**\n     * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n     * on change detection, it will not notify of changes to the queries, unless a new change\n     * occurs.\n     *\n     * @param resultsTree The query results to store\n     * @param identityAccessor Optional function for extracting stable object identity from a value\n     *    in the array. This function is executed for each element of the query result list while\n     *    comparing current query list with the new one (provided as a first argument of the `reset`\n     *    function) to detect if the lists are different. If the function is not provided, elements\n     *    are compared as is (without any pre-processing).\n     */\n    reset(resultsTree, identityAccessor) {\n        this.dirty = false;\n        const newResultFlat = flatten(resultsTree);\n        if ((this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor))) {\n            this._results = newResultFlat;\n            this.length = newResultFlat.length;\n            this.last = newResultFlat[this.length - 1];\n            this.first = newResultFlat[0];\n        }\n    }\n    /**\n     * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n     */\n    notifyOnChanges() {\n        if (this._changes !== undefined && (this._changesDetected || !this._emitDistinctChangesOnly))\n            this._changes.next(this);\n    }\n    /** @internal */\n    onDirty(cb) {\n        this._onDirty = cb;\n    }\n    /** internal */\n    setDirty() {\n        this.dirty = true;\n        this._onDirty?.();\n    }\n    /** internal */\n    destroy() {\n        if (this._changes !== undefined) {\n            this._changes.complete();\n            this._changes.unsubscribe();\n        }\n    }\n    [Symbol.iterator] = (() => symbolIterator)();\n}\n\n/**\n * The name of an attribute that can be added to the hydration boundary node\n * (component host node) to disable hydration for the content within that boundary.\n */\nconst SKIP_HYDRATION_ATTR_NAME = 'ngSkipHydration';\n/** Lowercase name of the `ngSkipHydration` attribute used for case-insensitive comparisons. */\nconst SKIP_HYDRATION_ATTR_NAME_LOWER_CASE = 'ngskiphydration';\n/**\n * Helper function to check if a given TNode has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnTNode(tNode) {\n    const attrs = tNode.mergedAttrs;\n    if (attrs === null)\n        return false;\n    // only ever look at the attribute name and skip the values\n    for (let i = 0; i < attrs.length; i += 2) {\n        const value = attrs[i];\n        // This is a marker, which means that the static attributes section is over,\n        // so we can exit early.\n        if (typeof value === 'number')\n            return false;\n        if (typeof value === 'string' && value.toLowerCase() === SKIP_HYDRATION_ATTR_NAME_LOWER_CASE) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Helper function to check if a given RElement has the 'ngSkipHydration' attribute.\n */\nfunction hasSkipHydrationAttrOnRElement(rNode) {\n    return rNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME);\n}\n/**\n * Checks whether a TNode has a flag to indicate that it's a part of\n * a skip hydration block.\n */\nfunction hasInSkipHydrationBlockFlag(tNode) {\n    return (tNode.flags & 128 /* TNodeFlags.inSkipHydrationBlock */) === 128 /* TNodeFlags.inSkipHydrationBlock */;\n}\n/**\n * Helper function that determines if a given node is within a skip hydration block\n * by navigating up the TNode tree to see if any parent nodes have skip hydration\n * attribute.\n */\nfunction isInSkipHydrationBlock(tNode) {\n    if (hasInSkipHydrationBlockFlag(tNode)) {\n        return true;\n    }\n    let currentTNode = tNode.parent;\n    while (currentTNode) {\n        if (hasInSkipHydrationBlockFlag(tNode) || hasSkipHydrationAttrOnTNode(currentTNode)) {\n            return true;\n        }\n        currentTNode = currentTNode.parent;\n    }\n    return false;\n}\n/**\n * Check if an i18n block is in a skip hydration section by looking at a parent TNode\n * to determine if this TNode is in a skip hydration section or the TNode has\n * the `ngSkipHydration` attribute.\n */\nfunction isI18nInSkipHydrationBlock(parentTNode) {\n    return (hasInSkipHydrationBlockFlag(parentTNode) ||\n        hasSkipHydrationAttrOnTNode(parentTNode) ||\n        isInSkipHydrationBlock(parentTNode));\n}\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link /api/core/ChangeDetectorRef?tab=usage-notes Change detection usage}\n * @see {@link /best-practices/skipping-subtrees Skipping component subtrees}\n *\n * @publicApi\n */\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    /**\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n     * Change detection can still be explicitly invoked.\n     * This strategy applies to all child directives and cannot be overridden.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    /**\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\n     * explicitly deactivated.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n\n// Keeps track of the currently-active LViews.\nconst TRACKED_LVIEWS = new Map();\n// Used for generating unique IDs for LViews.\nlet uniqueIdCounter = 0;\n/** Gets a unique ID that can be assigned to an LView. */\nfunction getUniqueLViewId() {\n    return uniqueIdCounter++;\n}\n/** Starts tracking an LView. */\nfunction registerLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');\n    TRACKED_LVIEWS.set(lView[ID], lView);\n}\n/** Gets an LView by its unique ID. */\nfunction getLViewById(id) {\n    ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');\n    return TRACKED_LVIEWS.get(id) || null;\n}\n/** Stops tracking an LView. */\nfunction unregisterLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');\n    TRACKED_LVIEWS.delete(lView[ID]);\n}\n/** Gets the currently-tracked views. */\nfunction getTrackedLViews() {\n    return TRACKED_LVIEWS;\n}\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nclass LContext {\n    lViewId;\n    nodeIndex;\n    native;\n    /**\n     * The instance of the Component node.\n     */\n    component;\n    /**\n     * The list of active directives that exist on this element.\n     */\n    directives;\n    /**\n     * The map of local references (local reference name => element or directive instance) that\n     * exist on this element.\n     */\n    localRefs;\n    /** Component's parent view data. */\n    get lView() {\n        return getLViewById(this.lViewId);\n    }\n    constructor(\n    /**\n     * ID of the component's parent view data.\n     */\n    lViewId, \n    /**\n     * The index instance of the node.\n     */\n    nodeIndex, \n    /**\n     * The instance of the DOM node that is attached to the lNode.\n     */\n    native) {\n        this.lViewId = lViewId;\n        this.nodeIndex = nodeIndex;\n        this.native = native;\n    }\n}\n\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nfunction getLContext(target) {\n    let mpValue = readPatchedData(target);\n    if (mpValue) {\n        // only when it's an array is it considered an LView instance\n        // ... otherwise it's an already constructed LContext instance\n        if (isLView(mpValue)) {\n            const lView = mpValue;\n            let nodeIndex;\n            let component = undefined;\n            let directives = undefined;\n            if (isComponentInstance(target)) {\n                nodeIndex = findViaComponent(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided component was not found in the application');\n                }\n                component = target;\n            }\n            else if (isDirectiveInstance(target)) {\n                nodeIndex = findViaDirective(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided directive was not found in the application');\n                }\n                directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n            }\n            else {\n                nodeIndex = findViaNativeElement(lView, target);\n                if (nodeIndex == -1) {\n                    return null;\n                }\n            }\n            // the goal is not to fill the entire context full of data because the lookups\n            // are expensive. Instead, only the target data (the element, component, container, ICU\n            // expression or directive details) are filled into the context. If called multiple times\n            // with different target values then the missing target data will be filled in.\n            const native = unwrapRNode(lView[nodeIndex]);\n            const existingCtx = readPatchedData(native);\n            const context = existingCtx && !Array.isArray(existingCtx)\n                ? existingCtx\n                : createLContext(lView, nodeIndex, native);\n            // only when the component has been discovered then update the monkey-patch\n            if (component && context.component === undefined) {\n                context.component = component;\n                attachPatchData(context.component, context);\n            }\n            // only when the directives have been discovered then update the monkey-patch\n            if (directives && context.directives === undefined) {\n                context.directives = directives;\n                for (let i = 0; i < directives.length; i++) {\n                    attachPatchData(directives[i], context);\n                }\n            }\n            attachPatchData(context.native, context);\n            mpValue = context;\n        }\n    }\n    else {\n        const rElement = target;\n        ngDevMode && assertDomNode(rElement);\n        // if the context is not found then we need to traverse upwards up the DOM\n        // to find the nearest element that has already been monkey patched with data\n        let parent = rElement;\n        while ((parent = parent.parentNode)) {\n            const parentContext = readPatchedData(parent);\n            if (parentContext) {\n                const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;\n                // the edge of the app was also reached here through another means\n                // (maybe because the DOM was changed manually).\n                if (!lView) {\n                    return null;\n                }\n                const index = findViaNativeElement(lView, rElement);\n                if (index >= 0) {\n                    const native = unwrapRNode(lView[index]);\n                    const context = createLContext(lView, index, native);\n                    attachPatchData(native, context);\n                    mpValue = context;\n                    break;\n                }\n            }\n        }\n    }\n    return mpValue || null;\n}\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView, nodeIndex, native) {\n    return new LContext(lView[ID], nodeIndex, native);\n}\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nfunction getComponentViewByInstance(componentInstance) {\n    let patchedData = readPatchedData(componentInstance);\n    let lView;\n    if (isLView(patchedData)) {\n        const contextLView = patchedData;\n        const nodeIndex = findViaComponent(contextLView, componentInstance);\n        lView = getComponentLViewByIndex(nodeIndex, contextLView);\n        const context = createLContext(contextLView, nodeIndex, lView[HOST]);\n        context.component = componentInstance;\n        attachPatchData(componentInstance, context);\n        attachPatchData(context.native, context);\n    }\n    else {\n        const context = patchedData;\n        const contextLView = context.lView;\n        ngDevMode && assertLView(contextLView);\n        lView = getComponentLViewByIndex(context.nodeIndex, contextLView);\n    }\n    return lView;\n}\n/**\n * This property will be monkey-patched on elements, components and directives.\n */\nconst MONKEY_PATCH_KEY_NAME = '__ngContext__';\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nfunction attachPatchData(target, data) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    // Only attach the ID of the view in order to avoid memory leaks (see #41047). We only do this\n    // for `LView`, because we have control over when an `LView` is created and destroyed, whereas\n    // we can't know when to remove an `LContext`.\n    if (isLView(data)) {\n        target[MONKEY_PATCH_KEY_NAME] = data[ID];\n        registerLView(data);\n    }\n    else {\n        target[MONKEY_PATCH_KEY_NAME] = data;\n    }\n}\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nfunction readPatchedData(target) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    const data = target[MONKEY_PATCH_KEY_NAME];\n    return typeof data === 'number' ? getLViewById(data) : data || null;\n}\nfunction readPatchedLView(target) {\n    const value = readPatchedData(target);\n    if (value) {\n        return (isLView(value) ? value : value.lView);\n    }\n    return null;\n}\nfunction isComponentInstance(instance) {\n    return instance && instance.constructor && instance.constructor.ɵcmp;\n}\nfunction isDirectiveInstance(instance) {\n    return instance && instance.constructor && instance.constructor.ɵdir;\n}\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView, target) {\n    const tView = lView[TVIEW];\n    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n        if (unwrapRNode(lView[i]) === target) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode) {\n    if (tNode.child) {\n        return tNode.child;\n    }\n    else if (tNode.next) {\n        return tNode.next;\n    }\n    else {\n        // Let's take the following template: <div><span>text</span></div><component/>\n        // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n        // in this case the parent `div`, so that we can find the component.\n        while (tNode.parent && !tNode.parent.next) {\n            tNode = tNode.parent;\n        }\n        return tNode.parent && tNode.parent.next;\n    }\n}\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView, componentInstance) {\n    const componentIndices = lView[TVIEW].components;\n    if (componentIndices) {\n        for (let i = 0; i < componentIndices.length; i++) {\n            const elementComponentIndex = componentIndices[i];\n            const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n            if (componentView[CONTEXT] === componentInstance) {\n                return elementComponentIndex;\n            }\n        }\n    }\n    else {\n        const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n        const rootComponent = rootComponentView[CONTEXT];\n        if (rootComponent === componentInstance) {\n            // we are dealing with the root element here therefore we know that the\n            // element is the very first element after the HEADER data in the lView\n            return HEADER_OFFSET;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView, directiveInstance) {\n    // if a directive is monkey patched then it will (by default)\n    // have a reference to the LView of the current view. The\n    // element bound to the directive being search lives somewhere\n    // in the view data. We loop through the nodes and check their\n    // list of directives for the instance.\n    let tNode = lView[TVIEW].firstChild;\n    while (tNode) {\n        const directiveIndexStart = tNode.directiveStart;\n        const directiveIndexEnd = tNode.directiveEnd;\n        for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n            if (lView[i] === directiveInstance) {\n                return tNode.index;\n            }\n        }\n        tNode = traverseNextElement(tNode);\n    }\n    return -1;\n}\n/**\n * Returns a list of directives applied to a node at a specific index. The list includes\n * directives matched by selector and any host directives, but it excludes components.\n * Use `getComponentAtNodeIndex` to find the component applied to a node.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n */\nfunction getDirectivesAtNodeIndex(nodeIndex, lView) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    if (tNode.directiveStart === 0)\n        return EMPTY_ARRAY;\n    const results = [];\n    for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n        const directiveInstance = lView[i];\n        if (!isComponentInstance(directiveInstance)) {\n            results.push(directiveInstance);\n        }\n    }\n    return results;\n}\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    return isComponentHost(tNode) ? lView[tNode.directiveStart + tNode.componentOffset] : null;\n}\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nfunction discoverLocalRefs(lView, nodeIndex) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    if (tNode && tNode.localNames) {\n        const result = {};\n        let localIndex = tNode.index + 1;\n        for (let i = 0; i < tNode.localNames.length; i += 2) {\n            result[tNode.localNames[i]] = lView[localIndex];\n            localIndex++;\n        }\n        return result;\n    }\n    return null;\n}\n\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nfunction getRootView(componentOrLView) {\n    ngDevMode && assertDefined(componentOrLView, 'component');\n    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n    while (lView && !isRootView(lView)) {\n        lView = getLViewParent(lView);\n    }\n    ngDevMode && assertLView(lView);\n    return lView;\n}\n/**\n * Returns the context information associated with the application where the target is situated. It\n * does this by walking the parent views until it gets to the root view, then getting the context\n * off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nfunction getRootContext(viewOrComponent) {\n    const rootView = getRootView(viewOrComponent);\n    ngDevMode &&\n        assertDefined(rootView[CONTEXT], 'Root view has no context. Perhaps it is disconnected?');\n    return rootView[CONTEXT];\n}\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nfunction getFirstLContainer(lView) {\n    return getNearestLContainer(lView[CHILD_HEAD]);\n}\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nfunction getNextLContainer(container) {\n    return getNearestLContainer(container[NEXT]);\n}\nfunction getNearestLContainer(viewOrContainer) {\n    while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n        viewOrContainer = viewOrContainer[NEXT];\n    }\n    return viewOrContainer;\n}\n\n/**\n * Retrieves the component instance associated with a given DOM element.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div>\n *     <child-comp></child-comp>\n *   </div>\n * </app-root>\n * ```\n *\n * Calling `getComponent` on `<child-comp>` will return the instance of `ChildComponent`\n * associated with this DOM element.\n *\n * Calling the function on `<app-root>` will return the `MyApp` instance.\n *\n *\n * @param element DOM element from which the component should be retrieved.\n * @returns Component instance associated with the element or `null` if there\n *    is no component associated with it.\n *\n * @publicApi\n */\nfunction getComponent(element) {\n    ngDevMode && assertDomElement(element);\n    const context = getLContext(element);\n    if (context === null)\n        return null;\n    if (context.component === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return null;\n        }\n        context.component = getComponentAtNodeIndex(context.nodeIndex, lView);\n    }\n    return context.component;\n}\n/**\n * If inside an embedded view (e.g. `*ngIf` or `*ngFor`), retrieves the context of the embedded\n * view that the element is part of. Otherwise retrieves the instance of the component whose view\n * owns the element (in this case, the result is the same as calling `getOwningComponent`).\n *\n * @param element Element for which to get the surrounding component instance.\n * @returns Instance of the component that is around the element or null if the element isn't\n *    inside any component.\n *\n * @publicApi\n */\nfunction getContext(element) {\n    assertDomElement(element);\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    return lView === null ? null : lView[CONTEXT];\n}\n/**\n * Retrieves the component instance whose view contains the DOM element.\n *\n * For example, if `<child-comp>` is used in the template of `<app-comp>`\n * (i.e. a `ViewChild` of `<app-comp>`), calling `getOwningComponent` on `<child-comp>`\n * would return `<app-comp>`.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Component instance whose view owns the DOM element or null if the element is not\n *    part of a component view.\n *\n * @publicApi\n */\nfunction getOwningComponent(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    let lView = context ? context.lView : null;\n    if (lView === null)\n        return null;\n    let parent;\n    while (lView[TVIEW].type === 2 /* TViewType.Embedded */ && (parent = getLViewParent(lView))) {\n        lView = parent;\n    }\n    return isRootView(lView) ? null : lView[CONTEXT];\n}\n/**\n * Retrieves all root components associated with a DOM element, directive or component instance.\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Root components associated with the target object.\n *\n * @publicApi\n */\nfunction getRootComponents(elementOrDir) {\n    const lView = readPatchedLView(elementOrDir);\n    return lView !== null ? [getRootContext(lView)] : [];\n}\n/**\n * Retrieves an `Injector` associated with an element, component or directive instance.\n *\n * @param elementOrDir DOM element, component or directive instance for which to\n *    retrieve the injector.\n * @returns Injector associated with the element, component or directive instance.\n *\n * @publicApi\n */\nfunction getInjector(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return Injector.NULL;\n    const tNode = lView[TVIEW].data[context.nodeIndex];\n    return new NodeInjector(tNode, lView);\n}\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n */\nfunction getInjectionTokens(element) {\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const tNode = tView.data[context.nodeIndex];\n    const providerTokens = [];\n    const startIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const endIndex = tNode.directiveEnd;\n    for (let i = startIndex; i < endIndex; i++) {\n        let value = tView.data[i];\n        if (isDirectiveDefHack(value)) {\n            // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n            // design flaw.  We should always store same type so that we can be monomorphic. The issue\n            // is that for Components/Directives we store the def instead the type. The correct behavior\n            // is that we should always be storing injectable type in this location.\n            value = value.type;\n        }\n        providerTokens.push(value);\n    }\n    return providerTokens;\n}\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n */\nfunction getDirectives(node) {\n    // Skip text nodes because we can't have directives associated with them.\n    if (node instanceof Text) {\n        return [];\n    }\n    const context = getLContext(node);\n    const lView = context ? context.lView : null;\n    if (lView === null) {\n        return [];\n    }\n    const tView = lView[TVIEW];\n    const nodeIndex = context.nodeIndex;\n    if (!tView?.data[nodeIndex]) {\n        return [];\n    }\n    if (context.directives === undefined) {\n        context.directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n    }\n    // The `directives` in this case are a named array called `LComponentView`. Clone the\n    // result so we don't expose an internal data structure in the user's console.\n    return context.directives === null ? [] : [...context.directives];\n}\n/** The framework used to author a particular application or component. */\nvar Framework;\n(function (Framework) {\n    Framework[\"Angular\"] = \"angular\";\n    Framework[\"ACX\"] = \"acx\";\n    Framework[\"Wiz\"] = \"wiz\";\n})(Framework || (Framework = {}));\n/** ACX change detection strategies. */\nvar AcxChangeDetectionStrategy;\n(function (AcxChangeDetectionStrategy) {\n    AcxChangeDetectionStrategy[AcxChangeDetectionStrategy[\"Default\"] = 0] = \"Default\";\n    AcxChangeDetectionStrategy[AcxChangeDetectionStrategy[\"OnPush\"] = 1] = \"OnPush\";\n})(AcxChangeDetectionStrategy || (AcxChangeDetectionStrategy = {}));\n/** ACX view encapsulation modes. */\nvar AcxViewEncapsulation;\n(function (AcxViewEncapsulation) {\n    AcxViewEncapsulation[AcxViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    AcxViewEncapsulation[AcxViewEncapsulation[\"None\"] = 1] = \"None\";\n})(AcxViewEncapsulation || (AcxViewEncapsulation = {}));\n/**\n * Returns the debug (partial) metadata for a particular directive or component instance.\n * The function accepts an instance of a directive or component and returns the corresponding\n * metadata.\n *\n * @param directiveOrComponentInstance Instance of a directive or component\n * @returns metadata of the passed directive or component\n *\n * @publicApi\n */\nfunction getDirectiveMetadata$1(directiveOrComponentInstance) {\n    const { constructor } = directiveOrComponentInstance;\n    if (!constructor) {\n        throw new Error('Unable to find the instance constructor');\n    }\n    // In case a component inherits from a directive, we may have component and directive metadata\n    // To ensure we don't get the metadata of the directive, we want to call `getComponentDef` first.\n    const componentDef = getComponentDef(constructor);\n    if (componentDef) {\n        const inputs = extractInputDebugMetadata(componentDef.inputs);\n        return {\n            inputs,\n            outputs: componentDef.outputs,\n            encapsulation: componentDef.encapsulation,\n            changeDetection: componentDef.onPush\n                ? ChangeDetectionStrategy.OnPush\n                : ChangeDetectionStrategy.Default,\n        };\n    }\n    const directiveDef = getDirectiveDef(constructor);\n    if (directiveDef) {\n        const inputs = extractInputDebugMetadata(directiveDef.inputs);\n        return { inputs, outputs: directiveDef.outputs };\n    }\n    return null;\n}\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target DOM element, component or directive instance for which to retrieve\n *    the local references.\n */\nfunction getLocalRefs(target) {\n    const context = getLContext(target);\n    if (context === null)\n        return {};\n    if (context.localRefs === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return {};\n        }\n        context.localRefs = discoverLocalRefs(lView, context.nodeIndex);\n    }\n    return context.localRefs || {};\n}\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n */\nfunction getHostElement(componentOrDirective) {\n    return getLContext(componentOrDirective).native;\n}\n/**\n * Retrieves a list of event listeners associated with a DOM element. The list does include host\n * listeners, but it does not include event listeners defined outside of the Angular context\n * (e.g. through `addEventListener`).\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div (click)=\"doSomething()\"></div>\n * </app-root>\n * ```\n *\n * Calling `getListeners` on `<div>` will return an object that looks as follows:\n *\n * ```ts\n * {\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * }\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @returns Array of event listeners on the DOM element.\n *\n * @publicApi\n */\nfunction getListeners(element) {\n    ngDevMode && assertDomElement(element);\n    const lContext = getLContext(element);\n    const lView = lContext === null ? null : lContext.lView;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const lCleanup = lView[CLEANUP];\n    const tCleanup = tView.cleanup;\n    const listeners = [];\n    if (tCleanup && lCleanup) {\n        for (let i = 0; i < tCleanup.length;) {\n            const firstParam = tCleanup[i++];\n            const secondParam = tCleanup[i++];\n            if (typeof firstParam === 'string') {\n                const name = firstParam;\n                const listenerElement = unwrapRNode(lView[secondParam]);\n                const callback = lCleanup[tCleanup[i++]];\n                const useCaptureOrIndx = tCleanup[i++];\n                // if useCaptureOrIndx is boolean then report it as is.\n                // if useCaptureOrIndx is positive number then it in unsubscribe method\n                // if useCaptureOrIndx is negative number then it is a Subscription\n                const type = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0 ? 'dom' : 'output';\n                const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;\n                if (element == listenerElement) {\n                    listeners.push({ element, name, callback, useCapture, type });\n                }\n            }\n        }\n    }\n    listeners.sort(sortListeners);\n    return listeners;\n}\nfunction sortListeners(a, b) {\n    if (a.name == b.name)\n        return 0;\n    return a.name < b.name ? -1 : 1;\n}\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\nfunction isDirectiveDefHack(obj) {\n    return (obj.type !== undefined &&\n        obj.declaredInputs !== undefined &&\n        obj.resolveHostDirectives !== undefined);\n}\n/** Asserts that a value is a DOM Element. */\nfunction assertDomElement(value) {\n    if (typeof Element !== 'undefined' && !(value instanceof Element)) {\n        throw new Error('Expecting instance of DOM Element');\n    }\n}\n/**\n * A directive definition holds additional metadata using bitwise flags to indicate\n * for example whether it is signal based.\n *\n * This information needs to be separate from the `publicName -> minifiedName`\n * mappings for backwards compatibility.\n */\nfunction extractInputDebugMetadata(inputs) {\n    const res = {};\n    for (const key in inputs) {\n        if (inputs.hasOwnProperty(key)) {\n            const value = inputs[key];\n            if (value !== undefined) {\n                res[key] = value[0];\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser` and `Server`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT = undefined;\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nfunction setDocument(document) {\n    DOCUMENT = document;\n}\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nfunction getDocument() {\n    if (DOCUMENT !== undefined) {\n        return DOCUMENT;\n    }\n    else if (typeof document !== 'undefined') {\n        return document;\n    }\n    throw new RuntimeError(210 /* RuntimeErrorCode.MISSING_DOCUMENT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);\n    // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n    // the current platform is not a browser. Since this is not a supported scenario at the moment\n    // this should not happen in Angular apps.\n    // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n    // public API.\n}\n\n/**\n * A DI token representing a string ID, used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated} is being used.\n *\n * The token is needed in cases when multiple applications are bootstrapped on a page\n * (for example, using `bootstrapApplication` calls). In this case, ensure that those applications\n * have different `APP_ID` value setup. For example:\n *\n * ```ts\n * bootstrapApplication(ComponentA, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-a' },\n *     // ... other providers ...\n *   ]\n * });\n *\n * bootstrapApplication(ComponentB, {\n *   providers: [\n *     { provide: APP_ID, useValue: 'app-b' },\n *     // ... other providers ...\n *   ]\n * });\n * ```\n *\n * By default, when there is only one application bootstrapped, you don't need to provide the\n * `APP_ID` token (the `ng` will be used as an app ID).\n *\n * @publicApi\n */\nconst APP_ID = new InjectionToken(ngDevMode ? 'AppId' : '', {\n    providedIn: 'root',\n    factory: () => DEFAULT_APP_ID,\n});\n/** Default value of the `APP_ID` token. */\nconst DEFAULT_APP_ID = 'ng';\n/**\n * A function that is executed when a platform is initialized.\n *\n * @deprecated from v19.0.0, use providePlatformInitializer instead\n *\n * @see {@link providePlatformInitializer}\n *\n * @publicApi\n */\nconst PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? 'Platform Initializer' : '');\n/**\n * A token that indicates an opaque platform ID.\n * @publicApi\n */\nconst PLATFORM_ID = new InjectionToken(ngDevMode ? 'Platform ID' : '', {\n    providedIn: 'platform',\n    factory: () => 'unknown', // set a default platform name, when none set explicitly\n});\n/**\n * A DI token that indicates the root directory of\n * the application\n * @publicApi\n * @deprecated\n */\nconst PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? 'Application Packages Root URL' : '');\n// We keep this token here, rather than the animations package, so that modules that only care\n// about which animations module is loaded (e.g. the CDK) can retrieve it without having to\n// include extra dependencies. See #44970 for more context.\n/**\n * A [DI token](api/core/InjectionToken) that indicates which animations\n * module has been loaded.\n * @publicApi\n */\nconst ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? 'AnimationModuleType' : '');\n// TODO(crisbeto): link to CSP guide here.\n/**\n * Token used to configure the [Content Security Policy](https://web.dev/strict-csp/) nonce that\n * Angular will apply when inserting inline styles. If not provided, Angular will look up its value\n * from the `ngCspNonce` attribute of the application root node.\n *\n * @publicApi\n */\nconst CSP_NONCE = new InjectionToken(ngDevMode ? 'CSP nonce' : '', {\n    providedIn: 'root',\n    factory: () => {\n        // Ideally we wouldn't have to use `querySelector` here since we know that the nonce will be on\n        // the root node, but because the token value is used in renderers, it has to be available\n        // *very* early in the bootstrapping process. This should be a fairly shallow search, because\n        // the app won't have been added to the DOM yet. Some approaches that were considered:\n        // 1. Find the root node through `ApplicationRef.components[i].location` - normally this would\n        // be enough for our purposes, but the token is injected very early so the `components` array\n        // isn't populated yet.\n        // 2. Find the root `LView` through the current `LView` - renderers are a prerequisite to\n        // creating the `LView`. This means that no `LView` will have been entered when this factory is\n        // invoked for the root component.\n        // 3. Have the token factory return `() => string` which is invoked when a nonce is requested -\n        // the slightly later execution does allow us to get an `LView` reference, but the fact that\n        // it is a function means that it could be executed at *any* time (including immediately) which\n        // may lead to weird bugs.\n        // 4. Have the `ComponentFactory` read the attribute and provide it to the injector under the\n        // hood - has the same problem as #1 and #2 in that the renderer is used to query for the root\n        // node and the nonce value needs to be available when the renderer is created.\n        return getDocument().body?.querySelector('[ngCspNonce]')?.getAttribute('ngCspNonce') || null;\n    },\n});\nconst IMAGE_CONFIG_DEFAULTS = {\n    breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n    placeholderResolution: 30,\n    disableImageSizeWarning: false,\n    disableImageLazyLoadWarning: false,\n};\n/**\n * Injection token that configures the image optimized image functionality.\n * See {@link ImageConfig} for additional information about parameters that\n * can be used.\n *\n * @see {@link NgOptimizedImage}\n * @see {@link ImageConfig}\n * @publicApi\n */\nconst IMAGE_CONFIG = new InjectionToken(ngDevMode ? 'ImageConfig' : '', {\n    providedIn: 'root',\n    factory: () => IMAGE_CONFIG_DEFAULTS,\n});\n\n/**\n * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.\n *\n * Example:\n *\n * ```ts\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * @publicApi\n */\nfunction makeStateKey(key) {\n    return key;\n}\nfunction initTransferState() {\n    const transferState = new TransferState();\n    if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n        transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));\n    }\n    return transferState;\n}\n/**\n * A key value store that is transferred from the application on the server side to the application\n * on the client side.\n *\n * The `TransferState` is available as an injectable token.\n * On the client, just inject this token using DI and use it, it will be lazily initialized.\n * On the server it's already included if `renderApplication` function is used. Otherwise, import\n * the `ServerTransferStateModule` module to make the `TransferState` available.\n *\n * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only\n * boolean, number, string, null and non-class objects will be serialized and deserialized in a\n * non-lossy manner.\n *\n * @publicApi\n */\nclass TransferState {\n    /** @nocollapse */\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ __defineInjectable({\n        token: TransferState,\n        providedIn: 'root',\n        factory: initTransferState,\n    });\n    /** @internal */\n    store = {};\n    onSerializeCallbacks = {};\n    /**\n     * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n     */\n    get(key, defaultValue) {\n        return this.store[key] !== undefined ? this.store[key] : defaultValue;\n    }\n    /**\n     * Set the value corresponding to a key.\n     */\n    set(key, value) {\n        this.store[key] = value;\n    }\n    /**\n     * Remove a key from the store.\n     */\n    remove(key) {\n        delete this.store[key];\n    }\n    /**\n     * Test whether a key exists in the store.\n     */\n    hasKey(key) {\n        return this.store.hasOwnProperty(key);\n    }\n    /**\n     * Indicates whether the state is empty.\n     */\n    get isEmpty() {\n        return Object.keys(this.store).length === 0;\n    }\n    /**\n     * Register a callback to provide the value for a key when `toJson` is called.\n     */\n    onSerialize(key, callback) {\n        this.onSerializeCallbacks[key] = callback;\n    }\n    /**\n     * Serialize the current state of the store to JSON.\n     */\n    toJson() {\n        // Call the onSerialize callbacks and put those values into the store.\n        for (const key in this.onSerializeCallbacks) {\n            if (this.onSerializeCallbacks.hasOwnProperty(key)) {\n                try {\n                    this.store[key] = this.onSerializeCallbacks[key]();\n                }\n                catch (e) {\n                    console.warn('Exception in onSerialize callback: ', e);\n                }\n            }\n        }\n        // Escape script tag to avoid break out of <script> tag in serialized output.\n        // Encoding of `<` is the same behaviour as G3 script_builders.\n        return JSON.stringify(this.store).replace(/</g, '\\\\u003C');\n    }\n}\nfunction retrieveTransferredState(doc, appId) {\n    // Locate the script tag with the JSON data transferred from the server.\n    // The id of the script tag is set to the Angular appId + 'state'.\n    const script = doc.getElementById(appId + '-state');\n    if (script?.textContent) {\n        try {\n            // Avoid using any here as it triggers lint errors in google3 (any is not allowed).\n            // Decoding of `<` is done of the box by browsers and node.js, same behaviour as G3\n            // script_builders.\n            return JSON.parse(script.textContent);\n        }\n        catch (e) {\n            console.warn('Exception while restoring TransferState for app ' + appId, e);\n        }\n    }\n    return {};\n}\n\n/** Encodes that the node lookup should start from the host node of this component. */\nconst REFERENCE_NODE_HOST = 'h';\n/** Encodes that the node lookup should start from the document body node. */\nconst REFERENCE_NODE_BODY = 'b';\nconst NODE_NAVIGATION_STEP_FIRST_CHILD = 'f';\nconst NODE_NAVIGATION_STEP_NEXT_SIBLING = 'n';\n/**\n * Keys within serialized view data structure to represent various\n * parts. See the `SerializedView` interface below for additional information.\n */\nconst ELEMENT_CONTAINERS = 'e';\nconst TEMPLATES = 't';\nconst CONTAINERS = 'c';\nconst MULTIPLIER = 'x';\nconst NUM_ROOT_NODES = 'r';\nconst TEMPLATE_ID = 'i'; // as it's also an \"id\"\nconst NODES = 'n';\nconst DISCONNECTED_NODES = 'd';\nconst I18N_DATA = 'l';\nconst DEFER_BLOCK_ID = 'di';\nconst DEFER_BLOCK_STATE$1 = 's';\nconst DEFER_PARENT_BLOCK_ID = 'p';\nconst DEFER_HYDRATE_TRIGGERS = 't';\n\n/**\n * Internal token that specifies whether DOM reuse logic\n * during hydration is enabled.\n */\nconst IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'IS_HYDRATION_DOM_REUSE_ENABLED' : '');\n// By default (in client rendering mode), we remove all the contents\n// of the host element and render an application after that.\nconst PRESERVE_HOST_CONTENT_DEFAULT = false;\n/**\n * Internal token that indicates whether host element content should be\n * retained during the bootstrap.\n */\nconst PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'PRESERVE_HOST_CONTENT' : '', {\n    providedIn: 'root',\n    factory: () => PRESERVE_HOST_CONTENT_DEFAULT,\n});\n/**\n * Internal token that indicates whether hydration support for i18n\n * is enabled.\n */\nconst IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'IS_I18N_HYDRATION_ENABLED' : '');\n/**\n * Internal token that indicates whether event replay support for SSR\n * is enabled.\n */\nconst IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'IS_EVENT_REPLAY_ENABLED' : '');\nconst EVENT_REPLAY_ENABLED_DEFAULT = false;\n/**\n * Internal token that indicates whether incremental hydration support\n * is enabled.\n */\nconst IS_INCREMENTAL_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || !!ngDevMode ? 'IS_INCREMENTAL_HYDRATION_ENABLED' : '');\n/**\n * A map of DOM elements with `jsaction` attributes grouped by action names.\n */\nconst JSACTION_BLOCK_ELEMENT_MAP = new InjectionToken(ngDevMode ? 'JSACTION_BLOCK_ELEMENT_MAP' : '', {\n    providedIn: 'root',\n    factory: () => new Map(),\n});\n\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n/** Configuration object used to register passive and capturing events. */\nconst eventListenerOptions = {\n    passive: true,\n    capture: true,\n};\n/** Keeps track of the currently-registered `on hover` triggers. */\nconst hoverTriggers = new WeakMap();\n/** Keeps track of the currently-registered `on interaction` triggers. */\nconst interactionTriggers = new WeakMap();\n/** Currently-registered `viewport` triggers. */\nconst viewportTriggers = new WeakMap();\n/** Names of the events considered as interaction events. */\nconst interactionEventNames = ['click', 'keydown'];\n/** Names of the events considered as hover events. */\nconst hoverEventNames = ['mouseenter', 'mouseover', 'focusin'];\n/** `IntersectionObserver` used to observe `viewport` triggers. */\nlet intersectionObserver = null;\n/** Number of elements currently observed with `viewport` triggers. */\nlet observedViewportElements = 0;\n/** Object keeping track of registered callbacks for a deferred block trigger. */\nclass DeferEventEntry {\n    callbacks = new Set();\n    listener = () => {\n        for (const callback of this.callbacks) {\n            callback();\n        }\n    };\n}\n/**\n * Registers an interaction trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger is interacted with.\n * @return cleanup function which removes trigger Element from interactionTriggers map\n * and interaction event listeners from the trigger Element\n */\nfunction onInteraction(trigger, callback) {\n    let entry = interactionTriggers.get(trigger);\n    // If this is the first entry for this element, add the listeners.\n    if (!entry) {\n        // Note that managing events centrally like this lends itself well to using global\n        // event delegation. It currently does delegation at the element level, rather than the\n        // document level, because:\n        // 1. Global delegation is the most effective when there are a lot of events being registered\n        // at the same time. Deferred blocks are unlikely to be used in such a way.\n        // 2. Matching events to their target isn't free. For each `click` and `keydown` event we\n        // would have look through all the triggers and check if the target either is the element\n        // itself or it's contained within the element. Given that `click` and `keydown` are some\n        // of the most common events, this may end up introducing a lot of runtime overhead.\n        // 3. We're still registering only two events per element, no matter how many deferred blocks\n        // are referencing it.\n        entry = new DeferEventEntry();\n        interactionTriggers.set(trigger, entry);\n        for (const name of interactionEventNames) {\n            trigger.addEventListener(name, entry.listener, eventListenerOptions);\n        }\n    }\n    entry.callbacks.add(callback);\n    return () => {\n        const { callbacks, listener } = entry;\n        callbacks.delete(callback);\n        if (callbacks.size === 0) {\n            interactionTriggers.delete(trigger);\n            for (const name of interactionEventNames) {\n                trigger.removeEventListener(name, listener, eventListenerOptions);\n            }\n        }\n    };\n}\n/**\n * Registers a hover trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger is hovered over.\n * @return cleanup function which removes trigger element from hoverTriggers map\n * and removes hover interaction event listeners from the trigger element\n */\nfunction onHover(trigger, callback) {\n    let entry = hoverTriggers.get(trigger);\n    // If this is the first entry for this element, add the listener.\n    if (!entry) {\n        entry = new DeferEventEntry();\n        hoverTriggers.set(trigger, entry);\n        for (const name of hoverEventNames) {\n            trigger.addEventListener(name, entry.listener, eventListenerOptions);\n        }\n    }\n    entry.callbacks.add(callback);\n    return () => {\n        const { callbacks, listener } = entry;\n        callbacks.delete(callback);\n        if (callbacks.size === 0) {\n            for (const name of hoverEventNames) {\n                trigger.removeEventListener(name, listener, eventListenerOptions);\n            }\n            hoverTriggers.delete(trigger);\n        }\n    };\n}\n/**\n * Used to create an IntersectionObserver instance.\n * @return IntersectionObserver that is used by onViewport\n */\nfunction createIntersectionObserver() {\n    return new IntersectionObserver((entries) => {\n        for (const current of entries) {\n            if (current.isIntersecting && viewportTriggers.has(current.target)) {\n                viewportTriggers.get(current.target).listener();\n            }\n        }\n    });\n}\n/**\n * Registers a viewport trigger.\n * @param trigger Element that is the trigger.\n * @param callback Callback to be invoked when the trigger comes into the viewport.\n * @param observerFactoryFn Factory function which returns an IntersectionObserver\n * @return cleanup function which removes trigger Element from viewportTriggers map\n * and tells the intersection observer to stop observing trigger Element and set\n * intersectionObserver to null if there are no more Elements to observe\n */\nfunction onViewport(trigger, callback, observerFactoryFn) {\n    let entry = viewportTriggers.get(trigger);\n    intersectionObserver = intersectionObserver || observerFactoryFn();\n    if (!entry) {\n        entry = new DeferEventEntry();\n        intersectionObserver.observe(trigger);\n        viewportTriggers.set(trigger, entry);\n        observedViewportElements++;\n    }\n    entry.callbacks.add(callback);\n    return () => {\n        if (!viewportTriggers.has(trigger)) {\n            return;\n        }\n        entry.callbacks.delete(callback);\n        if (entry.callbacks.size === 0) {\n            intersectionObserver?.unobserve(trigger);\n            viewportTriggers.delete(trigger);\n            observedViewportElements--;\n        }\n        if (observedViewportElements === 0) {\n            intersectionObserver?.disconnect();\n            intersectionObserver = null;\n        }\n    };\n}\n\nconst DEFER_BLOCK_SSR_ID_ATTRIBUTE = 'ngb';\nfunction setJSActionAttributes(nativeElement, eventTypes, parentDeferBlockId = null) {\n    // jsaction attributes specifically should be applied to elements and not comment nodes.\n    // Comment nodes also have no setAttribute function. So this avoids errors.\n    if (eventTypes.length === 0 || nativeElement.nodeType !== Node.ELEMENT_NODE) {\n        return;\n    }\n    const existingAttr = nativeElement.getAttribute(Attribute$1.JSACTION);\n    // we dedupe cases where hydrate triggers are used as it's possible that\n    // someone may have added an event binding to the root node that matches what the\n    // hydrate trigger adds.\n    const parts = eventTypes.reduce((prev, curr) => {\n        // if there is no existing attribute OR it's not in the existing one, we need to add it\n        return (existingAttr?.indexOf(curr) ?? -1) === -1 ? prev + curr + ':;' : prev;\n    }, '');\n    //  This is required to be a module accessor to appease security tests on setAttribute.\n    nativeElement.setAttribute(Attribute$1.JSACTION, `${existingAttr ?? ''}${parts}`);\n    const blockName = parentDeferBlockId ?? '';\n    if (blockName !== '' && parts.length > 0) {\n        nativeElement.setAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE, blockName);\n    }\n}\nconst sharedStashFunction = (rEl, eventType, listenerFn) => {\n    const el = rEl;\n    const eventListenerMap = el.__jsaction_fns ?? new Map();\n    const eventListeners = eventListenerMap.get(eventType) ?? [];\n    eventListeners.push(listenerFn);\n    eventListenerMap.set(eventType, eventListeners);\n    el.__jsaction_fns = eventListenerMap;\n};\nconst sharedMapFunction = (rEl, jsActionMap) => {\n    const el = rEl;\n    let blockName = el.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE) ?? '';\n    const blockSet = jsActionMap.get(blockName) ?? new Set();\n    if (!blockSet.has(el)) {\n        blockSet.add(el);\n    }\n    jsActionMap.set(blockName, blockSet);\n};\nfunction removeListenersFromBlocks(blockNames, jsActionMap) {\n    if (blockNames.length > 0) {\n        let blockList = [];\n        for (let blockName of blockNames) {\n            if (jsActionMap.has(blockName)) {\n                blockList = [...blockList, ...jsActionMap.get(blockName)];\n            }\n        }\n        const replayList = new Set(blockList);\n        replayList.forEach(removeListeners);\n    }\n}\nconst removeListeners = (el) => {\n    el.removeAttribute(Attribute$1.JSACTION);\n    el.removeAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE);\n    el.__jsaction_fns = undefined;\n};\nconst JSACTION_EVENT_CONTRACT = new InjectionToken(ngDevMode ? 'EVENT_CONTRACT_DETAILS' : '', {\n    providedIn: 'root',\n    factory: () => ({}),\n});\nfunction invokeListeners(event, currentTarget) {\n    const handlerFns = currentTarget?.__jsaction_fns?.get(event.type);\n    if (!handlerFns || !currentTarget?.isConnected) {\n        return;\n    }\n    for (const handler of handlerFns) {\n        handler(event);\n    }\n}\nconst stashEventListeners = new Map();\n/**\n * Registers a stashing function for a specific application ID.\n *\n * @param appId The unique identifier for the application instance.\n * @param fn The stashing function to associate with this app ID.\n * @returns A cleanup function that removes the stashing function when called.\n */\nfunction setStashFn(appId, fn) {\n    stashEventListeners.set(appId, fn);\n    return () => stashEventListeners.delete(appId);\n}\n/**\n * Indicates whether the stashing code was added, prevents adding it multiple times.\n */\nlet isStashEventListenerImplEnabled = false;\nlet _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => { };\n/**\n * Optionally stashes an event listener for later replay during hydration.\n *\n * This function delegates to an internal `_stashEventListenerImpl`, which may\n * be a no-op unless the event replay feature is enabled. When active, this\n * allows capturing event listener metadata before hydration completes, so that\n * user interactions during SSR can be replayed.\n *\n * @param lView The logical view (LView) where the listener is being registered.\n * @param target The DOM element or event target the listener is attached to.\n * @param eventName The name of the event being listened for (e.g., 'click').\n * @param wrappedListener The event handler that was registered.\n */\nfunction stashEventListenerImpl(lView, target, eventName, wrappedListener) {\n    _stashEventListenerImpl(lView, target, eventName, wrappedListener);\n}\n/**\n * Enables the event listener stashing logic in a tree-shakable way.\n *\n * This function lazily sets the implementation of `_stashEventListenerImpl`\n * so that it becomes active only when `withEventReplay` is invoked. This ensures\n * that the stashing logic is excluded from production builds unless needed.\n */\nfunction enableStashEventListenerImpl() {\n    if (!isStashEventListenerImplEnabled) {\n        _stashEventListenerImpl = (lView, target, eventName, wrappedListener) => {\n            const appId = lView[INJECTOR].get(APP_ID);\n            const stashEventListener = stashEventListeners.get(appId);\n            stashEventListener?.(target, eventName, wrappedListener);\n        };\n        isStashEventListenerImplEnabled = true;\n    }\n}\n\n/**\n * An internal injection token to reference `DehydratedBlockRegistry` implementation\n * in a tree-shakable way.\n */\nconst DEHYDRATED_BLOCK_REGISTRY = new InjectionToken(ngDevMode ? 'DEHYDRATED_BLOCK_REGISTRY' : '');\n/**\n * The DehydratedBlockRegistry is used for incremental hydration purposes. It keeps\n * track of the Defer Blocks that need hydration so we can effectively\n * navigate up to the top dehydrated defer block and fire appropriate cleanup\n * functions post hydration.\n */\nclass DehydratedBlockRegistry {\n    registry = new Map();\n    cleanupFns = new Map();\n    jsActionMap = inject(JSACTION_BLOCK_ELEMENT_MAP);\n    contract = inject(JSACTION_EVENT_CONTRACT);\n    add(blockId, info) {\n        this.registry.set(blockId, info);\n        // It's possible that hydration is queued that's waiting for the\n        // resolution of a lazy loaded route. In this case, we ensure\n        // the callback function is called to continue the hydration process\n        // for the queued block set.\n        if (this.awaitingCallbacks.has(blockId)) {\n            const awaitingCallbacks = this.awaitingCallbacks.get(blockId);\n            for (const cb of awaitingCallbacks) {\n                cb();\n            }\n        }\n    }\n    get(blockId) {\n        return this.registry.get(blockId) ?? null;\n    }\n    has(blockId) {\n        return this.registry.has(blockId);\n    }\n    cleanup(hydratedBlocks) {\n        removeListenersFromBlocks(hydratedBlocks, this.jsActionMap);\n        for (let blockId of hydratedBlocks) {\n            this.registry.delete(blockId);\n            this.jsActionMap.delete(blockId);\n            this.invokeTriggerCleanupFns(blockId);\n            this.hydrating.delete(blockId);\n            this.awaitingCallbacks.delete(blockId);\n        }\n        if (this.size === 0) {\n            this.contract.instance?.cleanUp();\n        }\n    }\n    get size() {\n        return this.registry.size;\n    }\n    // we have to leave the lowest block Id in the registry\n    // unless that block has no children\n    addCleanupFn(blockId, fn) {\n        let cleanupFunctions = [];\n        if (this.cleanupFns.has(blockId)) {\n            cleanupFunctions = this.cleanupFns.get(blockId);\n        }\n        cleanupFunctions.push(fn);\n        this.cleanupFns.set(blockId, cleanupFunctions);\n    }\n    invokeTriggerCleanupFns(blockId) {\n        const fns = this.cleanupFns.get(blockId) ?? [];\n        for (let fn of fns) {\n            fn();\n        }\n        this.cleanupFns.delete(blockId);\n    }\n    // Blocks that are being hydrated.\n    hydrating = new Map();\n    // Blocks that are awaiting a defer instruction finish.\n    awaitingCallbacks = new Map();\n    awaitParentBlock(topmostParentBlock, callback) {\n        const parentBlockAwaitCallbacks = this.awaitingCallbacks.get(topmostParentBlock) ?? [];\n        parentBlockAwaitCallbacks.push(callback);\n        this.awaitingCallbacks.set(topmostParentBlock, parentBlockAwaitCallbacks);\n    }\n    /** @nocollapse */\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ __defineInjectable({\n        token: DehydratedBlockRegistry,\n        providedIn: null,\n        factory: () => new DehydratedBlockRegistry(),\n    });\n}\n\n/**\n * Checks whether a TNode is considered detached, i.e. not present in the\n * translated i18n template. We should not attempt hydration for such nodes\n * and instead, use a regular \"creation mode\".\n */\nfunction isDetachedByI18n(tNode) {\n    return (tNode.flags & 32 /* TNodeFlags.isDetached */) === 32 /* TNodeFlags.isDetached */;\n}\n\n/**\n * The name of the key used in the TransferState collection,\n * where hydration information is located.\n */\nconst TRANSFER_STATE_TOKEN_ID = '__nghData__';\n/**\n * Lookup key used to reference DOM hydration data (ngh) in `TransferState`.\n */\nconst NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);\n/**\n * The name of the key used in the TransferState collection,\n * where serialized defer block information is located.\n */\nconst TRANSFER_STATE_DEFER_BLOCKS_INFO = '__nghDeferData__';\n/**\n * Lookup key used to retrieve defer block datain `TransferState`.\n */\nconst NGH_DEFER_BLOCKS_KEY = makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);\n/**\n * Checks whether a given key is used by the framework for transferring hydration data.\n */\nfunction isInternalHydrationTransferStateKey(key) {\n    return key === TRANSFER_STATE_TOKEN_ID || key === TRANSFER_STATE_DEFER_BLOCKS_INFO;\n}\n/**\n * The name of the attribute that would be added to host component\n * nodes and contain a reference to a particular slot in transferred\n * state that contains the necessary hydration info for this component.\n */\nconst NGH_ATTR_NAME = 'ngh';\n/**\n * Marker used in a comment node to ensure hydration content integrity\n */\nconst SSR_CONTENT_INTEGRITY_MARKER = 'nghm';\n/**\n * Reference to a function that reads `ngh` attribute value from a given RNode\n * and retrieves hydration information from the TransferState using that value\n * as an index. Returns `null` by default, when hydration is not enabled.\n *\n * @param rNode Component's host element.\n * @param injector Injector that this component has access to.\n * @param isRootView Specifies whether we trying to read hydration info for the root view.\n */\nlet _retrieveHydrationInfoImpl = () => null;\nfunction retrieveHydrationInfoImpl(rNode, injector, isRootView = false) {\n    let nghAttrValue = rNode.getAttribute(NGH_ATTR_NAME);\n    if (nghAttrValue == null)\n        return null;\n    // For cases when a root component also acts as an anchor node for a ViewContainerRef\n    // (for example, when ViewContainerRef is injected in a root component), there is a need\n    // to serialize information about the component itself, as well as an LContainer that\n    // represents this ViewContainerRef. Effectively, we need to serialize 2 pieces of info:\n    // (1) hydration info for the root component itself and (2) hydration info for the\n    // ViewContainerRef instance (an LContainer). Each piece of information is included into\n    // the hydration data (in the TransferState object) separately, thus we end up with 2 ids.\n    // Since we only have 1 root element, we encode both bits of info into a single string:\n    // ids are separated by the `|` char (e.g. `10|25`, where `10` is the ngh for a component view\n    // and 25 is the `ngh` for a root view which holds LContainer).\n    const [componentViewNgh, rootViewNgh] = nghAttrValue.split('|');\n    nghAttrValue = isRootView ? rootViewNgh : componentViewNgh;\n    if (!nghAttrValue)\n        return null;\n    // We've read one of the ngh ids, keep the remaining one, so that\n    // we can set it back on the DOM element.\n    const rootNgh = rootViewNgh ? `|${rootViewNgh}` : '';\n    const remainingNgh = isRootView ? componentViewNgh : rootNgh;\n    let data = {};\n    // An element might have an empty `ngh` attribute value (e.g. `<comp ngh=\"\" />`),\n    // which means that no special annotations are required. Do not attempt to read\n    // from the TransferState in this case.\n    if (nghAttrValue !== '') {\n        const transferState = injector.get(TransferState, null, { optional: true });\n        if (transferState !== null) {\n            const nghData = transferState.get(NGH_DATA_KEY, []);\n            // The nghAttrValue is always a number referencing an index\n            // in the hydration TransferState data.\n            data = nghData[Number(nghAttrValue)];\n            // If the `ngh` attribute exists and has a non-empty value,\n            // the hydration info *must* be present in the TransferState.\n            // If there is no data for some reasons, this is an error.\n            ngDevMode && assertDefined(data, 'Unable to retrieve hydration info from the TransferState.');\n        }\n    }\n    const dehydratedView = {\n        data,\n        firstChild: rNode.firstChild ?? null,\n    };\n    if (isRootView) {\n        // If there is hydration info present for the root view, it means that there was\n        // a ViewContainerRef injected in the root component. The root component host element\n        // acted as an anchor node in this scenario. As a result, the DOM nodes that represent\n        // embedded views in this ViewContainerRef are located as siblings to the host node,\n        // i.e. `<app-root /><#VIEW1><#VIEW2>...<!--container-->`. In this case, the current\n        // node becomes the first child of this root view and the next sibling is the first\n        // element in the DOM segment.\n        dehydratedView.firstChild = rNode;\n        // We use `0` here, since this is the slot (right after the HEADER_OFFSET)\n        // where a component LView or an LContainer is located in a root LView.\n        setSegmentHead(dehydratedView, 0, rNode.nextSibling);\n    }\n    if (remainingNgh) {\n        // If we have only used one of the ngh ids, store the remaining one\n        // back on this RNode.\n        rNode.setAttribute(NGH_ATTR_NAME, remainingNgh);\n    }\n    else {\n        // The `ngh` attribute is cleared from the DOM node now\n        // that the data has been retrieved for all indices.\n        rNode.removeAttribute(NGH_ATTR_NAME);\n    }\n    // Note: don't check whether this node was claimed for hydration,\n    // because this node might've been previously claimed while processing\n    // template instructions.\n    ngDevMode && markRNodeAsClaimedByHydration(rNode, /* checkIfAlreadyClaimed */ false);\n    ngDevMode && ngDevMode.hydratedComponents++;\n    return dehydratedView;\n}\n/**\n * Sets the implementation for the `retrieveHydrationInfo` function.\n */\nfunction enableRetrieveHydrationInfoImpl() {\n    _retrieveHydrationInfoImpl = retrieveHydrationInfoImpl;\n}\n/**\n * Retrieves hydration info by reading the value from the `ngh` attribute\n * and accessing a corresponding slot in TransferState storage.\n */\nfunction retrieveHydrationInfo(rNode, injector, isRootView = false) {\n    return _retrieveHydrationInfoImpl(rNode, injector, isRootView);\n}\n/**\n * Retrieves the necessary object from a given ViewRef to serialize:\n *  - an LView for component views\n *  - an LContainer for cases when component acts as a ViewContainerRef anchor\n *  - `null` in case of an embedded view\n */\nfunction getLNodeForHydration(viewRef) {\n    // Reading an internal field from `ViewRef` instance.\n    let lView = viewRef._lView;\n    const tView = lView[TVIEW];\n    // A registered ViewRef might represent an instance of an\n    // embedded view, in which case we do not need to annotate it.\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        return null;\n    }\n    // Check if it's a root view and if so, retrieve component's\n    // LView from the first slot after the header.\n    if (isRootView(lView)) {\n        lView = lView[HEADER_OFFSET];\n    }\n    return lView;\n}\nfunction getTextNodeContent(node) {\n    return node.textContent?.replace(/\\s/gm, '');\n}\n/**\n * Restores text nodes and separators into the DOM that were lost during SSR\n * serialization. The hydration process replaces empty text nodes and text\n * nodes that are immediately adjacent to other text nodes with comment nodes\n * that this method filters on to restore those missing nodes that the\n * hydration process is expecting to be present.\n *\n * @param node The app's root HTML Element\n */\nfunction processTextNodeMarkersBeforeHydration(node) {\n    const doc = getDocument();\n    const commentNodesIterator = doc.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n        acceptNode(node) {\n            const content = getTextNodeContent(node);\n            const isTextNodeMarker = content === \"ngetn\" /* TextNodeMarker.EmptyNode */ || content === \"ngtns\" /* TextNodeMarker.Separator */;\n            return isTextNodeMarker ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n        },\n    });\n    let currentNode;\n    // We cannot modify the DOM while using the commentIterator,\n    // because it throws off the iterator state.\n    // So we collect all marker nodes first and then follow up with\n    // applying the changes to the DOM: either inserting an empty node\n    // or just removing the marker if it was used as a separator.\n    const nodes = [];\n    while ((currentNode = commentNodesIterator.nextNode())) {\n        nodes.push(currentNode);\n    }\n    for (const node of nodes) {\n        if (node.textContent === \"ngetn\" /* TextNodeMarker.EmptyNode */) {\n            node.replaceWith(doc.createTextNode(''));\n        }\n        else {\n            node.remove();\n        }\n    }\n}\n/**\n * Internal type that represents a claimed node.\n * Only used in dev mode.\n */\nvar HydrationStatus;\n(function (HydrationStatus) {\n    HydrationStatus[\"Hydrated\"] = \"hydrated\";\n    HydrationStatus[\"Skipped\"] = \"skipped\";\n    HydrationStatus[\"Mismatched\"] = \"mismatched\";\n})(HydrationStatus || (HydrationStatus = {}));\nconst HYDRATION_INFO_KEY = '__ngDebugHydrationInfo__';\nfunction patchHydrationInfo(node, info) {\n    node[HYDRATION_INFO_KEY] = info;\n}\nfunction readHydrationInfo(node) {\n    return node[HYDRATION_INFO_KEY] ?? null;\n}\n/**\n * Marks a node as \"claimed\" by hydration process.\n * This is needed to make assessments in tests whether\n * the hydration process handled all nodes.\n */\nfunction markRNodeAsClaimedByHydration(node, checkIfAlreadyClaimed = true) {\n    if (!ngDevMode) {\n        throw new Error('Calling `markRNodeAsClaimedByHydration` in prod mode ' +\n            'is not supported and likely a mistake.');\n    }\n    if (checkIfAlreadyClaimed && isRNodeClaimedForHydration(node)) {\n        throw new Error('Trying to claim a node, which was claimed already.');\n    }\n    patchHydrationInfo(node, { status: HydrationStatus.Hydrated });\n    ngDevMode.hydratedNodes++;\n}\nfunction markRNodeAsSkippedByHydration(node) {\n    if (!ngDevMode) {\n        throw new Error('Calling `markRNodeAsSkippedByHydration` in prod mode ' +\n            'is not supported and likely a mistake.');\n    }\n    patchHydrationInfo(node, { status: HydrationStatus.Skipped });\n    ngDevMode.componentsSkippedHydration++;\n}\nfunction countBlocksSkippedByHydration(injector) {\n    const transferState = injector.get(TransferState);\n    const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});\n    if (ngDevMode) {\n        ngDevMode.deferBlocksWithIncrementalHydration = Object.keys(nghDeferData).length;\n    }\n}\nfunction markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {\n    if (!ngDevMode) {\n        throw new Error('Calling `markRNodeAsMismatchedByHydration` in prod mode ' +\n            'is not supported and likely a mistake.');\n    }\n    // The RNode can be a standard HTMLElement (not an Angular component or directive)\n    // The devtools component tree only displays Angular components & directives\n    // Therefore we attach the debug info to the closest component/directive\n    while (node && !getComponent(node)) {\n        node = node?.parentNode;\n    }\n    if (node) {\n        patchHydrationInfo(node, {\n            status: HydrationStatus.Mismatched,\n            expectedNodeDetails,\n            actualNodeDetails,\n        });\n    }\n}\nfunction isRNodeClaimedForHydration(node) {\n    return readHydrationInfo(node)?.status === HydrationStatus.Hydrated;\n}\nfunction setSegmentHead(hydrationInfo, index, node) {\n    hydrationInfo.segmentHeads ??= {};\n    hydrationInfo.segmentHeads[index] = node;\n}\nfunction getSegmentHead(hydrationInfo, index) {\n    return hydrationInfo.segmentHeads?.[index] ?? null;\n}\nfunction isIncrementalHydrationEnabled(injector) {\n    return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {\n        optional: true,\n    });\n}\n/** Throws an error if the incremental hydration is not enabled */\nfunction assertIncrementalHydrationIsConfigured(injector) {\n    if (!isIncrementalHydrationEnabled(injector)) {\n        throw new RuntimeError(508 /* RuntimeErrorCode.MISCONFIGURED_INCREMENTAL_HYDRATION */, 'Angular has detected that some `@defer` blocks use `hydrate` triggers, ' +\n            'but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` ' +\n            'call is added as an argument for the `provideClientHydration()` function call ' +\n            'in your application config.');\n    }\n}\n/** Throws an error if the ssrUniqueId on the LDeferBlockDetails is not present  */\nfunction assertSsrIdDefined(ssrUniqueId) {\n    assertDefined(ssrUniqueId, 'Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present');\n}\n/**\n * Returns the size of an <ng-container>, using either the information\n * serialized in `ELEMENT_CONTAINERS` (element container size) or by\n * computing the sum of root nodes in all dehydrated views in a given\n * container (in case this `<ng-container>` was also used as a view\n * container host node, e.g. <ng-container *ngIf>).\n */\nfunction getNgContainerSize(hydrationInfo, index) {\n    const data = hydrationInfo.data;\n    let size = data[ELEMENT_CONTAINERS]?.[index] ?? null;\n    // If there is no serialized information available in the `ELEMENT_CONTAINERS` slot,\n    // check if we have info about view containers at this location (e.g.\n    // `<ng-container *ngIf>`) and use container size as a number of root nodes in this\n    // element container.\n    if (size === null && data[CONTAINERS]?.[index]) {\n        size = calcSerializedContainerSize(hydrationInfo, index);\n    }\n    return size;\n}\nfunction isSerializedElementContainer(hydrationInfo, index) {\n    return hydrationInfo.data[ELEMENT_CONTAINERS]?.[index] !== undefined;\n}\nfunction getSerializedContainerViews(hydrationInfo, index) {\n    return hydrationInfo.data[CONTAINERS]?.[index] ?? null;\n}\n/**\n * Computes the size of a serialized container (the number of root nodes)\n * by calculating the sum of root nodes in all dehydrated views in this container.\n */\nfunction calcSerializedContainerSize(hydrationInfo, index) {\n    const views = getSerializedContainerViews(hydrationInfo, index) ?? [];\n    let numNodes = 0;\n    for (let view of views) {\n        numNodes += view[NUM_ROOT_NODES] * (view[MULTIPLIER] ?? 1);\n    }\n    return numNodes;\n}\n/**\n * Attempt to initialize the `disconnectedNodes` field of the given\n * `DehydratedView`. Returns the initialized value.\n */\nfunction initDisconnectedNodes(hydrationInfo) {\n    // Check if we are processing disconnected info for the first time.\n    if (typeof hydrationInfo.disconnectedNodes === 'undefined') {\n        const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];\n        hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;\n    }\n    return hydrationInfo.disconnectedNodes;\n}\n/**\n * Checks whether a node is annotated as \"disconnected\", i.e. not present\n * in the DOM at serialization time. We should not attempt hydration for\n * such nodes and instead, use a regular \"creation mode\".\n */\nfunction isDisconnectedNode$1(hydrationInfo, index) {\n    // Check if we are processing disconnected info for the first time.\n    if (typeof hydrationInfo.disconnectedNodes === 'undefined') {\n        const nodeIds = hydrationInfo.data[DISCONNECTED_NODES];\n        hydrationInfo.disconnectedNodes = nodeIds ? new Set(nodeIds) : null;\n    }\n    return !!initDisconnectedNodes(hydrationInfo)?.has(index);\n}\n/**\n * Checks whether a node can be hydrated.\n * @param lView View in which the node instance is placed.\n * @param tNode Node to be checked.\n */\nfunction canHydrateNode(lView, tNode) {\n    const hydrationInfo = lView[HYDRATION];\n    return (hydrationInfo !== null &&\n        !isInSkipHydrationBlock$1() &&\n        !isDetachedByI18n(tNode) &&\n        !isDisconnectedNode$1(hydrationInfo, tNode.index - HEADER_OFFSET));\n}\n/**\n * Helper function to prepare text nodes for serialization by ensuring\n * that seperate logical text blocks in the DOM remain separate after\n * serialization.\n */\nfunction processTextNodeBeforeSerialization(context, node) {\n    // Handle cases where text nodes can be lost after DOM serialization:\n    //  1. When there is an *empty text node* in DOM: in this case, this\n    //     node would not make it into the serialized string and as a result,\n    //     this node wouldn't be created in a browser. This would result in\n    //     a mismatch during the hydration, where the runtime logic would expect\n    //     a text node to be present in live DOM, but no text node would exist.\n    //     Example: `<span>{{ name }}</span>` when the `name` is an empty string.\n    //     This would result in `<span></span>` string after serialization and\n    //     in a browser only the `span` element would be created. To resolve that,\n    //     an extra comment node is appended in place of an empty text node and\n    //     that special comment node is replaced with an empty text node *before*\n    //     hydration.\n    //  2. When there are 2 consecutive text nodes present in the DOM.\n    //     Example: `<div>Hello <ng-container *ngIf=\"true\">world</ng-container></div>`.\n    //     In this scenario, the live DOM would look like this:\n    //       <div>#text('Hello ') #text('world') #comment('container')</div>\n    //     Serialized string would look like this: `<div>Hello world<!--container--></div>`.\n    //     The live DOM in a browser after that would be:\n    //       <div>#text('Hello world') #comment('container')</div>\n    //     Notice how 2 text nodes are now \"merged\" into one. This would cause hydration\n    //     logic to fail, since it'd expect 2 text nodes being present, not one.\n    //     To fix this, we insert a special comment node in between those text nodes, so\n    //     serialized representation is: `<div>Hello <!--ngtns-->world<!--container--></div>`.\n    //     This forces browser to create 2 text nodes separated by a comment node.\n    //     Before running a hydration process, this special comment node is removed, so the\n    //     live DOM has exactly the same state as it was before serialization.\n    // Collect this node as required special annotation only when its\n    // contents is empty. Otherwise, such text node would be present on\n    // the client after server-side rendering and no special handling needed.\n    const el = node;\n    const corruptedTextNodes = context.corruptedTextNodes;\n    if (el.textContent === '') {\n        corruptedTextNodes.set(el, \"ngetn\" /* TextNodeMarker.EmptyNode */);\n    }\n    else if (el.nextSibling?.nodeType === Node.TEXT_NODE) {\n        corruptedTextNodes.set(el, \"ngtns\" /* TextNodeMarker.Separator */);\n    }\n}\nfunction convertHydrateTriggersToJsAction(triggers) {\n    let actionList = [];\n    if (triggers !== null) {\n        if (triggers.has(4 /* DeferBlockTrigger.Hover */)) {\n            actionList.push(...hoverEventNames);\n        }\n        if (triggers.has(3 /* DeferBlockTrigger.Interaction */)) {\n            actionList.push(...interactionEventNames);\n        }\n    }\n    return actionList;\n}\n/**\n * Builds a queue of blocks that need to be hydrated, looking up the\n * tree to the topmost defer block that exists in the tree that hasn't\n * been hydrated, but exists in the registry. This queue is in top down\n * hierarchical order as a list of defer block ids.\n * Note: This is utilizing serialized information to navigate up the tree\n */\nfunction getParentBlockHydrationQueue(deferBlockId, injector) {\n    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n    const transferState = injector.get(TransferState);\n    const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});\n    let isTopMostDeferBlock = false;\n    let currentBlockId = deferBlockId;\n    let parentBlockPromise = null;\n    const hydrationQueue = [];\n    while (!isTopMostDeferBlock && currentBlockId) {\n        ngDevMode &&\n            assertEqual(hydrationQueue.indexOf(currentBlockId), -1, 'Internal error: defer block hierarchy has a cycle.');\n        isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);\n        const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);\n        if (parentBlockPromise === null && hydratingParentBlock != null) {\n            parentBlockPromise = hydratingParentBlock.promise;\n            break;\n        }\n        hydrationQueue.unshift(currentBlockId);\n        currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];\n    }\n    return { parentBlockPromise, hydrationQueue };\n}\nfunction gatherDeferBlocksByJSActionAttribute(doc) {\n    const jsactionNodes = doc.body.querySelectorAll('[jsaction]');\n    const blockMap = new Set();\n    const eventTypes = [hoverEventNames.join(':;'), interactionEventNames.join(':;')].join('|');\n    for (let node of jsactionNodes) {\n        const attr = node.getAttribute('jsaction');\n        const blockId = node.getAttribute('ngb');\n        if (attr?.match(eventTypes) && blockId !== null) {\n            blockMap.add(node);\n        }\n    }\n    return blockMap;\n}\nfunction appendDeferBlocksToJSActionMap(doc, injector) {\n    const blockMap = gatherDeferBlocksByJSActionAttribute(doc);\n    const jsActionMap = injector.get(JSACTION_BLOCK_ELEMENT_MAP);\n    for (let rNode of blockMap) {\n        sharedMapFunction(rNode, jsActionMap);\n    }\n}\n/**\n * Retrieves defer block hydration information from the TransferState.\n *\n * @param injector Injector that this component has access to.\n */\nlet _retrieveDeferBlockDataImpl = () => {\n    return {};\n};\nfunction retrieveDeferBlockDataImpl(injector) {\n    const transferState = injector.get(TransferState, null, { optional: true });\n    if (transferState !== null) {\n        const nghDeferData = transferState.get(NGH_DEFER_BLOCKS_KEY, {});\n        ngDevMode &&\n            assertDefined(nghDeferData, 'Unable to retrieve defer block info from the TransferState.');\n        return nghDeferData;\n    }\n    return {};\n}\n/**\n * Sets the implementation for the `retrieveDeferBlockData` function.\n */\nfunction enableRetrieveDeferBlockDataImpl() {\n    _retrieveDeferBlockDataImpl = retrieveDeferBlockDataImpl;\n}\n/**\n * Retrieves defer block data from TransferState storage\n */\nfunction retrieveDeferBlockData(injector) {\n    return _retrieveDeferBlockDataImpl(injector);\n}\nfunction isTimerTrigger(triggerInfo) {\n    return typeof triggerInfo === 'object' && triggerInfo.trigger === 5 /* DeferBlockTrigger.Timer */;\n}\nfunction getHydrateTimerTrigger(blockData) {\n    const trigger = blockData[DEFER_HYDRATE_TRIGGERS]?.find((t) => isTimerTrigger(t));\n    return trigger?.delay ?? null;\n}\nfunction hasHydrateTrigger(blockData, trigger) {\n    return blockData[DEFER_HYDRATE_TRIGGERS]?.includes(trigger) ?? false;\n}\n/**\n * Creates a summary of the given serialized defer block, which is used later to properly initialize\n * specific triggers.\n */\nfunction createBlockSummary(blockInfo) {\n    return {\n        data: blockInfo,\n        hydrate: {\n            idle: hasHydrateTrigger(blockInfo, 0 /* DeferBlockTrigger.Idle */),\n            immediate: hasHydrateTrigger(blockInfo, 1 /* DeferBlockTrigger.Immediate */),\n            timer: getHydrateTimerTrigger(blockInfo),\n            viewport: hasHydrateTrigger(blockInfo, 2 /* DeferBlockTrigger.Viewport */),\n        },\n    };\n}\n/**\n * Processes all of the defer block data in the transfer state and creates a map of the summaries\n */\nfunction processBlockData(injector) {\n    const blockData = retrieveDeferBlockData(injector);\n    let blockDetails = new Map();\n    for (let blockId in blockData) {\n        blockDetails.set(blockId, createBlockSummary(blockData[blockId]));\n    }\n    return blockDetails;\n}\nfunction isSsrContentsIntegrity(node) {\n    return (!!node &&\n        node.nodeType === Node.COMMENT_NODE &&\n        node.textContent?.trim() === SSR_CONTENT_INTEGRITY_MARKER);\n}\nfunction skipTextNodes(node) {\n    // Ignore whitespace. Before the <body>, we shouldn't find text nodes that aren't whitespace.\n    while (node && node.nodeType === Node.TEXT_NODE) {\n        node = node.previousSibling;\n    }\n    return node;\n}\n/**\n * Verifies whether the DOM contains a special marker added during SSR time to make sure\n * there is no SSR'ed contents transformations happen after SSR is completed. Typically that\n * happens either by CDN or during the build process as an optimization to remove comment nodes.\n * Hydration process requires comment nodes produced by Angular to locate correct DOM segments.\n * When this special marker is *not* present - throw an error and do not proceed with hydration,\n * since it will not be able to function correctly.\n *\n * Note: this function is invoked only on the client, so it's safe to use DOM APIs.\n */\nfunction verifySsrContentsIntegrity(doc) {\n    for (const node of doc.body.childNodes) {\n        if (isSsrContentsIntegrity(node)) {\n            return;\n        }\n    }\n    // Check if the HTML parser may have moved the marker to just before the <body> tag,\n    // e.g. because the body tag was implicit and not present in the markup. An implicit body\n    // tag is unlikely to interfer with whitespace/comments inside of the app's root element.\n    // Case 1: Implicit body. Example:\n    //   <!doctype html><head><title>Hi</title></head><!--nghm--><app-root></app-root>\n    const beforeBody = skipTextNodes(doc.body.previousSibling);\n    if (isSsrContentsIntegrity(beforeBody)) {\n        return;\n    }\n    // Case 2: Implicit body & head. Example:\n    //   <!doctype html><head><title>Hi</title><!--nghm--><app-root></app-root>\n    let endOfHead = skipTextNodes(doc.head.lastChild);\n    if (isSsrContentsIntegrity(endOfHead)) {\n        return;\n    }\n    throw new RuntimeError(-507 /* RuntimeErrorCode.MISSING_SSR_CONTENT_INTEGRITY_MARKER */, typeof ngDevMode !== 'undefined' &&\n        ngDevMode &&\n        'Angular hydration logic detected that HTML content of this page was modified after it ' +\n            'was produced during server side rendering. Make sure that there are no optimizations ' +\n            'that remove comment nodes from HTML enabled on your CDN. Angular hydration ' +\n            'relies on HTML produced by the server, including whitespaces and comment nodes.');\n}\n\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView, lView) {\n    const contentQueries = tView.contentQueries;\n    if (contentQueries !== null) {\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            for (let i = 0; i < contentQueries.length; i += 2) {\n                const queryStartIdx = contentQueries[i];\n                const directiveDefIdx = contentQueries[i + 1];\n                if (directiveDefIdx !== -1) {\n                    const directiveDef = tView.data[directiveDefIdx];\n                    ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n                    ngDevMode &&\n                        assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n                    setCurrentQueryIndex(queryStartIdx);\n                    directiveDef.contentQueries(2 /* RenderFlags.Update */, lView[directiveDefIdx], directiveDefIdx);\n                }\n            }\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n    }\n}\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n    ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n    setCurrentQueryIndex(0);\n    const prevConsumer = setActiveConsumer(null);\n    try {\n        viewQueryFn(flags, component);\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\nfunction executeContentQueries(tView, tNode, lView) {\n    if (isContentQueryHost(tNode)) {\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            const start = tNode.directiveStart;\n            const end = tNode.directiveEnd;\n            for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n                const def = tView.data[directiveIndex];\n                if (def.contentQueries) {\n                    const directiveInstance = lView[directiveIndex];\n                    ngDevMode &&\n                        assertDefined(directiveIndex, 'Incorrect reference to a directive defining a content query');\n                    def.contentQueries(1 /* RenderFlags.Create */, directiveInstance, directiveIndex);\n                }\n            }\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n    }\n}\n\n/**\n * Defines the CSS styles encapsulation policies for the {@link /api/core/Component Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n    // https://github.com/angular/angular/issues/44119 for additional information.\n    /**\n     * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n     * component's host element and applying the same attribute to all the CSS selectors provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n     *\n     * This is the default option.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    /**\n     * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n     * to any HTML element of the application regardless of their host Component.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    /**\n     * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n     * a ShadowRoot for the component's host element which is then used to encapsulate\n     * all the Component's styling.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy$1;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy$1() {\n    if (policy$1 === undefined) {\n        policy$1 = null;\n        if (_global.trustedTypes) {\n            try {\n                policy$1 = _global.trustedTypes.createPolicy('angular', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy$1;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nfunction trustedHTMLFromString(html) {\n    return getPolicy$1()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\nfunction trustedScriptURLFromString(url) {\n    return getPolicy$1()?.createScriptURL(url) || url;\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy internally within\n * Angular specifically for bypassSecurityTrust* and custom sanitizers. It\n * lazily constructs the Trusted Types policy, providing helper utilities for\n * promoting strings to Trusted Types. When Trusted Types are not available,\n * strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (_global.trustedTypes) {\n            try {\n                policy = _global.trustedTypes.createPolicy('angular#unsafe-bypass', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedHTMLFromStringBypass(html) {\n    return getPolicy()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptFromStringBypass(script) {\n    return getPolicy()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptURLFromStringBypass(url) {\n    return getPolicy()?.createScriptURL(url) || url;\n}\n\nclass SafeValueImpl {\n    changingThisBreaksApplicationSecurity;\n    constructor(changingThisBreaksApplicationSecurity) {\n        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n    }\n    toString() {\n        return (`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n            ` (see ${XSS_SECURITY_URL})`);\n    }\n}\nclass SafeHtmlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"HTML\" /* BypassType.Html */;\n    }\n}\nclass SafeStyleImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Style\" /* BypassType.Style */;\n    }\n}\nclass SafeScriptImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Script\" /* BypassType.Script */;\n    }\n}\nclass SafeUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"URL\" /* BypassType.Url */;\n    }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"ResourceURL\" /* BypassType.ResourceUrl */;\n    }\n}\nfunction unwrapSafeValue(value) {\n    return value instanceof SafeValueImpl\n        ? value.changingThisBreaksApplicationSecurity\n        : value;\n}\nfunction allowSanitizationBypassAndThrow(value, type) {\n    const actualType = getSanitizationBypassType(value);\n    if (actualType != null && actualType !== type) {\n        // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n        if (actualType === \"ResourceURL\" /* BypassType.ResourceUrl */ && type === \"URL\" /* BypassType.Url */)\n            return true;\n        throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);\n    }\n    return actualType === type;\n}\nfunction getSanitizationBypassType(value) {\n    return (value instanceof SafeValueImpl && value.getTypeName()) || null;\n}\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n    return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n    return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustScript(trustedScript) {\n    return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n    return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n    return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\nfunction getInertBodyHelper(defaultDoc) {\n    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\nclass DOMParserHelper {\n    inertDocumentHelper;\n    constructor(inertDocumentHelper) {\n        this.inertDocumentHelper = inertDocumentHelper;\n    }\n    getInertBodyElement(html) {\n        // We add these extra elements to ensure that the rest of the content is parsed as expected\n        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n        // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n        // in `html` from consuming the otherwise explicit `</body>` tag.\n        html = '<body><remove></remove>' + html;\n        try {\n            const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), 'text/html').body;\n            if (body === null) {\n                // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n                // becomes available in the following tick of the JS engine. In that case we fall back to\n                // the `inertDocumentHelper` instead.\n                return this.inertDocumentHelper.getInertBodyElement(html);