{
  "version": 3,
  "sources": ["angular:jit:template:src\\app\\routes\\contact\\contact.html", "angular:jit:style:src\\app\\routes\\contact\\contact.css", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/fake-event-detection.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/keycodes/keycodes.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/platform/features/shadow-dom.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/platform/platform.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/platform/features/passive-listeners.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/coercion/number-property.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/coercion/element.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/input-modality/input-modality-detector.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/focus-monitor/focus-monitor.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/private/style-loader.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/private/visually-hidden/visually-hidden.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/coercion/array.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/layout/media-matcher.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/layout/breakpoints-observer.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/observers/observe-content.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/interactivity-checker/interactivity-checker.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/focus-trap/focus-trap.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/live-announcer/live-announcer-tokens.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/live-announcer/live-announcer.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/high-contrast-mode/high-contrast-mode-detector.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/a11y-module.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/aria-describer/aria-reference.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/aria-describer/aria-describer.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/key-manager/noop-tree-key-manager.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/focus-trap/configurable-focus-trap.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/focus-trap/event-listener-inert-strategy.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/focus-trap/focus-trap-inert-strategy.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/focus-trap/focus-trap-manager.ts", "../k8-fastbuild-ST-c646aa77115d/bin/src/cdk/a11y/focus-trap/configurable-focus-trap-factory.ts", "src/app/routes/contact/contact.ts", "src/app/routes/contact/contact.spec.ts"],
  "sourcesContent": ["<div>contact works!</div>\r\n<br>\r\n<br>\r\n<form class=\" border rounded-xl w-min mx-10 p-10 \" [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\" cdkTrapFocus>\r\n    <input class=\"border p-1\" type=\"text\" placeholder=\"enter name\" formControlName=\"userName\">\r\n    @if (profileForm.controls.userName.invalid && profileForm.controls.userName.touched) {\r\n    @if (profileForm.controls.userName.hasError('minlength')) {\r\n    <div class=\"text-red-500\">Name must be at least 6 characters long.</div>\r\n    }\r\n    }\r\n    <br><br>\r\n    <input class=\"border p-1\" type=\"text\" placeholder=\"enter email\" formControlName=\"email\">\r\n    @if (profileForm.controls.email.invalid && profileForm.controls.email.touched) {\r\n    @if (profileForm.controls.email.hasError('email')) {\r\n    <div class=\"text-red-500\">Enter valid email id.</div>\r\n    }\r\n    }\r\n    <br><br>\r\n    <input class=\"border p-1\" type=\"text\" placeholder=\"enter password\" formControlName=\"password\">\r\n    @if (profileForm.controls.password.invalid && profileForm.controls.password.touched) {\r\n    @if (profileForm.controls.password.hasError('minlength')) {\r\n    <div class=\"text-red-500\">Name must be at least 8 characters long.</div>\r\n    }\r\n    }\r\n    <br><br>\r\n\r\n\r\n    <div class=\" flex justify-between \">\r\n        <button (keyup.enter)=\"onSubmit()\" (click)=\"onSubmit()\" class=\"border p-2 cursor-pointer bg-green-500 text-black disabled:bg-gray-300 disabled:cursor-not-allowed\"\r\n            [disabled]=\"profileForm.invalid\" type=\"submit\">Submit</button>\r\n        <button [disabled]=\"profileForm.pristine\" (keyup.enter)=\"reset()\" (click)=\"reset()\" class=\"border p-2 cursor-pointer text-black bg-red-500 disabled:bg-gray-300 disabled:cursor-not-allowed\"\r\n            type=\"button\">Reset</button>\r\n    </div>\r\n\r\n    <br>\r\n</form>\r\n<br>\r\n@if (formValues) {\r\n<div>Submitted Form Data:</div>\r\n<div>Name: {{ formValues.userName }}</div>\r\n<div>Email: {{ formValues.email }}</div>\r\n<div>Password: {{ formValues.password }}</div>\r\n}\r\n<br>\r\n<br><br>\r\n\r\n\r\n<app-button1 [label]=\"'Go to HomePage'\"></app-button1>\r\n\r\n<div>\r\n    <app-button [label]=\"'shared button contact'\"></app-button>\r\n</div>\r\n\r\n<br><br>\r\n\r\n<app-section-1 (messageEvent)=\"receiveMessage($event)\"></app-section-1>\r\n\r\n<div>Message Received: <strong>{{ receivedMessage }}</strong></div>", "/* src/app/routes/contact/contact.css */\n/*# sourceMappingURL=contact.css.map */\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nexport function isFakeMousedownFromScreenReader(event: MouseEvent): boolean {\n  // Some screen readers will dispatch a fake `mousedown` event when pressing enter or space on\n  // a clickable element. We can distinguish these events when `event.buttons` is zero, or\n  // `event.detail` is zero depending on the browser:\n  // - `event.buttons` works on Firefox, but fails on Chrome.\n  // - `detail` works on Chrome, but fails on Firefox.\n  return event.buttons === 0 || event.detail === 0;\n}\n\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nexport function isFakeTouchstartFromScreenReader(event: TouchEvent): boolean {\n  const touch: Touch | undefined =\n    (event.touches && event.touches[0]) || (event.changedTouches && event.changedTouches[0]);\n\n  // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n  // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n  // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n  // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n  return (\n    !!touch &&\n    touch.identifier === -1 &&\n    (touch.radiusX == null || touch.radiusX === 1) &&\n    (touch.radiusY == null || touch.radiusY === 1)\n  );\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport const MAC_ENTER = 3;\nexport const BACKSPACE = 8;\nexport const TAB = 9;\nexport const NUM_CENTER = 12;\nexport const ENTER = 13;\nexport const SHIFT = 16;\nexport const CONTROL = 17;\nexport const ALT = 18;\nexport const PAUSE = 19;\nexport const CAPS_LOCK = 20;\nexport const ESCAPE = 27;\nexport const SPACE = 32;\nexport const PAGE_UP = 33;\nexport const PAGE_DOWN = 34;\nexport const END = 35;\nexport const HOME = 36;\nexport const LEFT_ARROW = 37;\nexport const UP_ARROW = 38;\nexport const RIGHT_ARROW = 39;\nexport const DOWN_ARROW = 40;\nexport const PLUS_SIGN = 43;\nexport const PRINT_SCREEN = 44;\nexport const INSERT = 45;\nexport const DELETE = 46;\nexport const ZERO = 48;\nexport const ONE = 49;\nexport const TWO = 50;\nexport const THREE = 51;\nexport const FOUR = 52;\nexport const FIVE = 53;\nexport const SIX = 54;\nexport const SEVEN = 55;\nexport const EIGHT = 56;\nexport const NINE = 57;\nexport const FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nexport const FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nexport const QUESTION_MARK = 63;\nexport const AT_SIGN = 64;\nexport const A = 65;\nexport const B = 66;\nexport const C = 67;\nexport const D = 68;\nexport const E = 69;\nexport const F = 70;\nexport const G = 71;\nexport const H = 72;\nexport const I = 73;\nexport const J = 74;\nexport const K = 75;\nexport const L = 76;\nexport const M = 77;\nexport const N = 78;\nexport const O = 79;\nexport const P = 80;\nexport const Q = 81;\nexport const R = 82;\nexport const S = 83;\nexport const T = 84;\nexport const U = 85;\nexport const V = 86;\nexport const W = 87;\nexport const X = 88;\nexport const Y = 89;\nexport const Z = 90;\nexport const META = 91; // WIN_KEY_LEFT\nexport const MAC_WK_CMD_LEFT = 91;\nexport const MAC_WK_CMD_RIGHT = 93;\nexport const CONTEXT_MENU = 93;\nexport const NUMPAD_ZERO = 96;\nexport const NUMPAD_ONE = 97;\nexport const NUMPAD_TWO = 98;\nexport const NUMPAD_THREE = 99;\nexport const NUMPAD_FOUR = 100;\nexport const NUMPAD_FIVE = 101;\nexport const NUMPAD_SIX = 102;\nexport const NUMPAD_SEVEN = 103;\nexport const NUMPAD_EIGHT = 104;\nexport const NUMPAD_NINE = 105;\nexport const NUMPAD_MULTIPLY = 106;\nexport const NUMPAD_PLUS = 107;\nexport const NUMPAD_MINUS = 109;\nexport const NUMPAD_PERIOD = 110;\nexport const NUMPAD_DIVIDE = 111;\nexport const F1 = 112;\nexport const F2 = 113;\nexport const F3 = 114;\nexport const F4 = 115;\nexport const F5 = 116;\nexport const F6 = 117;\nexport const F7 = 118;\nexport const F8 = 119;\nexport const F9 = 120;\nexport const F10 = 121;\nexport const F11 = 122;\nexport const F12 = 123;\nexport const NUM_LOCK = 144;\nexport const SCROLL_LOCK = 145;\nexport const FIRST_MEDIA = 166;\nexport const FF_MINUS = 173;\nexport const MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nexport const VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nexport const VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nexport const FF_MUTE = 181;\nexport const FF_VOLUME_DOWN = 182;\nexport const LAST_MEDIA = 183;\nexport const FF_VOLUME_UP = 183;\nexport const SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nexport const EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nexport const COMMA = 188;\nexport const DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nexport const PERIOD = 190;\nexport const SLASH = 191;\nexport const APOSTROPHE = 192;\nexport const TILDE = 192;\nexport const OPEN_SQUARE_BRACKET = 219;\nexport const BACKSLASH = 220;\nexport const CLOSE_SQUARE_BRACKET = 221;\nexport const SINGLE_QUOTE = 222;\nexport const MAC_META = 224;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nlet shadowDomIsSupported: boolean;\n\n/** Checks whether the user's browser support Shadow DOM. */\nexport function _supportsShadowDom(): boolean {\n  if (shadowDomIsSupported == null) {\n    const head = typeof document !== 'undefined' ? document.head : null;\n    shadowDomIsSupported = !!(head && ((head as any).createShadowRoot || head.attachShadow));\n  }\n\n  return shadowDomIsSupported;\n}\n\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nexport function _getShadowRoot(element: HTMLElement): ShadowRoot | null {\n  if (_supportsShadowDom()) {\n    const rootNode = element.getRootNode ? element.getRootNode() : null;\n\n    // Note that this should be caught by `_supportsShadowDom`, but some\n    // teams have been able to hit this code path on unsupported browsers.\n    if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n      return rootNode;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nexport function _getFocusedElementPierceShadowDom(): HTMLElement | null {\n  let activeElement =\n    typeof document !== 'undefined' && document\n      ? (document.activeElement as HTMLElement | null)\n      : null;\n\n  while (activeElement && activeElement.shadowRoot) {\n    const newActiveElement = activeElement.shadowRoot.activeElement as HTMLElement | null;\n    if (newActiveElement === activeElement) {\n      break;\n    } else {\n      activeElement = newActiveElement;\n    }\n  }\n\n  return activeElement;\n}\n\n/** Gets the target of an event while accounting for Shadow DOM. */\nexport function _getEventTarget<T extends EventTarget>(event: Event): T | null {\n  // If an event is bound outside the Shadow DOM, the `event.target` will\n  // point to the shadow root so we have to use `composedPath` instead.\n  return (event.composedPath ? event.composedPath()[0] : event.target) as T | null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable, PLATFORM_ID} from '@angular/core';\nimport {isPlatformBrowser} from '@angular/common';\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nlet hasV8BreakIterator: boolean;\n\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n  hasV8BreakIterator = typeof Intl !== 'undefined' && (Intl as any).v8BreakIterator;\n} catch {\n  hasV8BreakIterator = false;\n}\n\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\n@Injectable({providedIn: 'root'})\nexport class Platform {\n  private _platformId = inject(PLATFORM_ID);\n\n  // We want to use the Angular platform check because if the Document is shimmed\n  // without the navigator, the following checks will fail. This is preferred because\n  // sometimes the Document may be shimmed without the user's knowledge or intention\n  /** Whether the Angular application is being rendered in the browser. */\n  isBrowser: boolean = this._platformId\n    ? isPlatformBrowser(this._platformId)\n    : typeof document === 'object' && !!document;\n\n  /** Whether the current browser is Microsoft Edge. */\n  EDGE: boolean = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n\n  /** Whether the current rendering engine is Microsoft Trident. */\n  TRIDENT: boolean = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n\n  // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n  /** Whether the current rendering engine is Blink. */\n  BLINK: boolean =\n    this.isBrowser &&\n    !!((window as any).chrome || hasV8BreakIterator) &&\n    typeof CSS !== 'undefined' &&\n    !this.EDGE &&\n    !this.TRIDENT;\n\n  // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n  // ensure that Webkit runs standalone and is not used as another engine's base.\n  /** Whether the current rendering engine is WebKit. */\n  WEBKIT: boolean =\n    this.isBrowser &&\n    /AppleWebKit/i.test(navigator.userAgent) &&\n    !this.BLINK &&\n    !this.EDGE &&\n    !this.TRIDENT;\n\n  /** Whether the current platform is Apple iOS. */\n  IOS: boolean =\n    this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n\n  // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n  // them self as Gecko-like browsers and modify the userAgent's according to that.\n  // Since we only cover one explicit Firefox case, we can simply check for Firefox\n  // instead of having an unstable check for Gecko.\n  /** Whether the current browser is Firefox. */\n  FIREFOX: boolean = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n\n  /** Whether the current platform is Android. */\n  // Trident on mobile adds the android platform to the userAgent to trick detections.\n  ANDROID: boolean = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n\n  // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n  // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n  // Safari browser should also use Webkit as its layout engine.\n  /** Whether the current browser is Safari. */\n  SAFARI: boolean = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n\n  /** Backwards-compatible constructor. */\n  constructor(..._args: unknown[]);\n\n  constructor() {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents: boolean;\n\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport function supportsPassiveEventListeners(): boolean {\n  if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n    try {\n      window.addEventListener(\n        'test',\n        null!,\n        Object.defineProperty({}, 'passive', {\n          get: () => (supportsPassiveEvents = true),\n        }),\n      );\n    } finally {\n      supportsPassiveEvents = supportsPassiveEvents || false;\n    }\n  }\n\n  return supportsPassiveEvents;\n}\n\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nexport function normalizePassiveListenerOptions(\n  options: AddEventListenerOptions,\n): AddEventListenerOptions | boolean {\n  return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Type describing the allowed values for a number input\n * @docs-private\n */\nexport type NumberInput = string | number | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a number. */\nexport function coerceNumberProperty(value: any): number;\nexport function coerceNumberProperty<D>(value: any, fallback: D): number | D;\nexport function coerceNumberProperty(value: any, fallbackValue = 0) {\n  if (_isNumberValue(value)) {\n    return Number(value);\n  }\n  return arguments.length === 2 ? fallbackValue : 0;\n}\n\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nexport function _isNumberValue(value: any): boolean {\n  // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n  // and other non-number values as NaN, where Number just uses 0) but it considers the string\n  // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n  return !isNaN(parseFloat(value as any)) && !isNaN(Number(value));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ElementRef} from '@angular/core';\n\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nexport function coerceElement<T>(elementOrRef: ElementRef<T> | T): T {\n  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ALT, CONTROL, MAC_META, META, SHIFT} from '../../keycodes';\nimport {\n  Injectable,\n  InjectionToken,\n  OnDestroy,\n  NgZone,\n  inject,\n  RendererFactory2,\n  DOCUMENT,\n} from '@angular/core';\nimport {Platform, _getEventTarget} from '../../platform';\n\nimport {BehaviorSubject, Observable} from 'rxjs';\nimport {distinctUntilChanged, skip} from 'rxjs/operators';\nimport {\n  isFakeMousedownFromScreenReader,\n  isFakeTouchstartFromScreenReader,\n} from '../fake-event-detection';\n\n/**\n * The input modalities detected by this service. Null is used if the input modality is unknown.\n */\nexport type InputModality = 'keyboard' | 'mouse' | 'touch' | null;\n\n/** Options to configure the behavior of the InputModalityDetector. */\nexport interface InputModalityDetectorOptions {\n  /** Keys to ignore when detecting keyboard input modality. */\n  ignoreKeys?: number[];\n}\n\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nexport const INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken<InputModalityDetectorOptions>(\n  'cdk-input-modality-detector-options',\n);\n\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nexport const INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS: InputModalityDetectorOptions = {\n  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],\n};\n\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nexport const TOUCH_BUFFER_MS = 650;\n\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = {\n  passive: true,\n  capture: true,\n};\n\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\n@Injectable({providedIn: 'root'})\nexport class InputModalityDetector implements OnDestroy {\n  private readonly _platform = inject(Platform);\n  private readonly _listenerCleanups: (() => void)[] | undefined;\n\n  /** Emits whenever an input modality is detected. */\n  readonly modalityDetected: Observable<InputModality>;\n\n  /** Emits when the input modality changes. */\n  readonly modalityChanged: Observable<InputModality>;\n\n  /** The most recently detected input modality. */\n  get mostRecentModality(): InputModality {\n    return this._modality.value;\n  }\n\n  /**\n   * The most recently detected input modality event target. Is null if no input modality has been\n   * detected or if the associated event target is null for some unknown reason.\n   */\n  _mostRecentTarget: HTMLElement | null = null;\n\n  /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n  private readonly _modality = new BehaviorSubject<InputModality>(null);\n\n  /** Options for this InputModalityDetector. */\n  private readonly _options: InputModalityDetectorOptions;\n\n  /**\n   * The timestamp of the last touch input modality. Used to determine whether mousedown events\n   * should be attributed to mouse or touch.\n   */\n  private _lastTouchMs = 0;\n\n  /**\n   * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n   * bound.\n   */\n  private _onKeydown = (event: KeyboardEvent) => {\n    // If this is one of the keys we should ignore, then ignore it and don't update the input\n    // modality to keyboard.\n    if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n      return;\n    }\n\n    this._modality.next('keyboard');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n\n  /**\n   * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n   * gets bound.\n   */\n  private _onMousedown = (event: MouseEvent) => {\n    // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n    // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n    // after the previous touch event.\n    if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n      return;\n    }\n\n    // Fake mousedown events are fired by some screen readers when controls are activated by the\n    // screen reader. Attribute them to keyboard input modality.\n    this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n\n  /**\n   * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n   * gets bound.\n   */\n  private _onTouchstart = (event: TouchEvent) => {\n    // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n    // events are fired. Again, attribute to keyboard input modality.\n    if (isFakeTouchstartFromScreenReader(event)) {\n      this._modality.next('keyboard');\n      return;\n    }\n\n    // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n    // triggered via mouse vs touch.\n    this._lastTouchMs = Date.now();\n\n    this._modality.next('touch');\n    this._mostRecentTarget = _getEventTarget(event);\n  };\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const ngZone = inject(NgZone);\n    const document = inject<Document>(DOCUMENT);\n    const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, {optional: true});\n\n    this._options = {\n      ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n      ...options,\n    };\n\n    // Skip the first emission as it's null.\n    this.modalityDetected = this._modality.pipe(skip(1));\n    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n\n    // If we're not in a browser, this service should do nothing, as there's no relevant input\n    // modality to detect.\n    if (this._platform.isBrowser) {\n      const renderer = inject(RendererFactory2).createRenderer(null, null);\n\n      this._listenerCleanups = ngZone.runOutsideAngular(() => {\n        return [\n          renderer.listen(document, 'keydown', this._onKeydown, modalityEventListenerOptions),\n          renderer.listen(document, 'mousedown', this._onMousedown, modalityEventListenerOptions),\n          renderer.listen(document, 'touchstart', this._onTouchstart, modalityEventListenerOptions),\n        ];\n      });\n    }\n  }\n\n  ngOnDestroy() {\n    this._modality.complete();\n    this._listenerCleanups?.forEach(cleanup => cleanup());\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Platform,\n  normalizePassiveListenerOptions,\n  _getShadowRoot,\n  _getEventTarget,\n} from '../../platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  InjectionToken,\n  NgZone,\n  OnDestroy,\n  Output,\n  AfterViewInit,\n  inject,\n  DOCUMENT,\n} from '@angular/core';\nimport {Observable, of as observableOf, Subject, Subscription} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {coerceElement} from '../../coercion';\n\nimport {InputModalityDetector, TOUCH_BUFFER_MS} from '../input-modality/input-modality-detector';\n\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\n\n/**\n * Corresponds to the options that can be passed to the native `focus` event.\n * via https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n */\nexport interface FocusOptions {\n  /** Whether the browser should scroll to the element when it is focused. */\n  preventScroll?: boolean;\n}\n\n/** Detection mode used for attributing the origin of a focus event. */\nexport enum FocusMonitorDetectionMode {\n  /**\n   * Any mousedown, keydown, or touchstart event that happened in the previous\n   * tick or the current tick will be used to assign a focus event's origin (to\n   * either mouse, keyboard, or touch). This is the default option.\n   */\n  IMMEDIATE,\n  /**\n   * A focus event's origin is always attributed to the last corresponding\n   * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\n   */\n  EVENTUAL,\n}\n\n/** Injectable service-level options for FocusMonitor. */\nexport interface FocusMonitorOptions {\n  detectionMode?: FocusMonitorDetectionMode;\n}\n\n/** InjectionToken for FocusMonitorOptions. */\nexport const FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken<FocusMonitorOptions>(\n  'cdk-focus-monitor-default-options',\n);\n\ntype MonitoredElementInfo = {\n  checkChildren: boolean;\n  readonly subject: Subject<FocusOrigin>;\n  rootNode: HTMLElement | ShadowRoot | Document;\n};\n\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n  passive: true,\n  capture: true,\n});\n\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\n@Injectable({providedIn: 'root'})\nexport class FocusMonitor implements OnDestroy {\n  private _ngZone = inject(NgZone);\n  private _platform = inject(Platform);\n  private readonly _inputModalityDetector = inject(InputModalityDetector);\n\n  /** The focus origin that the next focus event is a result of. */\n  private _origin: FocusOrigin = null;\n\n  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n  private _lastFocusOrigin: FocusOrigin;\n\n  /** Whether the window has just been focused. */\n  private _windowFocused = false;\n\n  /** The timeout id of the window focus timeout. */\n  private _windowFocusTimeoutId: ReturnType<typeof setTimeout>;\n\n  /** The timeout id of the origin clearing timeout. */\n  private _originTimeoutId: ReturnType<typeof setTimeout>;\n\n  /**\n   * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n   * focus events to touch interactions requires special logic.\n   */\n  private _originFromTouchInteraction = false;\n\n  /** Map of elements being monitored to their info. */\n  private _elementInfo = new Map<HTMLElement, MonitoredElementInfo>();\n\n  /** The number of elements currently being monitored. */\n  private _monitoredElementCount = 0;\n\n  /**\n   * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n   * as well as the number of monitored elements that they contain. We have to treat focus/blur\n   * handlers differently from the rest of the events, because the browser won't emit events\n   * to the document when focus moves inside of a shadow root.\n   */\n  private _rootNodeFocusListenerCount = new Map<HTMLElement | Document | ShadowRoot, number>();\n\n  /**\n   * The specified detection mode, used for attributing the origin of a focus\n   * event.\n   */\n  private readonly _detectionMode: FocusMonitorDetectionMode;\n\n  /**\n   * Event listener for `focus` events on the window.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  private _windowFocusListener = () => {\n    // Make a note of when the window regains focus, so we can\n    // restore the origin info for the focused element.\n    this._windowFocused = true;\n    this._windowFocusTimeoutId = setTimeout(() => (this._windowFocused = false));\n  };\n\n  /** Used to reference correct document/window */\n  protected _document = inject(DOCUMENT);\n\n  /** Subject for stopping our InputModalityDetector subscription. */\n  private readonly _stopInputModalityDetector = new Subject<void>();\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const options = inject<FocusMonitorOptions | null>(FOCUS_MONITOR_DEFAULT_OPTIONS, {\n      optional: true,\n    });\n\n    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;\n  }\n  /**\n   * Event listener for `focus` and 'blur' events on the document.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  private _rootNodeFocusAndBlurListener = (event: Event) => {\n    const target = _getEventTarget<HTMLElement>(event);\n\n    // We need to walk up the ancestor chain in order to support `checkChildren`.\n    for (let element = target; element; element = element.parentElement) {\n      if (event.type === 'focus') {\n        this._onFocus(event as FocusEvent, element);\n      } else {\n        this._onBlur(event as FocusEvent, element);\n      }\n    }\n  };\n\n  /**\n   * Monitors focus on an element and applies appropriate CSS classes.\n   * @param element The element to monitor\n   * @param checkChildren Whether to count the element as focused when its children are focused.\n   * @returns An observable that emits when the focus state of the element changes.\n   *     When the element is blurred, null will be emitted.\n   */\n  monitor(element: HTMLElement, checkChildren?: boolean): Observable<FocusOrigin>;\n\n  /**\n   * Monitors focus on an element and applies appropriate CSS classes.\n   * @param element The element to monitor\n   * @param checkChildren Whether to count the element as focused when its children are focused.\n   * @returns An observable that emits when the focus state of the element changes.\n   *     When the element is blurred, null will be emitted.\n   */\n  monitor(element: ElementRef<HTMLElement>, checkChildren?: boolean): Observable<FocusOrigin>;\n\n  monitor(\n    element: HTMLElement | ElementRef<HTMLElement>,\n    checkChildren: boolean = false,\n  ): Observable<FocusOrigin> {\n    const nativeElement = coerceElement(element);\n\n    // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n      // Note: we don't want the observable to emit at all so we don't pass any parameters.\n      return observableOf();\n    }\n\n    // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n    // the shadow root, rather than the `document`, because the browser won't emit focus events\n    // to the `document`, if focus is moving within the same shadow root.\n    const rootNode = _getShadowRoot(nativeElement) || this._document;\n    const cachedInfo = this._elementInfo.get(nativeElement);\n\n    // Check if we're already monitoring this element.\n    if (cachedInfo) {\n      if (checkChildren) {\n        // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n        // observers into ones that behave as if `checkChildren` was turned on. We need a more\n        // robust solution.\n        cachedInfo.checkChildren = true;\n      }\n\n      return cachedInfo.subject;\n    }\n\n    // Create monitored element info.\n    const info: MonitoredElementInfo = {\n      checkChildren: checkChildren,\n      subject: new Subject<FocusOrigin>(),\n      rootNode,\n    };\n    this._elementInfo.set(nativeElement, info);\n    this._registerGlobalListeners(info);\n\n    return info.subject;\n  }\n\n  /**\n   * Stops monitoring an element and removes all focus classes.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: HTMLElement): void;\n\n  /**\n   * Stops monitoring an element and removes all focus classes.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<HTMLElement>): void;\n\n  stopMonitoring(element: HTMLElement | ElementRef<HTMLElement>): void {\n    const nativeElement = coerceElement(element);\n    const elementInfo = this._elementInfo.get(nativeElement);\n\n    if (elementInfo) {\n      elementInfo.subject.complete();\n\n      this._setClasses(nativeElement);\n      this._elementInfo.delete(nativeElement);\n      this._removeGlobalListeners(elementInfo);\n    }\n  }\n\n  /**\n   * Focuses the element via the specified focus origin.\n   * @param element Element to focus.\n   * @param origin Focus origin.\n   * @param options Options that can be used to configure the focus behavior.\n   */\n  focusVia(element: HTMLElement, origin: FocusOrigin, options?: FocusOptions): void;\n\n  /**\n   * Focuses the element via the specified focus origin.\n   * @param element Element to focus.\n   * @param origin Focus origin.\n   * @param options Options that can be used to configure the focus behavior.\n   */\n  focusVia(element: ElementRef<HTMLElement>, origin: FocusOrigin, options?: FocusOptions): void;\n\n  focusVia(\n    element: HTMLElement | ElementRef<HTMLElement>,\n    origin: FocusOrigin,\n    options?: FocusOptions,\n  ): void {\n    const nativeElement = coerceElement(element);\n    const focusedElement = this._document.activeElement;\n\n    // If the element is focused already, calling `focus` again won't trigger the event listener\n    // which means that the focus classes won't be updated. If that's the case, update the classes\n    // directly without waiting for an event.\n    if (nativeElement === focusedElement) {\n      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) =>\n        this._originChanged(currentElement, origin, info),\n      );\n    } else {\n      this._setOrigin(origin);\n\n      // `focus` isn't available on the server\n      if (typeof nativeElement.focus === 'function') {\n        nativeElement.focus(options);\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    return this._document.defaultView || window;\n  }\n\n  private _getFocusOrigin(focusEventTarget: HTMLElement | null): FocusOrigin {\n    if (this._origin) {\n      // If the origin was realized via a touch interaction, we need to perform additional checks\n      // to determine whether the focus origin should be attributed to touch or program.\n      if (this._originFromTouchInteraction) {\n        return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n      } else {\n        return this._origin;\n      }\n    }\n\n    // If the window has just regained focus, we can restore the most recent origin from before the\n    // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n    // focus. This typically means one of two things happened:\n    //\n    // 1) The element was programmatically focused, or\n    // 2) The element was focused via screen reader navigation (which generally doesn't fire\n    //    events).\n    //\n    // Because we can't distinguish between these two cases, we default to setting `program`.\n    if (this._windowFocused && this._lastFocusOrigin) {\n      return this._lastFocusOrigin;\n    }\n\n    // If the interaction is coming from an input label, we consider it a mouse interactions.\n    // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n    // our detection, because all our assumptions are for `mousedown`. We need to handle this\n    // special case, because it's very common for checkboxes and radio buttons.\n    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n      return 'mouse';\n    }\n\n    return 'program';\n  }\n\n  /**\n   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n   * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n   * event was directly caused by the touch interaction or (2) the focus event was caused by a\n   * subsequent programmatic focus call triggered by the touch interaction.\n   * @param focusEventTarget The target of the focus event under examination.\n   */\n  private _shouldBeAttributedToTouch(focusEventTarget: HTMLElement | null): boolean {\n    // Please note that this check is not perfect. Consider the following edge case:\n    //\n    // <div #parent tabindex=\"0\">\n    //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n    // </div>\n    //\n    // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n    // #child, #parent is programmatically focused. This code will attribute the focus to touch\n    // instead of program. This is a relatively minor edge-case that can be worked around by using\n    // focusVia(parent, 'program') to focus #parent.\n    return (\n      this._detectionMode === FocusMonitorDetectionMode.EVENTUAL ||\n      !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget)\n    );\n  }\n\n  /**\n   * Sets the focus classes on the element based on the given focus origin.\n   * @param element The element to update the classes on.\n   * @param origin The focus origin.\n   */\n  private _setClasses(element: HTMLElement, origin?: FocusOrigin): void {\n    element.classList.toggle('cdk-focused', !!origin);\n    element.classList.toggle('cdk-touch-focused', origin === 'touch');\n    element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n    element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n    element.classList.toggle('cdk-program-focused', origin === 'program');\n  }\n\n  /**\n   * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n   * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n   * the origin being set.\n   * @param origin The origin to set.\n   * @param isFromInteraction Whether we are setting the origin from an interaction event.\n   */\n  private _setOrigin(origin: FocusOrigin, isFromInteraction = false): void {\n    this._ngZone.runOutsideAngular(() => {\n      this._origin = origin;\n      this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n\n      // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n      // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n      // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n      // a touch event because when a touch event is fired, the associated focus event isn't yet in\n      // the event queue. Before doing so, clear any pending timeouts.\n      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {\n        clearTimeout(this._originTimeoutId);\n        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n        this._originTimeoutId = setTimeout(() => (this._origin = null), ms);\n      }\n    });\n  }\n\n  /**\n   * Handles focus events on a registered element.\n   * @param event The focus event.\n   * @param element The monitored element.\n   */\n  private _onFocus(event: FocusEvent, element: HTMLElement) {\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n    // focus event affecting the monitored element. If we want to use the origin of the first event\n    // instead we should check for the cdk-focused class here and return if the element already has\n    // it. (This only matters for elements that have includesChildren = true).\n\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\n    // monitored element itself.\n    const elementInfo = this._elementInfo.get(element);\n    const focusEventTarget = _getEventTarget<HTMLElement>(event);\n    if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\n      return;\n    }\n\n    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n  }\n\n  /**\n   * Handles blur events on a registered element.\n   * @param event The blur event.\n   * @param element The monitored element.\n   */\n  _onBlur(event: FocusEvent, element: HTMLElement) {\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n    // order to focus another child of the monitored element.\n    const elementInfo = this._elementInfo.get(element);\n\n    if (\n      !elementInfo ||\n      (elementInfo.checkChildren &&\n        event.relatedTarget instanceof Node &&\n        element.contains(event.relatedTarget))\n    ) {\n      return;\n    }\n\n    this._setClasses(element);\n    this._emitOrigin(elementInfo, null);\n  }\n\n  private _emitOrigin(info: MonitoredElementInfo, origin: FocusOrigin) {\n    if (info.subject.observers.length) {\n      this._ngZone.run(() => info.subject.next(origin));\n    }\n  }\n\n  private _registerGlobalListeners(elementInfo: MonitoredElementInfo) {\n    if (!this._platform.isBrowser) {\n      return;\n    }\n\n    const rootNode = elementInfo.rootNode;\n    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n\n    if (!rootNodeFocusListeners) {\n      this._ngZone.runOutsideAngular(() => {\n        rootNode.addEventListener(\n          'focus',\n          this._rootNodeFocusAndBlurListener,\n          captureEventListenerOptions,\n        );\n        rootNode.addEventListener(\n          'blur',\n          this._rootNodeFocusAndBlurListener,\n          captureEventListenerOptions,\n        );\n      });\n    }\n\n    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n\n    // Register global listeners when first element is monitored.\n    if (++this._monitoredElementCount === 1) {\n      // Note: we listen to events in the capture phase so we\n      // can detect them even if the user stops propagation.\n      this._ngZone.runOutsideAngular(() => {\n        const window = this._getWindow();\n        window.addEventListener('focus', this._windowFocusListener);\n      });\n\n      // The InputModalityDetector is also just a collection of global listeners.\n      this._inputModalityDetector.modalityDetected\n        .pipe(takeUntil(this._stopInputModalityDetector))\n        .subscribe(modality => {\n          this._setOrigin(modality, true /* isFromInteraction */);\n        });\n    }\n  }\n\n  private _removeGlobalListeners(elementInfo: MonitoredElementInfo) {\n    const rootNode = elementInfo.rootNode;\n\n    if (this._rootNodeFocusListenerCount.has(rootNode)) {\n      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode)!;\n\n      if (rootNodeFocusListeners > 1) {\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n      } else {\n        rootNode.removeEventListener(\n          'focus',\n          this._rootNodeFocusAndBlurListener,\n          captureEventListenerOptions,\n        );\n        rootNode.removeEventListener(\n          'blur',\n          this._rootNodeFocusAndBlurListener,\n          captureEventListenerOptions,\n        );\n        this._rootNodeFocusListenerCount.delete(rootNode);\n      }\n    }\n\n    // Unregister global listeners when last element is unmonitored.\n    if (!--this._monitoredElementCount) {\n      const window = this._getWindow();\n      window.removeEventListener('focus', this._windowFocusListener);\n\n      // Equivalently, stop our InputModalityDetector subscription.\n      this._stopInputModalityDetector.next();\n\n      // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n      clearTimeout(this._windowFocusTimeoutId);\n      clearTimeout(this._originTimeoutId);\n    }\n  }\n\n  /** Updates all the state on an element once its focus origin has changed. */\n  private _originChanged(\n    element: HTMLElement,\n    origin: FocusOrigin,\n    elementInfo: MonitoredElementInfo,\n  ) {\n    this._setClasses(element, origin);\n    this._emitOrigin(elementInfo, origin);\n    this._lastFocusOrigin = origin;\n  }\n\n  /**\n   * Collects the `MonitoredElementInfo` of a particular element and\n   * all of its ancestors that have enabled `checkChildren`.\n   * @param element Element from which to start the search.\n   */\n  private _getClosestElementsInfo(element: HTMLElement): [HTMLElement, MonitoredElementInfo][] {\n    const results: [HTMLElement, MonitoredElementInfo][] = [];\n\n    this._elementInfo.forEach((info, currentElement) => {\n      if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n        results.push([currentElement, info]);\n      }\n    });\n\n    return results;\n  }\n\n  /**\n   * Returns whether an interaction is likely to have come from the user clicking the `label` of\n   * an `input` or `textarea` in order to focus it.\n   * @param focusEventTarget Target currently receiving focus.\n   */\n  private _isLastInteractionFromInputLabel(focusEventTarget: HTMLElement): boolean {\n    const {_mostRecentTarget: mostRecentTarget, mostRecentModality} = this._inputModalityDetector;\n\n    // If the last interaction used the mouse on an element contained by one of the labels\n    // of an `input`/`textarea` that is currently focused, it is very likely that the\n    // user redirected focus using the label.\n    if (\n      mostRecentModality !== 'mouse' ||\n      !mostRecentTarget ||\n      mostRecentTarget === focusEventTarget ||\n      (focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA') ||\n      (focusEventTarget as HTMLInputElement | HTMLTextAreaElement).disabled\n    ) {\n      return false;\n    }\n\n    const labels = (focusEventTarget as HTMLInputElement | HTMLTextAreaElement).labels;\n\n    if (labels) {\n      for (let i = 0; i < labels.length; i++) {\n        if (labels[i].contains(mostRecentTarget)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\n@Directive({\n  selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n  exportAs: 'cdkMonitorFocus',\n})\nexport class CdkMonitorFocus implements AfterViewInit, OnDestroy {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _focusMonitor = inject(FocusMonitor);\n\n  private _monitorSubscription: Subscription;\n  private _focusOrigin: FocusOrigin = null;\n\n  @Output() readonly cdkFocusChange = new EventEmitter<FocusOrigin>();\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  get focusOrigin(): FocusOrigin {\n    return this._focusOrigin;\n  }\n\n  ngAfterViewInit() {\n    const element = this._elementRef.nativeElement;\n    this._monitorSubscription = this._focusMonitor\n      .monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n      .subscribe(origin => {\n        this._focusOrigin = origin;\n        this.cdkFocusChange.emit(origin);\n      });\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n\n    if (this._monitorSubscription) {\n      this._monitorSubscription.unsubscribe();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ApplicationRef,\n  ComponentRef,\n  createComponent,\n  EnvironmentInjector,\n  inject,\n  Injectable,\n  Injector,\n  Type,\n} from '@angular/core';\n\n/** Apps in which we've loaded styles. */\nconst appsWithLoaders = new WeakMap<\n  ApplicationRef,\n  {\n    /** Style loaders that have been added. */\n    loaders: Set<Type<unknown>>;\n\n    /** References to the instantiated loaders. */\n    refs: ComponentRef<unknown>[];\n  }\n>();\n\n/**\n * Service that loads structural styles dynamically\n * and ensures that they're only loaded once per app.\n */\n@Injectable({providedIn: 'root'})\nexport class _CdkPrivateStyleLoader {\n  private _appRef: ApplicationRef | undefined;\n  private _injector = inject(Injector);\n  private _environmentInjector = inject(EnvironmentInjector);\n\n  /**\n   * Loads a set of styles.\n   * @param loader Component which will be instantiated to load the styles.\n   */\n  load(loader: Type<unknown>): void {\n    // Resolve the app ref lazily to avoid circular dependency errors if this is called too early.\n    const appRef = (this._appRef = this._appRef || this._injector.get(ApplicationRef));\n    let data = appsWithLoaders.get(appRef);\n\n    // If we haven't loaded for this app before, we have to initialize it.\n    if (!data) {\n      data = {loaders: new Set(), refs: []};\n      appsWithLoaders.set(appRef, data);\n\n      // When the app is destroyed, we need to clean up all the related loaders.\n      appRef.onDestroy(() => {\n        appsWithLoaders.get(appRef)?.refs.forEach(ref => ref.destroy());\n        appsWithLoaders.delete(appRef);\n      });\n    }\n\n    // If the loader hasn't been loaded before, we need to instatiate it.\n    if (!data.loaders.has(loader)) {\n      data.loaders.add(loader);\n      data.refs.push(createComponent(loader, {environmentInjector: this._environmentInjector}));\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ChangeDetectionStrategy, Component, ViewEncapsulation} from '@angular/core';\n\n/**\n * Component used to load the .cdk-visually-hidden styles.\n * @docs-private\n */\n@Component({\n  styleUrl: 'visually-hidden.css',\n  exportAs: 'cdkVisuallyHidden',\n  encapsulation: ViewEncapsulation.None,\n  template: '',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class _VisuallyHiddenLoader {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** Wraps the provided value in an array, unless the provided value is an array. */\nexport function coerceArray<T>(value: T | T[]): T[];\nexport function coerceArray<T>(value: T | readonly T[]): readonly T[];\nexport function coerceArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {Injectable, CSP_NONCE, inject} from '@angular/core';\nimport {Platform} from '../platform';\n\n/** Global registry for all dynamically-created, injected media queries. */\nconst mediaQueriesForWebkitCompatibility: Set<string> = new Set<string>();\n\n/** Style tag that holds all of the dynamically-created media queries. */\nlet mediaQueryStyleNode: HTMLStyleElement | undefined;\n\n/** A utility for calling matchMedia queries. */\n@Injectable({providedIn: 'root'})\nexport class MediaMatcher {\n  private _platform = inject(Platform);\n  private _nonce = inject(CSP_NONCE, {optional: true});\n\n  /** The internal matchMedia method to return back a MediaQueryList like object. */\n  private _matchMedia: (query: string) => MediaQueryList;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    this._matchMedia =\n      this._platform.isBrowser && window.matchMedia\n        ? // matchMedia is bound to the window scope intentionally as it is an illegal invocation to\n          // call it from a different scope.\n          window.matchMedia.bind(window)\n        : noopMatchMedia;\n  }\n\n  /**\n   * Evaluates the given media query and returns the native MediaQueryList from which results\n   * can be retrieved.\n   * Confirms the layout engine will trigger for the selector query provided and returns the\n   * MediaQueryList for the query provided.\n   */\n  matchMedia(query: string): MediaQueryList {\n    if (this._platform.WEBKIT || this._platform.BLINK) {\n      createEmptyStyleRule(query, this._nonce);\n    }\n    return this._matchMedia(query);\n  }\n}\n\n/**\n * Creates an empty stylesheet that is used to work around browser inconsistencies related to\n * `matchMedia`. At the time of writing, it handles the following cases:\n * 1. On WebKit browsers, a media query has to have at least one rule in order for `matchMedia`\n * to fire. We work around it by declaring a dummy stylesheet with a `@media` declaration.\n * 2. In some cases Blink browsers will stop firing the `matchMedia` listener if none of the rules\n * inside the `@media` match existing elements on the page. We work around it by having one rule\n * targeting the `body`. See https://github.com/angular/components/issues/23546.\n */\nfunction createEmptyStyleRule(query: string, nonce: string | undefined | null) {\n  if (mediaQueriesForWebkitCompatibility.has(query)) {\n    return;\n  }\n\n  try {\n    if (!mediaQueryStyleNode) {\n      mediaQueryStyleNode = document.createElement('style');\n\n      if (nonce) {\n        mediaQueryStyleNode.setAttribute('nonce', nonce);\n      }\n\n      mediaQueryStyleNode.setAttribute('type', 'text/css');\n      document.head!.appendChild(mediaQueryStyleNode);\n    }\n\n    if (mediaQueryStyleNode.sheet) {\n      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);\n      mediaQueriesForWebkitCompatibility.add(query);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\n\n/** No-op matchMedia replacement for non-browser platforms. */\nfunction noopMatchMedia(query: string): MediaQueryList {\n  // Use `as any` here to avoid adding additional necessary properties for\n  // the noop matcher.\n  return {\n    matches: query === 'all' || query === '',\n    media: query,\n    addListener: () => {},\n    removeListener: () => {},\n  } as any;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {coerceArray} from '../coercion';\nimport {Injectable, NgZone, OnDestroy, inject} from '@angular/core';\nimport {combineLatest, concat, Observable, Observer, Subject} from 'rxjs';\nimport {debounceTime, map, skip, startWith, take, takeUntil} from 'rxjs/operators';\nimport {MediaMatcher} from './media-matcher';\n\n/** The current state of a layout breakpoint. */\nexport interface BreakpointState {\n  /** Whether the breakpoint is currently matching. */\n  matches: boolean;\n  /**\n   * A key boolean pair for each query provided to the observe method,\n   * with its current matched state.\n   */\n  breakpoints: {\n    [key: string]: boolean;\n  };\n}\n\n/** The current state of a layout breakpoint. */\ninterface InternalBreakpointState {\n  /** Whether the breakpoint is currently matching. */\n  matches: boolean;\n  /** The media query being to be matched */\n  query: string;\n}\n\ninterface Query {\n  observable: Observable<InternalBreakpointState>;\n  mql: MediaQueryList;\n}\n\n/** Utility for checking the matching state of `@media` queries. */\n@Injectable({providedIn: 'root'})\nexport class BreakpointObserver implements OnDestroy {\n  private _mediaMatcher = inject(MediaMatcher);\n  private _zone = inject(NgZone);\n\n  /**  A map of all media queries currently being listened for. */\n  private _queries = new Map<string, Query>();\n  /** A subject for all other observables to takeUntil based on. */\n  private readonly _destroySubject = new Subject<void>();\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /** Completes the active subject, signalling to all other observables to complete. */\n  ngOnDestroy() {\n    this._destroySubject.next();\n    this._destroySubject.complete();\n  }\n\n  /**\n   * Whether one or more media queries match the current viewport size.\n   * @param value One or more media queries to check.\n   * @returns Whether any of the media queries match.\n   */\n  isMatched(value: string | readonly string[]): boolean {\n    const queries = splitQueries(coerceArray(value));\n    return queries.some(mediaQuery => this._registerQuery(mediaQuery).mql.matches);\n  }\n\n  /**\n   * Gets an observable of results for the given queries that will emit new results for any changes\n   * in matching of the given queries.\n   * @param value One or more media queries to check.\n   * @returns A stream of matches for the given queries.\n   */\n  observe(value: string | readonly string[]): Observable<BreakpointState> {\n    const queries = splitQueries(coerceArray(value));\n    const observables = queries.map(query => this._registerQuery(query).observable);\n\n    let stateObservable = combineLatest(observables);\n    // Emit the first state immediately, and then debounce the subsequent emissions.\n    stateObservable = concat(\n      stateObservable.pipe(take(1)),\n      stateObservable.pipe(skip(1), debounceTime(0)),\n    );\n    return stateObservable.pipe(\n      map(breakpointStates => {\n        const response: BreakpointState = {\n          matches: false,\n          breakpoints: {},\n        };\n        breakpointStates.forEach(({matches, query}) => {\n          response.matches = response.matches || matches;\n          response.breakpoints[query] = matches;\n        });\n        return response;\n      }),\n    );\n  }\n\n  /** Registers a specific query to be listened for. */\n  private _registerQuery(query: string): Query {\n    // Only set up a new MediaQueryList if it is not already being listened for.\n    if (this._queries.has(query)) {\n      return this._queries.get(query)!;\n    }\n\n    const mql = this._mediaMatcher.matchMedia(query);\n\n    // Create callback for match changes and add it is as a listener.\n    const queryObservable = new Observable((observer: Observer<MediaQueryListEvent>) => {\n      // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed\n      // back into the zone because matchMedia is only included in Zone.js by loading the\n      // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not\n      // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js\n      // patches it.\n      const handler = (e: MediaQueryListEvent): void => this._zone.run(() => observer.next(e));\n      mql.addListener(handler);\n\n      return () => {\n        mql.removeListener(handler);\n      };\n    }).pipe(\n      startWith(mql),\n      map(({matches}) => ({query, matches})),\n      takeUntil(this._destroySubject),\n    );\n\n    // Add the MediaQueryList to the set of queries.\n    const output = {observable: queryObservable, mql};\n    this._queries.set(query, output);\n    return output;\n  }\n}\n\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n */\nfunction splitQueries(queries: readonly string[]): readonly string[] {\n  return queries\n    .map(query => query.split(','))\n    .reduce((a1, a2) => a1.concat(a2))\n    .map(query => query.trim());\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NumberInput, coerceElement, coerceNumberProperty} from '../coercion';\nimport {\n  AfterContentInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  Input,\n  NgModule,\n  NgZone,\n  OnDestroy,\n  Output,\n  booleanAttribute,\n  inject,\n} from '@angular/core';\nimport {Observable, Observer, Subject, Subscription} from 'rxjs';\nimport {debounceTime, filter, map} from 'rxjs/operators';\n\n// Angular may add, remove, or edit comment nodes during change detection. We don't care about\n// these changes because they don't affect the user-preceived content, and worse it can cause\n// infinite change detection cycles where the change detection updates a comment, triggering the\n// MutationObserver, triggering another change detection and kicking the cycle off again.\nfunction shouldIgnoreRecord(record: MutationRecord) {\n  // Ignore changes to comment text.\n  if (record.type === 'characterData' && record.target instanceof Comment) {\n    return true;\n  }\n  // Ignore addition / removal of comments.\n  if (record.type === 'childList') {\n    for (let i = 0; i < record.addedNodes.length; i++) {\n      if (!(record.addedNodes[i] instanceof Comment)) {\n        return false;\n      }\n    }\n    for (let i = 0; i < record.removedNodes.length; i++) {\n      if (!(record.removedNodes[i] instanceof Comment)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Observe everything else.\n  return false;\n}\n\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\n@Injectable({providedIn: 'root'})\nexport class MutationObserverFactory {\n  create(callback: MutationCallback): MutationObserver | null {\n    return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n  }\n}\n\n/** An injectable service that allows watching elements for changes to their content. */\n@Injectable({providedIn: 'root'})\nexport class ContentObserver implements OnDestroy {\n  private _mutationObserverFactory = inject(MutationObserverFactory);\n\n  /** Keeps track of the existing MutationObservers so they can be reused. */\n  private _observedElements = new Map<\n    Element,\n    {\n      observer: MutationObserver | null;\n      readonly stream: Subject<MutationRecord[]>;\n      count: number;\n    }\n  >();\n\n  private _ngZone = inject(NgZone);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngOnDestroy() {\n    this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n  }\n\n  /**\n   * Observe content changes on an element.\n   * @param element The element to observe for content changes.\n   */\n  observe(element: Element): Observable<MutationRecord[]>;\n\n  /**\n   * Observe content changes on an element.\n   * @param element The element to observe for content changes.\n   */\n  observe(element: ElementRef<Element>): Observable<MutationRecord[]>;\n\n  observe(elementOrRef: Element | ElementRef<Element>): Observable<MutationRecord[]> {\n    const element = coerceElement(elementOrRef);\n\n    return new Observable((observer: Observer<MutationRecord[]>) => {\n      const stream = this._observeElement(element);\n      const subscription = stream\n        .pipe(\n          map(records => records.filter(record => !shouldIgnoreRecord(record))),\n          filter(records => !!records.length),\n        )\n        .subscribe(records => {\n          this._ngZone.run(() => {\n            observer.next(records);\n          });\n        });\n\n      return () => {\n        subscription.unsubscribe();\n        this._unobserveElement(element);\n      };\n    });\n  }\n\n  /**\n   * Observes the given element by using the existing MutationObserver if available, or creating a\n   * new one if not.\n   */\n  private _observeElement(element: Element): Subject<MutationRecord[]> {\n    return this._ngZone.runOutsideAngular(() => {\n      if (!this._observedElements.has(element)) {\n        const stream = new Subject<MutationRecord[]>();\n        const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n        if (observer) {\n          observer.observe(element, {\n            characterData: true,\n            childList: true,\n            subtree: true,\n          });\n        }\n        this._observedElements.set(element, {observer, stream, count: 1});\n      } else {\n        this._observedElements.get(element)!.count++;\n      }\n      return this._observedElements.get(element)!.stream;\n    });\n  }\n\n  /**\n   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n   * observing this element.\n   */\n  private _unobserveElement(element: Element) {\n    if (this._observedElements.has(element)) {\n      this._observedElements.get(element)!.count--;\n      if (!this._observedElements.get(element)!.count) {\n        this._cleanupObserver(element);\n      }\n    }\n  }\n\n  /** Clean up the underlying MutationObserver for the specified element. */\n  private _cleanupObserver(element: Element) {\n    if (this._observedElements.has(element)) {\n      const {observer, stream} = this._observedElements.get(element)!;\n      if (observer) {\n        observer.disconnect();\n      }\n      stream.complete();\n      this._observedElements.delete(element);\n    }\n  }\n}\n\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\n@Directive({\n  selector: '[cdkObserveContent]',\n  exportAs: 'cdkObserveContent',\n})\nexport class CdkObserveContent implements AfterContentInit, OnDestroy {\n  private _contentObserver = inject(ContentObserver);\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n\n  /** Event emitted for each change in the element's content. */\n  @Output('cdkObserveContent') readonly event = new EventEmitter<MutationRecord[]>();\n\n  /**\n   * Whether observing content is disabled. This option can be used\n   * to disconnect the underlying MutationObserver until it is needed.\n   */\n  @Input({alias: 'cdkObserveContentDisabled', transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n    this._disabled ? this._unsubscribe() : this._subscribe();\n  }\n  private _disabled = false;\n\n  /** Debounce interval for emitting the changes. */\n  @Input()\n  get debounce(): number {\n    return this._debounce;\n  }\n  set debounce(value: NumberInput) {\n    this._debounce = coerceNumberProperty(value);\n    this._subscribe();\n  }\n  private _debounce: number;\n\n  private _currentSubscription: Subscription | null = null;\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngAfterContentInit() {\n    if (!this._currentSubscription && !this.disabled) {\n      this._subscribe();\n    }\n  }\n\n  ngOnDestroy() {\n    this._unsubscribe();\n  }\n\n  private _subscribe() {\n    this._unsubscribe();\n    const stream = this._contentObserver.observe(this._elementRef);\n\n    this._currentSubscription = (\n      this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream\n    ).subscribe(this.event);\n  }\n\n  private _unsubscribe() {\n    this._currentSubscription?.unsubscribe();\n  }\n}\n\n@NgModule({\n  imports: [CdkObserveContent],\n  exports: [CdkObserveContent],\n  providers: [MutationObserverFactory],\n})\nexport class ObserversModule {}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Platform} from '../../platform';\nimport {Injectable, inject} from '@angular/core';\n\n/**\n * Configuration for the isFocusable method.\n */\nexport class IsFocusableConfig {\n  /**\n   * Whether to count an element as focusable even if it is not currently visible.\n   */\n  ignoreVisibility: boolean = false;\n}\n\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n// supported.\n\n/**\n * Utility for checking the interactivity of an element, such as whether it is focusable or\n * tabbable.\n */\n@Injectable({providedIn: 'root'})\nexport class InteractivityChecker {\n  private _platform = inject(Platform);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /**\n   * Gets whether an element is disabled.\n   *\n   * @param element Element to be checked.\n   * @returns Whether the element is disabled.\n   */\n  isDisabled(element: HTMLElement): boolean {\n    // This does not capture some cases, such as a non-form control with a disabled attribute or\n    // a form control inside of a disabled form, but should capture the most common cases.\n    return element.hasAttribute('disabled');\n  }\n\n  /**\n   * Gets whether an element is visible for the purposes of interactivity.\n   *\n   * This will capture states like `display: none` and `visibility: hidden`, but not things like\n   * being clipped by an `overflow: hidden` parent or being outside the viewport.\n   *\n   * @returns Whether the element is visible.\n   */\n  isVisible(element: HTMLElement): boolean {\n    return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n  }\n\n  /**\n   * Gets whether an element can be reached via Tab key.\n   * Assumes that the element has already been checked with isFocusable.\n   *\n   * @param element Element to be checked.\n   * @returns Whether the element is tabbable.\n   */\n  isTabbable(element: HTMLElement): boolean {\n    // Nothing is tabbable on the server \n    if (!this._platform.isBrowser) {\n      return false;\n    }\n\n    const frameElement = getFrameElement(getWindow(element));\n\n    if (frameElement) {\n      // Frame elements inherit their tabindex onto all child elements.\n      if (getTabIndexValue(frameElement) === -1) {\n        return false;\n      }\n\n      // Browsers disable tabbing to an element inside of an invisible frame.\n      if (!this.isVisible(frameElement)) {\n        return false;\n      }\n    }\n\n    let nodeName = element.nodeName.toLowerCase();\n    let tabIndexValue = getTabIndexValue(element);\n\n    if (element.hasAttribute('contenteditable')) {\n      return tabIndexValue !== -1;\n    }\n\n    if (nodeName === 'iframe' || nodeName === 'object') {\n      // The frame or object's content may be tabbable depending on the content, but it's\n      // not possibly to reliably detect the content of the frames. We always consider such\n      // elements as non-tabbable.\n      return false;\n    }\n\n    // In iOS, the browser only considers some specific elements as tabbable.\n    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n      return false;\n    }\n\n    if (nodeName === 'audio') {\n      // Audio elements without controls enabled are never tabbable, regardless\n      // of the tabindex attribute explicitly being set.\n      if (!element.hasAttribute('controls')) {\n        return false;\n      }\n      // Audio elements with controls are by default tabbable unless the\n      // tabindex attribute is set to `-1` explicitly.\n      return tabIndexValue !== -1;\n    }\n\n    if (nodeName === 'video') {\n      // For all video elements, if the tabindex attribute is set to `-1`, the video\n      // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n      // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n      // tabindex attribute is the source of truth here.\n      if (tabIndexValue === -1) {\n        return false;\n      }\n      // If the tabindex is explicitly set, and not `-1` (as per check before), the\n      // video element is always tabbable (regardless of whether it has controls or not).\n      if (tabIndexValue !== null) {\n        return true;\n      }\n      // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n      // has controls enabled. Firefox is special as videos are always tabbable regardless\n      // of whether there are controls or not.\n      return this._platform.FIREFOX || element.hasAttribute('controls');\n    }\n\n    return element.tabIndex >= 0;\n  }\n\n  /**\n   * Gets whether an element can be focused by the user.\n   *\n   * @param element Element to be checked.\n   * @param config The config object with options to customize this method's behavior\n   * @returns Whether the element is focusable.\n   */\n  isFocusable(element: HTMLElement, config?: IsFocusableConfig): boolean {\n    // Perform checks in order of left to most expensive.\n    // Again, naive approach that does not capture many edge cases and browser quirks.\n    return (\n      isPotentiallyFocusable(element) &&\n      !this.isDisabled(element) &&\n      (config?.ignoreVisibility || this.isVisible(element))\n    );\n  }\n}\n\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window: Window) {\n  try {\n    return window.frameElement as HTMLElement;\n  } catch {\n    return null;\n  }\n}\n\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element: HTMLElement): boolean {\n  // Use logic from jQuery to check for an invisible element.\n  // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n  return !!(\n    element.offsetWidth ||\n    element.offsetHeight ||\n    (typeof element.getClientRects === 'function' && element.getClientRects().length)\n  );\n}\n\n/** Gets whether an element's  */\nfunction isNativeFormElement(element: Node) {\n  let nodeName = element.nodeName.toLowerCase();\n  return (\n    nodeName === 'input' ||\n    nodeName === 'select' ||\n    nodeName === 'button' ||\n    nodeName === 'textarea'\n  );\n}\n\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element: HTMLElement): boolean {\n  return isInputElement(element) && element.type == 'hidden';\n}\n\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element: HTMLElement): boolean {\n  return isAnchorElement(element) && element.hasAttribute('href');\n}\n\n/** Gets whether an element is an input element. */\nfunction isInputElement(element: HTMLElement): element is HTMLInputElement {\n  return element.nodeName.toLowerCase() == 'input';\n}\n\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element: HTMLElement): element is HTMLAnchorElement {\n  return element.nodeName.toLowerCase() == 'a';\n}\n\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element: HTMLElement): boolean {\n  if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n    return false;\n  }\n\n  let tabIndex = element.getAttribute('tabindex');\n  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element: HTMLElement): number | null {\n  if (!hasValidTabIndex(element)) {\n    return null;\n  }\n\n  // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n  const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n\n  return isNaN(tabIndex) ? -1 : tabIndex;\n}\n\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element: HTMLElement): boolean {\n  let nodeName = element.nodeName.toLowerCase();\n  let inputType = nodeName === 'input' && (element as HTMLInputElement).type;\n\n  return (\n    inputType === 'text' ||\n    inputType === 'password' ||\n    nodeName === 'select' ||\n    nodeName === 'textarea'\n  );\n}\n\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element: HTMLElement): boolean {\n  // Inputs are potentially focusable *unless* they're type=\"hidden\".\n  if (isHiddenInput(element)) {\n    return false;\n  }\n\n  return (\n    isNativeFormElement(element) ||\n    isAnchorWithHref(element) ||\n    element.hasAttribute('contenteditable') ||\n    hasValidTabIndex(element)\n  );\n}\n\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node: HTMLElement): Window {\n  // ownerDocument is null if `node` itself *is* a document.\n  return (node.ownerDocument && node.ownerDocument.defaultView) || window;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Platform, _getFocusedElementPierceShadowDom} from '../../platform';\n\nimport {\n  AfterContentInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  Injectable,\n  Injector,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  SimpleChanges,\n  afterNextRender,\n  booleanAttribute,\n  inject,\n  DOCUMENT,\n} from '@angular/core';\nimport {InteractivityChecker} from '../interactivity-checker/interactivity-checker';\nimport {_CdkPrivateStyleLoader, _VisuallyHiddenLoader} from '../../private';\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n */\nexport class FocusTrap {\n  private _startAnchor: HTMLElement | null;\n  private _endAnchor: HTMLElement | null;\n  private _hasAttached = false;\n\n  // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n  protected startAnchorListener = () => this.focusLastTabbableElement();\n  protected endAnchorListener = () => this.focusFirstTabbableElement();\n\n  /** Whether the focus trap is active. */\n  get enabled(): boolean {\n    return this._enabled;\n  }\n  set enabled(value: boolean) {\n    this._enabled = value;\n\n    if (this._startAnchor && this._endAnchor) {\n      this._toggleAnchorTabIndex(value, this._startAnchor);\n      this._toggleAnchorTabIndex(value, this._endAnchor);\n    }\n  }\n  protected _enabled: boolean = true;\n\n  constructor(\n    readonly _element: HTMLElement,\n    private _checker: InteractivityChecker,\n    readonly _ngZone: NgZone,\n    readonly _document: Document,\n    deferAnchors = false,\n    /** @breaking-change 20.0.0 param to become required */\n    readonly _injector?: Injector,\n  ) {\n    if (!deferAnchors) {\n      this.attachAnchors();\n    }\n  }\n\n  /** Destroys the focus trap by cleaning up the anchors. */\n  destroy() {\n    const startAnchor = this._startAnchor;\n    const endAnchor = this._endAnchor;\n\n    if (startAnchor) {\n      startAnchor.removeEventListener('focus', this.startAnchorListener);\n      startAnchor.remove();\n    }\n\n    if (endAnchor) {\n      endAnchor.removeEventListener('focus', this.endAnchorListener);\n      endAnchor.remove();\n    }\n\n    this._startAnchor = this._endAnchor = null;\n    this._hasAttached = false;\n  }\n\n  /**\n   * Inserts the anchors into the DOM. This is usually done automatically\n   * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n   * @returns Whether the focus trap managed to attach successfully. This may not be the case\n   * if the target element isn't currently in the DOM.\n   */\n  attachAnchors(): boolean {\n    // If we're not on the browser, there can be no focus to trap.\n    if (this._hasAttached) {\n      return true;\n    }\n\n    this._ngZone.runOutsideAngular(() => {\n      if (!this._startAnchor) {\n        this._startAnchor = this._createAnchor();\n        this._startAnchor!.addEventListener('focus', this.startAnchorListener);\n      }\n\n      if (!this._endAnchor) {\n        this._endAnchor = this._createAnchor();\n        this._endAnchor!.addEventListener('focus', this.endAnchorListener);\n      }\n    });\n\n    if (this._element.parentNode) {\n      this._element.parentNode.insertBefore(this._startAnchor!, this._element);\n      this._element.parentNode.insertBefore(this._endAnchor!, this._element.nextSibling);\n      this._hasAttached = true;\n    }\n\n    return this._hasAttached;\n  }\n\n  /**\n   * Waits for the zone to stabilize, then focuses the first tabbable element.\n   * @returns Returns a promise that resolves with a boolean, depending\n   * on whether focus was moved successfully.\n   */\n  focusInitialElementWhenReady(options?: FocusOptions): Promise<boolean> {\n    return new Promise<boolean>(resolve => {\n      this._executeOnStable(() => resolve(this.focusInitialElement(options)));\n    });\n  }\n\n  /**\n   * Waits for the zone to stabilize, then focuses\n   * the first tabbable element within the focus trap region.\n   * @returns Returns a promise that resolves with a boolean, depending\n   * on whether focus was moved successfully.\n   */\n  focusFirstTabbableElementWhenReady(options?: FocusOptions): Promise<boolean> {\n    return new Promise<boolean>(resolve => {\n      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));\n    });\n  }\n\n  /**\n   * Waits for the zone to stabilize, then focuses\n   * the last tabbable element within the focus trap region.\n   * @returns Returns a promise that resolves with a boolean, depending\n   * on whether focus was moved successfully.\n   */\n  focusLastTabbableElementWhenReady(options?: FocusOptions): Promise<boolean> {\n    return new Promise<boolean>(resolve => {\n      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));\n    });\n  }\n\n  /**\n   * Get the specified boundary element of the trapped region.\n   * @param bound The boundary to get (start or end of trapped region).\n   * @returns The boundary element.\n   */\n  private _getRegionBoundary(bound: 'start' | 'end'): HTMLElement | null {\n    // Contains the deprecated version of selector, for temporary backwards comparability.\n    const markers = this._element.querySelectorAll(\n      `[cdk-focus-region-${bound}], ` + `[cdkFocusRegion${bound}], ` + `[cdk-focus-${bound}]`,\n    ) as NodeListOf<HTMLElement>;\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      for (let i = 0; i < markers.length; i++) {\n        // @breaking-change 8.0.0\n        if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n          console.warn(\n            `Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n              `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n              `attribute will be removed in 8.0.0.`,\n            markers[i],\n          );\n        } else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n          console.warn(\n            `Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n              `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n              `will be removed in 8.0.0.`,\n            markers[i],\n          );\n        }\n      }\n    }\n\n    if (bound == 'start') {\n      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n    }\n    return markers.length\n      ? markers[markers.length - 1]\n      : this._getLastTabbableElement(this._element);\n  }\n\n  /**\n   * Focuses the element that should be focused when the focus trap is initialized.\n   * @returns Whether focus was moved successfully.\n   */\n  focusInitialElement(options?: FocusOptions): boolean {\n    // Contains the deprecated version of selector, for temporary backwards comparability.\n    const redirectToElement = this._element.querySelector(\n      `[cdk-focus-initial], ` + `[cdkFocusInitial]`,\n    ) as HTMLElement;\n\n    if (redirectToElement) {\n      // @breaking-change 8.0.0\n      if (\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        redirectToElement.hasAttribute(`cdk-focus-initial`)\n      ) {\n        console.warn(\n          `Found use of deprecated attribute 'cdk-focus-initial', ` +\n            `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n            `will be removed in 8.0.0`,\n          redirectToElement,\n        );\n      }\n\n      // Warn the consumer if the element they've pointed to\n      // isn't focusable, when not in production mode.\n      if (\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        !this._checker.isFocusable(redirectToElement)\n      ) {\n        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n      }\n\n      if (!this._checker.isFocusable(redirectToElement)) {\n        const focusableChild = this._getFirstTabbableElement(redirectToElement) as HTMLElement;\n        focusableChild?.focus(options);\n        return !!focusableChild;\n      }\n\n      redirectToElement.focus(options);\n      return true;\n    }\n\n    return this.focusFirstTabbableElement(options);\n  }\n\n  /**\n   * Focuses the first tabbable element within the focus trap region.\n   * @returns Whether focus was moved successfully.\n   */\n  focusFirstTabbableElement(options?: FocusOptions): boolean {\n    const redirectToElement = this._getRegionBoundary('start');\n\n    if (redirectToElement) {\n      redirectToElement.focus(options);\n    }\n\n    return !!redirectToElement;\n  }\n\n  /**\n   * Focuses the last tabbable element within the focus trap region.\n   * @returns Whether focus was moved successfully.\n   */\n  focusLastTabbableElement(options?: FocusOptions): boolean {\n    const redirectToElement = this._getRegionBoundary('end');\n\n    if (redirectToElement) {\n      redirectToElement.focus(options);\n    }\n\n    return !!redirectToElement;\n  }\n\n  /**\n   * Checks whether the focus trap has successfully been attached.\n   */\n  hasAttached(): boolean {\n    return this._hasAttached;\n  }\n\n  /** Get the first tabbable element from a DOM subtree (inclusive). */\n  private _getFirstTabbableElement(root: HTMLElement): HTMLElement | null {\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n      return root;\n    }\n\n    const children = root.children;\n\n    for (let i = 0; i < children.length; i++) {\n      const tabbableChild =\n        children[i].nodeType === this._document.ELEMENT_NODE\n          ? this._getFirstTabbableElement(children[i] as HTMLElement)\n          : null;\n\n      if (tabbableChild) {\n        return tabbableChild;\n      }\n    }\n\n    return null;\n  }\n\n  /** Get the last tabbable element from a DOM subtree (inclusive). */\n  private _getLastTabbableElement(root: HTMLElement): HTMLElement | null {\n    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n      return root;\n    }\n\n    // Iterate in reverse DOM order.\n    const children = root.children;\n\n    for (let i = children.length - 1; i >= 0; i--) {\n      const tabbableChild =\n        children[i].nodeType === this._document.ELEMENT_NODE\n          ? this._getLastTabbableElement(children[i] as HTMLElement)\n          : null;\n\n      if (tabbableChild) {\n        return tabbableChild;\n      }\n    }\n\n    return null;\n  }\n\n  /** Creates an anchor element. */\n  private _createAnchor(): HTMLElement {\n    const anchor = this._document.createElement('div');\n    this._toggleAnchorTabIndex(this._enabled, anchor);\n    anchor.classList.add('cdk-visually-hidden');\n    anchor.classList.add('cdk-focus-trap-anchor');\n    anchor.setAttribute('aria-hidden', 'true');\n    return anchor;\n  }\n\n  /**\n   * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n   * @param isEnabled Whether the focus trap is enabled.\n   * @param anchor Anchor on which to toggle the tabindex.\n   */\n  private _toggleAnchorTabIndex(isEnabled: boolean, anchor: HTMLElement) {\n    // Remove the tabindex completely, rather than setting it to -1, because if the\n    // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n    isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n  }\n\n  /**\n   * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n   * @param enabled: Whether the anchors should trap Tab.\n   */\n  protected toggleAnchors(enabled: boolean) {\n    if (this._startAnchor && this._endAnchor) {\n      this._toggleAnchorTabIndex(enabled, this._startAnchor);\n      this._toggleAnchorTabIndex(enabled, this._endAnchor);\n    }\n  }\n\n  /** Executes a function when the zone is stable. */\n  private _executeOnStable(fn: () => any): void {\n    // TODO: remove this conditional when injector is required in the constructor.\n    if (this._injector) {\n      afterNextRender(fn, {injector: this._injector});\n    } else {\n      setTimeout(fn);\n    }\n  }\n}\n\n/**\n * Factory that allows easy instantiation of focus traps.\n */\n@Injectable({providedIn: 'root'})\nexport class FocusTrapFactory {\n  private _checker = inject(InteractivityChecker);\n  private _ngZone = inject(NgZone);\n\n  private _document = inject(DOCUMENT);\n  private _injector = inject(Injector);\n\n  constructor(...args: unknown[]);\n  constructor() {\n    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n  }\n\n  /**\n   * Creates a focus-trapped region around the given element.\n   * @param element The element around which focus will be trapped.\n   * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n   *     manually by the user.\n   * @returns The created focus trap instance.\n   */\n  create(element: HTMLElement, deferCaptureElements: boolean = false): FocusTrap {\n    return new FocusTrap(\n      element,\n      this._checker,\n      this._ngZone,\n      this._document,\n      deferCaptureElements,\n      this._injector,\n    );\n  }\n}\n\n/** Directive for trapping focus within a region. */\n@Directive({\n  selector: '[cdkTrapFocus]',\n  exportAs: 'cdkTrapFocus',\n})\nexport class CdkTrapFocus implements OnDestroy, AfterContentInit, OnChanges, DoCheck {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _focusTrapFactory = inject(FocusTrapFactory);\n\n  /** Underlying FocusTrap instance. */\n  focusTrap: FocusTrap;\n\n  /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n  private _previouslyFocusedElement: HTMLElement | null = null;\n\n  /** Whether the focus trap is active. */\n  @Input({alias: 'cdkTrapFocus', transform: booleanAttribute})\n  get enabled(): boolean {\n    return this.focusTrap?.enabled || false;\n  }\n  set enabled(value: boolean) {\n    if (this.focusTrap) {\n      this.focusTrap.enabled = value;\n    }\n  }\n\n  /**\n   * Whether the directive should automatically move focus into the trapped region upon\n   * initialization and return focus to the previous activeElement upon destruction.\n   */\n  @Input({alias: 'cdkTrapFocusAutoCapture', transform: booleanAttribute}) autoCapture: boolean;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const platform = inject(Platform);\n\n    if (platform.isBrowser) {\n      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n  }\n\n  ngOnDestroy() {\n    this.focusTrap?.destroy();\n\n    // If we stored a previously focused element when using autoCapture, return focus to that\n    // element now that the trapped region is being destroyed.\n    if (this._previouslyFocusedElement) {\n      this._previouslyFocusedElement.focus();\n      this._previouslyFocusedElement = null;\n    }\n  }\n\n  ngAfterContentInit() {\n    this.focusTrap?.attachAnchors();\n\n    if (this.autoCapture) {\n      this._captureFocus();\n    }\n  }\n\n  ngDoCheck() {\n    if (this.focusTrap && !this.focusTrap.hasAttached()) {\n      this.focusTrap.attachAnchors();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    const autoCaptureChange = changes['autoCapture'];\n\n    if (\n      autoCaptureChange &&\n      !autoCaptureChange.firstChange &&\n      this.autoCapture &&\n      this.focusTrap?.hasAttached()\n    ) {\n      this._captureFocus();\n    }\n  }\n\n  private _captureFocus() {\n    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();\n    this.focusTrap?.focusInitialElementWhenReady();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n// The tokens for the live announcer are defined in a separate file from LiveAnnouncer\n// as a workaround for https://github.com/angular/angular/issues/22559\n\n/** Possible politeness levels. */\nexport type AriaLivePoliteness = 'off' | 'polite' | 'assertive';\n\nexport const LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken<HTMLElement | null>(\n  'liveAnnouncerElement',\n  {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n  },\n);\n\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nexport function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY(): null {\n  return null;\n}\n\n/** Object that can be used to configure the default options for the LiveAnnouncer. */\nexport interface LiveAnnouncerDefaultOptions {\n  /** Default politeness for the announcements. */\n  politeness?: AriaLivePoliteness;\n\n  /** Default duration for the announcement messages. */\n  duration?: number;\n}\n\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nexport const LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken<LiveAnnouncerDefaultOptions>(\n  'LIVE_ANNOUNCER_DEFAULT_OPTIONS',\n);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ContentObserver} from '../../observers';\n\nimport {\n  Directive,\n  ElementRef,\n  Injectable,\n  Input,\n  NgZone,\n  OnDestroy,\n  inject,\n  DOCUMENT,\n} from '@angular/core';\nimport {Subscription} from 'rxjs';\nimport {\n  AriaLivePoliteness,\n  LiveAnnouncerDefaultOptions,\n  LIVE_ANNOUNCER_ELEMENT_TOKEN,\n  LIVE_ANNOUNCER_DEFAULT_OPTIONS,\n} from './live-announcer-tokens';\nimport {_CdkPrivateStyleLoader, _VisuallyHiddenLoader} from '../../private';\n\nlet uniqueIds = 0;\n\n@Injectable({providedIn: 'root'})\nexport class LiveAnnouncer implements OnDestroy {\n  private _ngZone = inject(NgZone);\n  private _defaultOptions = inject<LiveAnnouncerDefaultOptions>(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {\n    optional: true,\n  });\n\n  private _liveElement: HTMLElement;\n  private _document = inject(DOCUMENT);\n  private _previousTimeout: ReturnType<typeof setTimeout>;\n  private _currentPromise: Promise<void> | undefined;\n  private _currentResolve: (() => void) | undefined;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, {optional: true});\n    this._liveElement = elementToken || this._createLiveElement();\n  }\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param politeness The politeness of the announcer element.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, politeness?: AriaLivePoliteness): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param duration Time in milliseconds after which to clear out the announcer element. Note\n   *   that this takes effect after the message has been added to the DOM, which can be up to\n   *   100ms after `announce` has been called.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, duration?: number): Promise<void>;\n\n  /**\n   * Announces a message to screen readers.\n   * @param message Message to be announced to the screen reader.\n   * @param politeness The politeness of the announcer element.\n   * @param duration Time in milliseconds after which to clear out the announcer element. Note\n   *   that this takes effect after the message has been added to the DOM, which can be up to\n   *   100ms after `announce` has been called.\n   * @returns Promise that will be resolved when the message is added to the DOM.\n   */\n  announce(message: string, politeness?: AriaLivePoliteness, duration?: number): Promise<void>;\n\n  announce(message: string, ...args: any[]): Promise<void> {\n    const defaultOptions = this._defaultOptions;\n    let politeness: AriaLivePoliteness | undefined;\n    let duration: number | undefined;\n\n    if (args.length === 1 && typeof args[0] === 'number') {\n      duration = args[0];\n    } else {\n      [politeness, duration] = args;\n    }\n\n    this.clear();\n    clearTimeout(this._previousTimeout);\n\n    if (!politeness) {\n      politeness =\n        defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : 'polite';\n    }\n\n    if (duration == null && defaultOptions) {\n      duration = defaultOptions.duration;\n    }\n\n    // TODO: ensure changing the politeness works on all environments we support.\n    this._liveElement.setAttribute('aria-live', politeness);\n\n    if (this._liveElement.id) {\n      this._exposeAnnouncerToModals(this._liveElement.id);\n    }\n\n    // This 100ms timeout is necessary for some browser + screen-reader combinations:\n    // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n    // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n    //   second time without clearing and then using a non-zero delay.\n    // (using JAWS 17 at time of this writing).\n    return this._ngZone.runOutsideAngular(() => {\n      if (!this._currentPromise) {\n        this._currentPromise = new Promise(resolve => (this._currentResolve = resolve));\n      }\n\n      clearTimeout(this._previousTimeout);\n      this._previousTimeout = setTimeout(() => {\n        this._liveElement.textContent = message;\n\n        if (typeof duration === 'number') {\n          this._previousTimeout = setTimeout(() => this.clear(), duration);\n        }\n\n        // For some reason in tests this can be undefined\n        // Probably related to ZoneJS and every other thing that patches browser APIs in tests\n        this._currentResolve?.();\n        this._currentPromise = this._currentResolve = undefined;\n      }, 100);\n\n      return this._currentPromise;\n    });\n  }\n\n  /**\n   * Clears the current text from the announcer element. Can be used to prevent\n   * screen readers from reading the text out again while the user is going\n   * through the page landmarks.\n   */\n  clear() {\n    if (this._liveElement) {\n      this._liveElement.textContent = '';\n    }\n  }\n\n  ngOnDestroy() {\n    clearTimeout(this._previousTimeout);\n    this._liveElement?.remove();\n    this._liveElement = null!;\n    this._currentResolve?.();\n    this._currentPromise = this._currentResolve = undefined;\n  }\n\n  private _createLiveElement(): HTMLElement {\n    const elementClass = 'cdk-live-announcer-element';\n    const previousElements = this._document.getElementsByClassName(elementClass);\n    const liveEl = this._document.createElement('div');\n\n    // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n    for (let i = 0; i < previousElements.length; i++) {\n      previousElements[i].remove();\n    }\n\n    liveEl.classList.add(elementClass);\n    liveEl.classList.add('cdk-visually-hidden');\n\n    liveEl.setAttribute('aria-atomic', 'true');\n    liveEl.setAttribute('aria-live', 'polite');\n    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;\n\n    this._document.body.appendChild(liveEl);\n\n    return liveEl;\n  }\n\n  /**\n   * Some browsers won't expose the accessibility node of the live announcer element if there is an\n   * `aria-modal` and the live announcer is outside of it. This method works around the issue by\n   * pointing the `aria-owns` of all modals to the live announcer element.\n   */\n  private _exposeAnnouncerToModals(id: string) {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `SnakBarContainer` and other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modals = this._document.querySelectorAll(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    for (let i = 0; i < modals.length; i++) {\n      const modal = modals[i];\n      const ariaOwns = modal.getAttribute('aria-owns');\n\n      if (!ariaOwns) {\n        modal.setAttribute('aria-owns', id);\n      } else if (ariaOwns.indexOf(id) === -1) {\n        modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n      }\n    }\n  }\n}\n\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\n@Directive({\n  selector: '[cdkAriaLive]',\n  exportAs: 'cdkAriaLive',\n})\nexport class CdkAriaLive implements OnDestroy {\n  private _elementRef = inject(ElementRef);\n  private _liveAnnouncer = inject(LiveAnnouncer);\n  private _contentObserver = inject(ContentObserver);\n  private _ngZone = inject(NgZone);\n\n  /** The aria-live politeness level to use when announcing messages. */\n  @Input('cdkAriaLive')\n  get politeness(): AriaLivePoliteness {\n    return this._politeness;\n  }\n  set politeness(value: AriaLivePoliteness) {\n    this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n    if (this._politeness === 'off') {\n      if (this._subscription) {\n        this._subscription.unsubscribe();\n        this._subscription = null;\n      }\n    } else if (!this._subscription) {\n      this._subscription = this._ngZone.runOutsideAngular(() => {\n        return this._contentObserver.observe(this._elementRef).subscribe(() => {\n          // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n          const elementText = this._elementRef.nativeElement.textContent;\n\n          // The `MutationObserver` fires also for attribute\n          // changes which we don't want to announce.\n          if (elementText !== this._previousAnnouncedText) {\n            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);\n            this._previousAnnouncedText = elementText;\n          }\n        });\n      });\n    }\n  }\n  private _politeness: AriaLivePoliteness = 'polite';\n\n  /** Time in milliseconds after which to clear out the announcer element. */\n  @Input('cdkAriaLiveDuration') duration: number;\n\n  private _previousAnnouncedText?: string;\n  private _subscription: Subscription | null;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n  }\n\n  ngOnDestroy() {\n    if (this._subscription) {\n      this._subscription.unsubscribe();\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injectable, OnDestroy, DOCUMENT} from '@angular/core';\nimport {BreakpointObserver} from '../../layout';\nimport {Platform} from '../../platform';\n\nimport {Subscription} from 'rxjs';\n\n/** Set of possible high-contrast mode backgrounds. */\nexport enum HighContrastMode {\n  NONE,\n  BLACK_ON_WHITE,\n  WHITE_ON_BLACK,\n}\n\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nexport const BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nexport const WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n\n/** CSS class applied to the document body when in high-contrast mode. */\nexport const HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\n\n/**\n * Service to determine whether the browser is currently in a high-contrast-mode environment.\n *\n * Microsoft Windows supports an accessibility feature called \"High Contrast Mode\". This mode\n * changes the appearance of all applications, including web applications, to dramatically increase\n * contrast.\n *\n * IE, Edge, and Firefox currently support this mode. Chrome does not support Windows High Contrast\n * Mode. This service does not detect high-contrast mode as added by the Chrome \"High Contrast\"\n * browser extension.\n */\n@Injectable({providedIn: 'root'})\nexport class HighContrastModeDetector implements OnDestroy {\n  private _platform = inject(Platform);\n\n  /**\n   * Figuring out the high contrast mode and adding the body classes can cause\n   * some expensive layouts. This flag is used to ensure that we only do it once.\n   */\n  private _hasCheckedHighContrastMode: boolean;\n  private _document = inject(DOCUMENT);\n  private _breakpointSubscription: Subscription;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    this._breakpointSubscription = inject(BreakpointObserver)\n      .observe('(forced-colors: active)')\n      .subscribe(() => {\n        if (this._hasCheckedHighContrastMode) {\n          this._hasCheckedHighContrastMode = false;\n          this._applyBodyHighContrastModeCssClasses();\n        }\n      });\n  }\n\n  /** Gets the current high-contrast-mode for the page. */\n  getHighContrastMode(): HighContrastMode {\n    if (!this._platform.isBrowser) {\n      return HighContrastMode.NONE;\n    }\n\n    // Create a test element with an arbitrary background-color that is neither black nor\n    // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n    // appending the test element to the DOM does not affect layout by absolutely positioning it\n    const testElement = this._document.createElement('div');\n    testElement.style.backgroundColor = 'rgb(1,2,3)';\n    testElement.style.position = 'absolute';\n    this._document.body.appendChild(testElement);\n\n    // Get the computed style for the background color, collapsing spaces to normalize between\n    // browsers. Once we get this color, we no longer need the test element. Access the `window`\n    // via the document so we can fake it in tests. Note that we have extra null checks, because\n    // this logic will likely run during app bootstrap and throwing can break the entire app.\n    const documentWindow = this._document.defaultView || window;\n    const computedStyle =\n      documentWindow && documentWindow.getComputedStyle\n        ? documentWindow.getComputedStyle(testElement)\n        : null;\n    const computedColor = ((computedStyle && computedStyle.backgroundColor) || '').replace(\n      / /g,\n      '',\n    );\n    testElement.remove();\n\n    switch (computedColor) {\n      // Pre Windows 11 dark theme.\n      case 'rgb(0,0,0)':\n      // Windows 11 dark themes.\n      case 'rgb(45,50,54)':\n      case 'rgb(32,32,32)':\n        return HighContrastMode.WHITE_ON_BLACK;\n      // Pre Windows 11 light theme.\n      case 'rgb(255,255,255)':\n      // Windows 11 light theme.\n      case 'rgb(255,250,239)':\n        return HighContrastMode.BLACK_ON_WHITE;\n    }\n    return HighContrastMode.NONE;\n  }\n\n  ngOnDestroy(): void {\n    this._breakpointSubscription.unsubscribe();\n  }\n\n  /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n  _applyBodyHighContrastModeCssClasses(): void {\n    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {\n      const bodyClasses = this._document.body.classList;\n      bodyClasses.remove(\n        HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS,\n        BLACK_ON_WHITE_CSS_CLASS,\n        WHITE_ON_BLACK_CSS_CLASS,\n      );\n      this._hasCheckedHighContrastMode = true;\n\n      const mode = this.getHighContrastMode();\n      if (mode === HighContrastMode.BLACK_ON_WHITE) {\n        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);\n      } else if (mode === HighContrastMode.WHITE_ON_BLACK) {\n        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ObserversModule} from '../observers';\nimport {NgModule, inject} from '@angular/core';\nimport {CdkMonitorFocus} from './focus-monitor/focus-monitor';\nimport {CdkTrapFocus} from './focus-trap/focus-trap';\nimport {HighContrastModeDetector} from './high-contrast-mode/high-contrast-mode-detector';\nimport {CdkAriaLive} from './live-announcer/live-announcer';\n\n@NgModule({\n  imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n  exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n})\nexport class A11yModule {\n  constructor() {\n    inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** IDs are delimited by an empty space, as per the spec. */\nconst ID_DELIMITER = ' ';\n\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nexport function addAriaReferencedId(el: Element, attr: `aria-${string}`, id: string) {\n  const ids = getAriaReferenceIds(el, attr);\n  id = id.trim();\n  if (ids.some(existingId => existingId.trim() === id)) {\n    return;\n  }\n  ids.push(id);\n\n  el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nexport function removeAriaReferencedId(el: Element, attr: `aria-${string}`, id: string) {\n  const ids = getAriaReferenceIds(el, attr);\n  id = id.trim();\n  const filteredIds = ids.filter(val => val !== id);\n\n  if (filteredIds.length) {\n    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nexport function getAriaReferenceIds(el: Element, attr: string): string[] {\n  // Get string array of all individual ids (whitespace delimited) in the attribute value\n  const attrValue = el.getAttribute(attr);\n  return attrValue?.match(/\\S+/g) ?? [];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, OnDestroy, APP_ID, inject, DOCUMENT} from '@angular/core';\nimport {Platform} from '../../platform';\nimport {addAriaReferencedId, getAriaReferenceIds, removeAriaReferencedId} from './aria-reference';\nimport {_CdkPrivateStyleLoader, _VisuallyHiddenLoader} from '../../private';\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n */\nexport interface RegisteredMessage {\n  /** The element containing the message. */\n  messageElement: Element;\n\n  /** The number of elements that reference this message element via `aria-describedby`. */\n  referenceCount: number;\n}\n\n/**\n * ID used for the body container where all messages are appended.\n * @deprecated No longer being used. To be removed.\n * @breaking-change 14.0.0\n */\nexport const MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n\n/**\n * ID prefix used for each created message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nexport const CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n\n/**\n * Attribute given to each host element that is described by a message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nexport const CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n */\n@Injectable({providedIn: 'root'})\nexport class AriaDescriber implements OnDestroy {\n  private _platform = inject(Platform);\n  private _document = inject(DOCUMENT);\n\n  /** Map of all registered message elements that have been placed into the document. */\n  private _messageRegistry = new Map<string | Element, RegisteredMessage>();\n\n  /** Container for all registered messages. */\n  private _messagesContainer: HTMLElement | null = null;\n\n  /** Unique ID for the service. */\n  private readonly _id = `${nextId++}`;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n    this._id = inject(APP_ID) + '-' + nextId++;\n  }\n\n  /**\n   * Adds to the host element an aria-describedby reference to a hidden element that contains\n   * the message. If the same message has already been registered, then it will reuse the created\n   * message element.\n   */\n  describe(hostElement: Element, message: string, role?: string): void;\n\n  /**\n   * Adds to the host element an aria-describedby reference to an already-existing message element.\n   */\n  describe(hostElement: Element, message: HTMLElement): void;\n\n  describe(hostElement: Element, message: string | HTMLElement, role?: string): void {\n    if (!this._canBeDescribed(hostElement, message)) {\n      return;\n    }\n\n    const key = getKey(message, role);\n\n    if (typeof message !== 'string') {\n      // We need to ensure that the element has an ID.\n      setMessageId(message, this._id);\n      this._messageRegistry.set(key, {messageElement: message, referenceCount: 0});\n    } else if (!this._messageRegistry.has(key)) {\n      this._createMessageElement(message, role);\n    }\n\n    if (!this._isElementDescribedByMessage(hostElement, key)) {\n      this._addMessageReference(hostElement, key);\n    }\n  }\n\n  /** Removes the host element's aria-describedby reference to the message. */\n  removeDescription(hostElement: Element, message: string, role?: string): void;\n\n  /** Removes the host element's aria-describedby reference to the message element. */\n  removeDescription(hostElement: Element, message: HTMLElement): void;\n\n  removeDescription(hostElement: Element, message: string | HTMLElement, role?: string): void {\n    if (!message || !this._isElementNode(hostElement)) {\n      return;\n    }\n\n    const key = getKey(message, role);\n\n    if (this._isElementDescribedByMessage(hostElement, key)) {\n      this._removeMessageReference(hostElement, key);\n    }\n\n    // If the message is a string, it means that it's one that we created for the\n    // consumer so we can remove it safely, otherwise we should leave it in place.\n    if (typeof message === 'string') {\n      const registeredMessage = this._messageRegistry.get(key);\n      if (registeredMessage && registeredMessage.referenceCount === 0) {\n        this._deleteMessageElement(key);\n      }\n    }\n\n    if (this._messagesContainer?.childNodes.length === 0) {\n      this._messagesContainer.remove();\n      this._messagesContainer = null;\n    }\n  }\n\n  /** Unregisters all created message elements and removes the message container. */\n  ngOnDestroy() {\n    const describedElements = this._document.querySelectorAll(\n      `[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}=\"${this._id}\"]`,\n    );\n\n    for (let i = 0; i < describedElements.length; i++) {\n      this._removeCdkDescribedByReferenceIds(describedElements[i]);\n      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    }\n\n    this._messagesContainer?.remove();\n    this._messagesContainer = null;\n    this._messageRegistry.clear();\n  }\n\n  /**\n   * Creates a new element in the visually hidden message container element with the message\n   * as its content and adds it to the message registry.\n   */\n  private _createMessageElement(message: string, role?: string) {\n    const messageElement = this._document.createElement('div');\n    setMessageId(messageElement, this._id);\n    messageElement.textContent = message;\n\n    if (role) {\n      messageElement.setAttribute('role', role);\n    }\n\n    this._createMessagesContainer();\n    this._messagesContainer!.appendChild(messageElement);\n    this._messageRegistry.set(getKey(message, role), {messageElement, referenceCount: 0});\n  }\n\n  /** Deletes the message element from the global messages container. */\n  private _deleteMessageElement(key: string | Element) {\n    this._messageRegistry.get(key)?.messageElement?.remove();\n    this._messageRegistry.delete(key);\n  }\n\n  /** Creates the global container for all aria-describedby messages. */\n  private _createMessagesContainer() {\n    if (this._messagesContainer) {\n      return;\n    }\n\n    const containerClassName = 'cdk-describedby-message-container';\n    const serverContainers = this._document.querySelectorAll(\n      `.${containerClassName}[platform=\"server\"]`,\n    );\n\n    for (let i = 0; i < serverContainers.length; i++) {\n      // When going from the server to the client, we may end up in a situation where there's\n      // already a container on the page, but we don't have a reference to it. Clear the\n      // old container so we don't get duplicates. Doing this, instead of emptying the previous\n      // container, should be slightly faster.\n      serverContainers[i].remove();\n    }\n\n    const messagesContainer = this._document.createElement('div');\n\n    // We add `visibility: hidden` in order to prevent text in this container from\n    // being searchable by the browser's Ctrl + F functionality.\n    // Screen-readers will still read the description for elements with aria-describedby even\n    // when the description element is not visible.\n    messagesContainer.style.visibility = 'hidden';\n    // Even though we use `visibility: hidden`, we still apply `cdk-visually-hidden` so that\n    // the description element doesn't impact page layout.\n    messagesContainer.classList.add(containerClassName);\n    messagesContainer.classList.add('cdk-visually-hidden');\n\n    if (!this._platform.isBrowser) {\n      messagesContainer.setAttribute('platform', 'server');\n    }\n\n    this._document.body.appendChild(messagesContainer);\n    this._messagesContainer = messagesContainer;\n  }\n\n  /** Removes all cdk-describedby messages that are hosted through the element. */\n  private _removeCdkDescribedByReferenceIds(element: Element) {\n    // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n    const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby').filter(\n      id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0,\n    );\n    element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n  }\n\n  /**\n   * Adds a message reference to the element using aria-describedby and increments the registered\n   * message's reference count.\n   */\n  private _addMessageReference(element: Element, key: string | Element) {\n    const registeredMessage = this._messageRegistry.get(key)!;\n\n    // Add the aria-describedby reference and set the\n    // describedby_host attribute to mark the element.\n    addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);\n    registeredMessage.referenceCount++;\n  }\n\n  /**\n   * Removes a message reference from the element using aria-describedby\n   * and decrements the registered message's reference count.\n   */\n  private _removeMessageReference(element: Element, key: string | Element) {\n    const registeredMessage = this._messageRegistry.get(key)!;\n    registeredMessage.referenceCount--;\n\n    removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n  }\n\n  /** Returns true if the element has been described by the provided message ID. */\n  private _isElementDescribedByMessage(element: Element, key: string | Element): boolean {\n    const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n    const registeredMessage = this._messageRegistry.get(key);\n    const messageId = registeredMessage && registeredMessage.messageElement.id;\n\n    return !!messageId && referenceIds.indexOf(messageId) != -1;\n  }\n\n  /** Determines whether a message can be described on a particular element. */\n  private _canBeDescribed(element: Element, message: string | HTMLElement | void): boolean {\n    if (!this._isElementNode(element)) {\n      return false;\n    }\n\n    if (message && typeof message === 'object') {\n      // We'd have to make some assumptions about the description element's text, if the consumer\n      // passed in an element. Assume that if an element is passed in, the consumer has verified\n      // that it can be used as a description.\n      return true;\n    }\n\n    const trimmedMessage = message == null ? '' : `${message}`.trim();\n    const ariaLabel = element.getAttribute('aria-label');\n\n    // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n    // element, because screen readers will end up reading out the same text twice in a row.\n    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;\n  }\n\n  /** Checks whether a node is an Element node. */\n  private _isElementNode(element: Node): element is Element {\n    return element.nodeType === this._document.ELEMENT_NODE;\n  }\n}\n\n/** Gets a key that can be used to look messages up in the registry. */\nfunction getKey(message: string | Element, role?: string): string | Element {\n  return typeof message === 'string' ? `${role || ''}/${message}` : message;\n}\n\n/** Assigns a unique ID to an element, if it doesn't have one already. */\nfunction setMessageId(element: HTMLElement, serviceId: string) {\n  if (!element.id) {\n    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Subject} from 'rxjs';\nimport {TREE_KEY_MANAGER} from './tree-key-manager';\nimport {\n  TreeKeyManagerFactory,\n  TreeKeyManagerItem,\n  TreeKeyManagerStrategy,\n} from './tree-key-manager-strategy';\nimport {Provider} from '@angular/core';\n\n// NoopTreeKeyManager is a \"noop\" implementation of TreeKeyMangerStrategy. Methods are noops. Does\n// not emit to streams.\n//\n// Used for applications built before TreeKeyManager to opt-out of TreeKeyManager and revert to\n// legacy behavior.\n/**\n * @docs-private\n *\n * Opt-out of Tree of key manager behavior.\n *\n * When provided, Tree has same focus management behavior as before TreeKeyManager was introduced.\n *  - Tree does not respond to keyboard interaction\n *  - Tree node allows tabindex to be set by Input binding\n *  - Tree node allows tabindex to be set by attribute binding\n *\n * @deprecated NoopTreeKeyManager deprecated. Use TreeKeyManager or inject a\n * TreeKeyManagerStrategy instead. To be removed in a future version.\n *\n * @breaking-change 21.0.0\n */\nexport class NoopTreeKeyManager<T extends TreeKeyManagerItem> implements TreeKeyManagerStrategy<T> {\n  readonly _isNoopTreeKeyManager = true;\n\n  // Provide change as required by TreeKeyManagerStrategy. NoopTreeKeyManager is a \"noop\"\n  // implementation that does not emit to streams.\n  readonly change = new Subject<T | null>();\n\n  destroy() {\n    this.change.complete();\n  }\n\n  onKeydown() {\n    // noop\n  }\n\n  getActiveItemIndex() {\n    // Always return null. NoopTreeKeyManager is a \"noop\" implementation that does not maintain\n    // the active item.\n    return null;\n  }\n\n  getActiveItem() {\n    // Always return null. NoopTreeKeyManager is a \"noop\" implementation that does not maintain\n    // the active item.\n    return null;\n  }\n\n  focusItem() {\n    // noop\n  }\n}\n\n/**\n * @docs-private\n *\n * Opt-out of Tree of key manager behavior.\n *\n * When provided, Tree has same focus management behavior as before TreeKeyManager was introduced.\n *  - Tree does not respond to keyboard interaction\n *  - Tree node allows tabindex to be set by Input binding\n *  - Tree node allows tabindex to be set by attribute binding\n *\n * @deprecated NoopTreeKeyManager deprecated. Use TreeKeyManager or inject a\n * TreeKeyManagerStrategy instead. To be removed in a future version.\n *\n * @breaking-change 21.0.0\n */\nexport function NOOP_TREE_KEY_MANAGER_FACTORY<\n  T extends TreeKeyManagerItem,\n>(): TreeKeyManagerFactory<T> {\n  return () => new NoopTreeKeyManager<T>();\n}\n\n/**\n * @docs-private\n *\n * Opt-out of Tree of key manager behavior.\n *\n * When provided, Tree has same focus management behavior as before TreeKeyManager was introduced.\n *  - Tree does not respond to keyboard interaction\n *  - Tree node allows tabindex to be set by Input binding\n *  - Tree node allows tabindex to be set by attribute binding\n *\n * @deprecated NoopTreeKeyManager deprecated. Use TreeKeyManager or inject a\n * TreeKeyManagerStrategy instead. To be removed in a future version.\n *\n * @breaking-change 21.0.0\n */\nexport const NOOP_TREE_KEY_MANAGER_FACTORY_PROVIDER: Provider = {\n  provide: TREE_KEY_MANAGER,\n  useFactory: NOOP_TREE_KEY_MANAGER_FACTORY,\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, NgZone} from '@angular/core';\nimport {InteractivityChecker} from '../interactivity-checker/interactivity-checker';\nimport {ConfigurableFocusTrapConfig} from './configurable-focus-trap-config';\nimport {FocusTrap} from './focus-trap';\nimport {FocusTrapInertStrategy} from './focus-trap-inert-strategy';\nimport {FocusTrapManager, ManagedFocusTrap} from './focus-trap-manager';\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nexport class ConfigurableFocusTrap extends FocusTrap implements ManagedFocusTrap {\n  /** Whether the FocusTrap is enabled. */\n  override get enabled(): boolean {\n    return this._enabled;\n  }\n  override set enabled(value: boolean) {\n    this._enabled = value;\n    if (this._enabled) {\n      this._focusTrapManager.register(this);\n    } else {\n      this._focusTrapManager.deregister(this);\n    }\n  }\n\n  constructor(\n    _element: HTMLElement,\n    _checker: InteractivityChecker,\n    _ngZone: NgZone,\n    _document: Document,\n    private _focusTrapManager: FocusTrapManager,\n    private _inertStrategy: FocusTrapInertStrategy,\n    config: ConfigurableFocusTrapConfig,\n    injector?: Injector,\n  ) {\n    super(_element, _checker, _ngZone, _document, config.defer, injector);\n    this._focusTrapManager.register(this);\n  }\n\n  /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n  override destroy() {\n    this._focusTrapManager.deregister(this);\n    super.destroy();\n  }\n\n  /** @docs-private Implemented as part of ManagedFocusTrap. */\n  _enable() {\n    this._inertStrategy.preventFocus(this);\n    this.toggleAnchors(true);\n  }\n\n  /** @docs-private Implemented as part of ManagedFocusTrap. */\n  _disable() {\n    this._inertStrategy.allowFocus(this);\n    this.toggleAnchors(false);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FocusTrapInertStrategy} from './focus-trap-inert-strategy';\nimport {ConfigurableFocusTrap} from './configurable-focus-trap';\n\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nexport class EventListenerFocusTrapInertStrategy implements FocusTrapInertStrategy {\n  /** Focus event handler. */\n  private _listener: ((e: FocusEvent) => void) | null = null;\n\n  /** Adds a document event listener that keeps focus inside the FocusTrap. */\n  preventFocus(focusTrap: ConfigurableFocusTrap): void {\n    // Ensure there's only one listener per document\n    if (this._listener) {\n      focusTrap._document.removeEventListener('focus', this._listener!, true);\n    }\n\n    this._listener = (e: FocusEvent) => this._trapFocus(focusTrap, e);\n    focusTrap._ngZone.runOutsideAngular(() => {\n      focusTrap._document.addEventListener('focus', this._listener!, true);\n    });\n  }\n\n  /** Removes the event listener added in preventFocus. */\n  allowFocus(focusTrap: ConfigurableFocusTrap): void {\n    if (!this._listener) {\n      return;\n    }\n    focusTrap._document.removeEventListener('focus', this._listener!, true);\n    this._listener = null;\n  }\n\n  /**\n   * Refocuses the first element in the FocusTrap if the focus event target was outside\n   * the FocusTrap.\n   *\n   * This is an event listener callback. The event listener is added in runOutsideAngular,\n   * so all this code runs outside Angular as well.\n   */\n  private _trapFocus(focusTrap: ConfigurableFocusTrap, event: FocusEvent) {\n    const target = event.target as HTMLElement;\n    const focusTrapRoot = focusTrap._element;\n\n    // Don't refocus if target was in an overlay, because the overlay might be associated\n    // with an element inside the FocusTrap, ex. mat-select.\n    if (target && !focusTrapRoot.contains(target) && !target.closest?.('div.cdk-overlay-pane')) {\n      // Some legacy FocusTrap usages have logic that focuses some element on the page\n      // just before FocusTrap is destroyed. For backwards compatibility, wait\n      // to be sure FocusTrap is still enabled before refocusing.\n      setTimeout(() => {\n        // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n          focusTrap.focusFirstTabbableElement();\n        }\n      });\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {InjectionToken} from '@angular/core';\nimport {FocusTrap} from './focus-trap';\n\n/** The injection token used to specify the inert strategy. */\nexport const FOCUS_TRAP_INERT_STRATEGY = new InjectionToken<FocusTrapInertStrategy>(\n  'FOCUS_TRAP_INERT_STRATEGY',\n);\n\n/**\n * A strategy that dictates how FocusTrap should prevent elements\n * outside of the FocusTrap from being focused.\n */\nexport interface FocusTrapInertStrategy {\n  /** Makes all elements outside focusTrap unfocusable. */\n  preventFocus(focusTrap: FocusTrap): void;\n  /** Reverts elements made unfocusable by preventFocus to their previous state. */\n  allowFocus(focusTrap: FocusTrap): void;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable} from '@angular/core';\n\n/**\n * A FocusTrap managed by FocusTrapManager.\n * Implemented by ConfigurableFocusTrap to avoid circular dependency.\n */\nexport interface ManagedFocusTrap {\n  _enable(): void;\n  _disable(): void;\n  focusInitialElementWhenReady(): Promise<boolean>;\n}\n\n/** Injectable that ensures only the most recently enabled FocusTrap is active. */\n@Injectable({providedIn: 'root'})\nexport class FocusTrapManager {\n  // A stack of the FocusTraps on the page. Only the FocusTrap at the\n  // top of the stack is active.\n  private _focusTrapStack: ManagedFocusTrap[] = [];\n\n  /**\n   * Disables the FocusTrap at the top of the stack, and then pushes\n   * the new FocusTrap onto the stack.\n   */\n  register(focusTrap: ManagedFocusTrap): void {\n    // Dedupe focusTraps that register multiple times.\n    this._focusTrapStack = this._focusTrapStack.filter(ft => ft !== focusTrap);\n\n    let stack = this._focusTrapStack;\n\n    if (stack.length) {\n      stack[stack.length - 1]._disable();\n    }\n\n    stack.push(focusTrap);\n    focusTrap._enable();\n  }\n\n  /**\n   * Removes the FocusTrap from the stack, and activates the\n   * FocusTrap that is the new top of the stack.\n   */\n  deregister(focusTrap: ManagedFocusTrap): void {\n    focusTrap._disable();\n\n    const stack = this._focusTrapStack;\n\n    const i = stack.indexOf(focusTrap);\n    if (i !== -1) {\n      stack.splice(i, 1);\n      if (stack.length) {\n        stack[stack.length - 1]._enable();\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injectable, Injector, NgZone, inject, DOCUMENT} from '@angular/core';\nimport {InteractivityChecker} from '../interactivity-checker/interactivity-checker';\nimport {ConfigurableFocusTrap} from './configurable-focus-trap';\nimport {ConfigurableFocusTrapConfig} from './configurable-focus-trap-config';\nimport {EventListenerFocusTrapInertStrategy} from './event-listener-inert-strategy';\nimport {FOCUS_TRAP_INERT_STRATEGY, FocusTrapInertStrategy} from './focus-trap-inert-strategy';\nimport {FocusTrapManager} from './focus-trap-manager';\n\n/** Factory that allows easy instantiation of configurable focus traps. */\n@Injectable({providedIn: 'root'})\nexport class ConfigurableFocusTrapFactory {\n  private _checker = inject(InteractivityChecker);\n  private _ngZone = inject(NgZone);\n  private _focusTrapManager = inject(FocusTrapManager);\n\n  private _document = inject(DOCUMENT);\n  private _inertStrategy: FocusTrapInertStrategy;\n\n  private readonly _injector = inject(Injector);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const inertStrategy = inject(FOCUS_TRAP_INERT_STRATEGY, {optional: true});\n\n    // TODO split up the strategies into different modules, similar to DateAdapter.\n    this._inertStrategy = inertStrategy || new EventListenerFocusTrapInertStrategy();\n  }\n\n  /**\n   * Creates a focus-trapped region around the given element.\n   * @param element The element around which focus will be trapped.\n   * @param config The focus trap configuration.\n   * @returns The created focus trap instance.\n   */\n  create(element: HTMLElement, config?: ConfigurableFocusTrapConfig): ConfigurableFocusTrap;\n\n  /**\n   * @deprecated Pass a config object instead of the `deferCaptureElements` flag.\n   * @breaking-change 11.0.0\n   */\n  create(element: HTMLElement, deferCaptureElements: boolean): ConfigurableFocusTrap;\n\n  create(\n    element: HTMLElement,\n    config: ConfigurableFocusTrapConfig | boolean = {defer: false},\n  ): ConfigurableFocusTrap {\n    let configObject: ConfigurableFocusTrapConfig;\n    if (typeof config === 'boolean') {\n      configObject = {defer: config};\n    } else {\n      configObject = config;\n    }\n    return new ConfigurableFocusTrap(\n      element,\n      this._checker,\n      this._ngZone,\n      this._document,\n      this._focusTrapManager,\n      this._inertStrategy,\n      configObject,\n      this._injector,\n    );\n  }\n}\n", "import { Component } from '@angular/core';\r\nimport { A11yModule } from '@angular/cdk/a11y';\r\nimport { Button1 } from '../../shared/button1/button1';\r\nimport { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { Button } from '../../shared/button/button';\r\nimport { Section1 } from './section-1/section-1';\r\n\r\n@Component({\r\n  selector: 'app-contact',\r\n  standalone: true,\r\n  imports: [Button1, ReactiveFormsModule, Button, Section1, A11yModule],\r\n  templateUrl: './contact.html',\r\n  styleUrl: './contact.css'\r\n})\r\nexport class Contact {\r\n  profileForm = new FormGroup({\r\n    userName: new FormControl('', [\r\n      Validators.required,\r\n      Validators.minLength(6)\r\n    ]),\r\n    email: new FormControl('', [\r\n      Validators.required,\r\n      Validators.minLength(6),\r\n      Validators.email\r\n    ]),\r\n    password: new FormControl('', [\r\n      Validators.required,\r\n      Validators.minLength(8),\r\n    ])\r\n  });\r\n\r\n  formValues: any;\r\n\r\n  onSubmit() {\r\n    if (this.profileForm.valid) {\r\n      this.formValues = this.profileForm.value;\r\n      this.profileForm.reset();\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.formValues = this.profileForm.reset();\r\n  }\r\n\r\n  receivedMessage: string = '...waiting for message';\r\n\r\n  receiveMessage(message: string) {\r\n    this.receivedMessage = message;\r\n  }\r\n}\r\n", "import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { Contact } from './contact';\r\nimport { ReactiveFormsModule } from '@angular/forms';\r\n\r\ndescribe('Contact', () => {\r\n  let component: Contact;\r\n  let fixture: ComponentFixture<Contact>;\r\n\r\n  beforeEach(async () => {\r\n    await TestBed.configureTestingModule({\r\n      imports: [Contact, ReactiveFormsModule]\r\n    })\r\n      .compileComponents();\r\n\r\n    fixture = TestBed.createComponent(Contact);\r\n    component = fixture.componentInstance;\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create contact', () => {\r\n    expect(component).toBeTruthy();\r\n  })\r\n\r\n  it('should be invalid when profileForm is empty', () => {\r\n    expect(component.profileForm.valid).toBeFalsy();\r\n  })\r\n\r\n  it('should validate userName', () => {\r\n    const userName = component.profileForm.controls['userName'];\r\n    userName.setValue('Vat');\r\n    expect(userName.valid).toBeFalse();\r\n\r\n    userName.setValue('Vatsal');\r\n    expect(userName.valid).toBeTrue();\r\n  })\r\n\r\n  it('should validate email', () => {\r\n    const userName = component.profileForm.controls['email'];\r\n    userName.setValue('vatsal');\r\n    expect(userName.valid).toBeFalse();\r\n\r\n    userName.setValue('Vatsal');\r\n    expect(userName.valid).toBeTrue();\r\n  })\r\n\r\n  it('should validate userName', () => {\r\n    const userName = component.profileForm.controls['userName'];\r\n    userName.setValue('Vat');\r\n    expect(userName.valid).toBeFalse();\r\n\r\n    userName.setValue('Vatsal');\r\n    expect(userName.valid).toBeTrue();\r\n  })\r\n});\r\n"],
  "mappings": "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",
  "names": ["contact_default", "init_contact", "document", "FocusMonitorDetectionMode", "observableOf", "window", "window", "HighContrastMode", "cov_qpxki1azj", "actualCoverage", "Contact", "s", "profileForm", "FormGroup", "userName", "FormControl", "Validators", "required", "minLength", "email", "password", "formValues", "onSubmit", "f", "valid", "b", "value", "reset", "receivedMessage", "receiveMessage", "message", "__decorate", "Component", "selector", "standalone", "imports", "Button1", "ReactiveFormsModule", "Button", "Section1", "A11yModule", "template", "__NG_CLI_RESOURCE__0", "init_contact"]
}
